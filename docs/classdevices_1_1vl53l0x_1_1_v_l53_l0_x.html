<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>FastArduino: devices::vl53l0x::VL53L0X&lt; MANAGER &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">FastArduino
   &#160;<span id="projectnumber">v1.9</span>
   </div>
   <div id="projectbrief">C++ library to build fast but small Arduino/AVR projects</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">devices::vl53l0x::VL53L0X&lt; MANAGER &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>I2C device driver for the <a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html" title="I2C device driver for the VL53L0X ToF ranging chip.">VL53L0X</a> ToF ranging chip.  
 <a href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="vl53l0x_8h_source.html">fastarduino/devices/vl53l0x.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for devices::vl53l0x::VL53L0X&lt; MANAGER &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classdevices_1_1vl53l0x_1_1_v_l53_l0_x__inherit__graph.png" border="0" usemap="#adevices_1_1vl53l0x_1_1_v_l53_l0_x_3_01_m_a_n_a_g_e_r_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="adevices_1_1vl53l0x_1_1_v_l53_l0_x_3_01_m_a_n_a_g_e_r_01_4_inherit__map" id="adevices_1_1vl53l0x_1_1_v_l53_l0_x_3_01_m_a_n_a_g_e_r_01_4_inherit__map">
<area shape="rect" title="I2C device driver for the VL53L0X ToF ranging chip." alt="" coords="21,80,188,121"/>
<area shape="rect" href="classi2c_1_1_i2_c_device.html" title=" " alt="" coords="5,5,204,32"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for devices::vl53l0x::VL53L0X&lt; MANAGER &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classdevices_1_1vl53l0x_1_1_v_l53_l0_x__coll__graph.png" border="0" usemap="#adevices_1_1vl53l0x_1_1_v_l53_l0_x_3_01_m_a_n_a_g_e_r_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="adevices_1_1vl53l0x_1_1_v_l53_l0_x_3_01_m_a_n_a_g_e_r_01_4_coll__map" id="adevices_1_1vl53l0x_1_1_v_l53_l0_x_3_01_m_a_n_a_g_e_r_01_4_coll__map">
<area shape="rect" title="I2C device driver for the VL53L0X ToF ranging chip." alt="" coords="21,80,188,121"/>
<area shape="rect" href="classi2c_1_1_i2_c_device.html" title=" " alt="" coords="5,5,204,32"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x_1_1_get_g_p_i_o_settings_future.html">GetGPIOSettingsFuture</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Future to get device current GPIO settings.  <a href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x_1_1_get_g_p_i_o_settings_future.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x_1_1_set_g_p_i_o_settings_future.html">SetGPIOSettingsFuture</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Future to set device GPIO settings.  <a href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x_1_1_set_g_p_i_o_settings_future.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ae755d8e7d051d0969d1d9310dca57f2d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#ae755d8e7d051d0969d1d9310dca57f2d">GetRangeStatusFuture</a> = <a class="el" href="classi2c_1_1_t_read_register_future.html">TReadRegisterFuture</a>&lt; Register::RESULT_RANGE_STATUS, <a class="el" href="classdevices_1_1vl53l0x_1_1_device_status.html">DeviceStatus</a> &gt;</td></tr>
<tr class="memdesc:ae755d8e7d051d0969d1d9310dca57f2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Future to get device range status.  <a href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#ae755d8e7d051d0969d1d9310dca57f2d">More...</a><br /></td></tr>
<tr class="separator:ae755d8e7d051d0969d1d9310dca57f2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9805d95efcc5eaa1a0842f3c8e09191c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#a9805d95efcc5eaa1a0842f3c8e09191c">GetInterruptStatusFuture</a> = <a class="el" href="classi2c_1_1_t_read_register_future.html">TReadRegisterFuture</a>&lt; Register::RESULT_INTERRUPT_STATUS, InterruptStatus &gt;</td></tr>
<tr class="memdesc:a9805d95efcc5eaa1a0842f3c8e09191c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Future to get device current interrupt status.  <a href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#a9805d95efcc5eaa1a0842f3c8e09191c">More...</a><br /></td></tr>
<tr class="separator:a9805d95efcc5eaa1a0842f3c8e09191c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03993b90b542fc88f314620165f0b4b4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#a03993b90b542fc88f314620165f0b4b4">ClearInterruptFuture</a> = <a class="el" href="classi2c_1_1_t_write_register_future.html">TWriteRegisterFuture</a>&lt; Register::SYSTEM_INTERRUPT_CLEAR &gt;</td></tr>
<tr class="memdesc:a03993b90b542fc88f314620165f0b4b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Future to clear device interrupt status.  <a href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#a03993b90b542fc88f314620165f0b4b4">More...</a><br /></td></tr>
<tr class="separator:a03993b90b542fc88f314620165f0b4b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a636ae6705cb4cc2946acc8b89699703a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#a636ae6705cb4cc2946acc8b89699703a">GetDirectRangeFuture</a> = <a class="el" href="classi2c_1_1_t_read_register_future.html">TReadRegisterFuture</a>&lt; Register::RESULT_RANGE_MILLIMETER, uint16_t &gt;</td></tr>
<tr class="memdesc:a636ae6705cb4cc2946acc8b89699703a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Future to get device current range measure.  <a href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#a636ae6705cb4cc2946acc8b89699703a">More...</a><br /></td></tr>
<tr class="separator:a636ae6705cb4cc2946acc8b89699703a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classi2c_1_1_i2_c_device"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classi2c_1_1_i2_c_device')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classi2c_1_1_i2_c_device.html">i2c::I2CDevice&lt; MANAGER &gt;</a></td></tr>
<tr class="memitem:a7b3f6509519292904a636f4262b404ae inherit pub_types_classi2c_1_1_i2_c_device"><td class="memItemLeft" align="right" valign="top"><a id="a7b3f6509519292904a636f4262b404ae"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classi2c_1_1_i2_c_device.html#a7b3f6509519292904a636f4262b404ae">MANAGER</a> = <a class="el" href="classi2c_1_1_i2_c_device.html#a7b3f6509519292904a636f4262b404ae">MANAGER</a></td></tr>
<tr class="memdesc:a7b3f6509519292904a636f4262b404ae inherit pub_types_classi2c_1_1_i2_c_device"><td class="mdescLeft">&#160;</td><td class="mdescRight">the type of I2C Manager that can handle this device. <br /></td></tr>
<tr class="separator:a7b3f6509519292904a636f4262b404ae inherit pub_types_classi2c_1_1_i2_c_device"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae262ba2d39353efb8ff1964d64c30cd3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#ae262ba2d39353efb8ff1964d64c30cd3">VL53L0X</a> (<a class="el" href="classi2c_1_1_i2_c_device.html#a7b3f6509519292904a636f4262b404ae">MANAGER</a> &amp;manager)</td></tr>
<tr class="memdesc:ae262ba2d39353efb8ff1964d64c30cd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new device driver for a <a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html" title="I2C device driver for the VL53L0X ToF ranging chip.">VL53L0X</a> chip.  <a href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#ae262ba2d39353efb8ff1964d64c30cd3">More...</a><br /></td></tr>
<tr class="separator:ae262ba2d39353efb8ff1964d64c30cd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a6410f0460104502ce83eb7ef540a9b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#a7a6410f0460104502ce83eb7ef540a9b">set_address</a> (uint8_t device_address)</td></tr>
<tr class="memdesc:a7a6410f0460104502ce83eb7ef540a9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the I2C address of this <a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html" title="I2C device driver for the VL53L0X ToF ranging chip.">VL53L0X</a> device.  <a href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#a7a6410f0460104502ce83eb7ef540a9b">More...</a><br /></td></tr>
<tr class="separator:a7a6410f0460104502ce83eb7ef540a9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0ca4aab9ad8b6b7e76ca34ee29e2e68"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#aa0ca4aab9ad8b6b7e76ca34ee29e2e68">begin</a> (<a class="el" href="namespacedevices_1_1vl53l0x.html#af48a92ac24c4f93d2513d4969b4d5a67">Profile</a> profile)</td></tr>
<tr class="memdesc:aa0ca4aab9ad8b6b7e76ca34ee29e2e68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fully initialize this <a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html" title="I2C device driver for the VL53L0X ToF ranging chip.">VL53L0X</a> device and configures it with provided <code>profile</code>.  <a href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#aa0ca4aab9ad8b6b7e76ca34ee29e2e68">More...</a><br /></td></tr>
<tr class="separator:aa0ca4aab9ad8b6b7e76ca34ee29e2e68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4f4e6608fff114b29b5fc2a0239d66f"><td class="memTemplParams" colspan="2">template&lt;board::Timer TIMER&gt; </td></tr>
<tr class="memitem:ac4f4e6608fff114b29b5fc2a0239d66f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#ac4f4e6608fff114b29b5fc2a0239d66f">await_single_range</a> (<a class="el" href="classtimer_1_1_r_t_t.html">timer::RTT</a>&lt; TIMER &gt; &amp;rtt, uint16_t &amp;range_mm, uint16_t timeout_ms=DEFAULT_TIMEOUT_MS)</td></tr>
<tr class="memdesc:ac4f4e6608fff114b29b5fc2a0239d66f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a single range action on <a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html" title="I2C device driver for the VL53L0X ToF ranging chip.">VL53L0X</a> device, and wait for the measurement result.  <a href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#ac4f4e6608fff114b29b5fc2a0239d66f">More...</a><br /></td></tr>
<tr class="separator:ac4f4e6608fff114b29b5fc2a0239d66f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2f73ffeafc9aea3196af584ed39d49f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#ab2f73ffeafc9aea3196af584ed39d49f">start_continuous_ranging</a> (uint16_t period_ms=0)</td></tr>
<tr class="memdesc:ab2f73ffeafc9aea3196af584ed39d49f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start continuous ranging on this <a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html" title="I2C device driver for the VL53L0X ToF ranging chip.">VL53L0X</a> device.  <a href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#ab2f73ffeafc9aea3196af584ed39d49f">More...</a><br /></td></tr>
<tr class="separator:ab2f73ffeafc9aea3196af584ed39d49f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa483218a8665973bf86c444f9617539d"><td class="memTemplParams" colspan="2">template&lt;board::Timer TIMER&gt; </td></tr>
<tr class="memitem:aa483218a8665973bf86c444f9617539d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#aa483218a8665973bf86c444f9617539d">await_continuous_range</a> (<a class="el" href="classtimer_1_1_r_t_t.html">timer::RTT</a>&lt; TIMER &gt; &amp;rtt, uint16_t &amp;range_mm, uint16_t timeout_ms=DEFAULT_TIMEOUT_MS)</td></tr>
<tr class="memdesc:aa483218a8665973bf86c444f9617539d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for the next continuous ranging measure on <a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html" title="I2C device driver for the VL53L0X ToF ranging chip.">VL53L0X</a> device to be ready and return the result.  <a href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#aa483218a8665973bf86c444f9617539d">More...</a><br /></td></tr>
<tr class="separator:aa483218a8665973bf86c444f9617539d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97a6d9833c513779ebc0c8e7ab98ed43"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#a97a6d9833c513779ebc0c8e7ab98ed43">stop_continuous_ranging</a> ()</td></tr>
<tr class="memdesc:a97a6d9833c513779ebc0c8e7ab98ed43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop continuous ranging on this <a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html" title="I2C device driver for the VL53L0X ToF ranging chip.">VL53L0X</a> device.  <a href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#a97a6d9833c513779ebc0c8e7ab98ed43">More...</a><br /></td></tr>
<tr class="separator:a97a6d9833c513779ebc0c8e7ab98ed43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1251ef487dbf56cdbda29135b02f6f9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#af1251ef487dbf56cdbda29135b02f6f9">reset_device</a> ()</td></tr>
<tr class="memdesc:af1251ef487dbf56cdbda29135b02f6f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset <a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html" title="I2C device driver for the VL53L0X ToF ranging chip.">VL53L0X</a> device.  <a href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#af1251ef487dbf56cdbda29135b02f6f9">More...</a><br /></td></tr>
<tr class="separator:af1251ef487dbf56cdbda29135b02f6f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b1a1492545e40f4ea981a330bb0bd2c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#a4b1a1492545e40f4ea981a330bb0bd2c">init_data_first</a> ()</td></tr>
<tr class="memdesc:a4b1a1492545e40f4ea981a330bb0bd2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform 1st stage initialization of this <a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html" title="I2C device driver for the VL53L0X ToF ranging chip.">VL53L0X</a> device.  <a href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#a4b1a1492545e40f4ea981a330bb0bd2c">More...</a><br /></td></tr>
<tr class="separator:a4b1a1492545e40f4ea981a330bb0bd2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a8a8c4cf17cf856fd449e25ce89c9a7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#a6a8a8c4cf17cf856fd449e25ce89c9a7">init_static_second</a> (const <a class="el" href="classdevices_1_1vl53l0x_1_1_g_p_i_o_settings.html">GPIOSettings</a> &amp;settings, <a class="el" href="classdevices_1_1vl53l0x_1_1_sequence_steps.html">SequenceSteps</a> steps=<a class="el" href="classdevices_1_1vl53l0x_1_1_sequence_steps.html#abc9fef218832edf1808741c45c3053b6">SequenceSteps::create</a>().pre_range().final_range().dss())</td></tr>
<tr class="memdesc:a6a8a8c4cf17cf856fd449e25ce89c9a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform 2nd stage initialization of this <a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html" title="I2C device driver for the VL53L0X ToF ranging chip.">VL53L0X</a> device.  <a href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#a6a8a8c4cf17cf856fd449e25ce89c9a7">More...</a><br /></td></tr>
<tr class="separator:a6a8a8c4cf17cf856fd449e25ce89c9a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e0a9fa13a07bd23170ce92897707326"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#a8e0a9fa13a07bd23170ce92897707326">perform_ref_calibration</a> ()</td></tr>
<tr class="memdesc:a8e0a9fa13a07bd23170ce92897707326"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform <a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html" title="I2C device driver for the VL53L0X ToF ranging chip.">VL53L0X</a> VHV and Phase calibration.  <a href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#a8e0a9fa13a07bd23170ce92897707326">More...</a><br /></td></tr>
<tr class="separator:a8e0a9fa13a07bd23170ce92897707326"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca4f6aca99f2481fc8f2c48388dfdf78"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#aca4f6aca99f2481fc8f2c48388dfdf78">get_range_status</a> (PROXY&lt; <a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#ae755d8e7d051d0969d1d9310dca57f2d">GetRangeStatusFuture</a> &gt; future)</td></tr>
<tr class="memdesc:aca4f6aca99f2481fc8f2c48388dfdf78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get current <code><a class="el" href="classdevices_1_1vl53l0x_1_1_device_status.html" title="Status of device as retrieved by VL53L0X::get_range_status().">DeviceStatus</a></code> from this device.  <a href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#aca4f6aca99f2481fc8f2c48388dfdf78">More...</a><br /></td></tr>
<tr class="separator:aca4f6aca99f2481fc8f2c48388dfdf78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a624511dcfa3565eb74721541432998f0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#a624511dcfa3565eb74721541432998f0">get_range_status</a> (<a class="el" href="classdevices_1_1vl53l0x_1_1_device_status.html">DeviceStatus</a> &amp;range_status)</td></tr>
<tr class="memdesc:a624511dcfa3565eb74721541432998f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get current <code><a class="el" href="classdevices_1_1vl53l0x_1_1_device_status.html" title="Status of device as retrieved by VL53L0X::get_range_status().">DeviceStatus</a></code> from this device.  <a href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#a624511dcfa3565eb74721541432998f0">More...</a><br /></td></tr>
<tr class="separator:a624511dcfa3565eb74721541432998f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53e8216f2f8ce75d5c79727b1db5a773"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#a53e8216f2f8ce75d5c79727b1db5a773">get_GPIO_settings</a> (<a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x_1_1_get_g_p_i_o_settings_future.html">GetGPIOSettingsFuture</a> &amp;future)</td></tr>
<tr class="memdesc:a53e8216f2f8ce75d5c79727b1db5a773"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get current <code><a class="el" href="classdevices_1_1vl53l0x_1_1_g_p_i_o_settings.html" title="Settings for behavior of VL53L0X GPIO pin.">GPIOSettings</a></code> from this device.  <a href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#a53e8216f2f8ce75d5c79727b1db5a773">More...</a><br /></td></tr>
<tr class="separator:a53e8216f2f8ce75d5c79727b1db5a773"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6acc0a701ceea05f086a4c3780b83b1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#ab6acc0a701ceea05f086a4c3780b83b1">get_GPIO_settings</a> (<a class="el" href="classdevices_1_1vl53l0x_1_1_g_p_i_o_settings.html">GPIOSettings</a> &amp;settings)</td></tr>
<tr class="memdesc:ab6acc0a701ceea05f086a4c3780b83b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get current <code><a class="el" href="classdevices_1_1vl53l0x_1_1_g_p_i_o_settings.html" title="Settings for behavior of VL53L0X GPIO pin.">GPIOSettings</a></code> from this device.  <a href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#ab6acc0a701ceea05f086a4c3780b83b1">More...</a><br /></td></tr>
<tr class="separator:ab6acc0a701ceea05f086a4c3780b83b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade2b985682bbaf683ef14d03a0f601f0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#ade2b985682bbaf683ef14d03a0f601f0">set_GPIO_settings</a> (<a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x_1_1_set_g_p_i_o_settings_future.html">SetGPIOSettingsFuture</a> &amp;future)</td></tr>
<tr class="memdesc:ade2b985682bbaf683ef14d03a0f601f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set new <code><a class="el" href="classdevices_1_1vl53l0x_1_1_g_p_i_o_settings.html" title="Settings for behavior of VL53L0X GPIO pin.">GPIOSettings</a></code> for this device.  <a href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#ade2b985682bbaf683ef14d03a0f601f0">More...</a><br /></td></tr>
<tr class="separator:ade2b985682bbaf683ef14d03a0f601f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f67a427dfbe6073bc6ba1a50aaf1be2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#a3f67a427dfbe6073bc6ba1a50aaf1be2">set_GPIO_settings</a> (const <a class="el" href="classdevices_1_1vl53l0x_1_1_g_p_i_o_settings.html">GPIOSettings</a> &amp;settings)</td></tr>
<tr class="memdesc:a3f67a427dfbe6073bc6ba1a50aaf1be2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set new <code><a class="el" href="classdevices_1_1vl53l0x_1_1_g_p_i_o_settings.html" title="Settings for behavior of VL53L0X GPIO pin.">GPIOSettings</a></code> for this device.  <a href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#a3f67a427dfbe6073bc6ba1a50aaf1be2">More...</a><br /></td></tr>
<tr class="separator:a3f67a427dfbe6073bc6ba1a50aaf1be2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51dd5f693458885893c7205af992e01e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#a51dd5f693458885893c7205af992e01e">get_interrupt_status</a> (PROXY&lt; <a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#a9805d95efcc5eaa1a0842f3c8e09191c">GetInterruptStatusFuture</a> &gt; future)</td></tr>
<tr class="memdesc:a51dd5f693458885893c7205af992e01e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get current <code>InterruptStatus</code> from this device.  <a href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#a51dd5f693458885893c7205af992e01e">More...</a><br /></td></tr>
<tr class="separator:a51dd5f693458885893c7205af992e01e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83db71bb4afce0c0ff060707c2018380"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#a83db71bb4afce0c0ff060707c2018380">get_interrupt_status</a> (InterruptStatus &amp;status)</td></tr>
<tr class="memdesc:a83db71bb4afce0c0ff060707c2018380"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get current <code>InterruptStatus</code> from this device.  <a href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#a83db71bb4afce0c0ff060707c2018380">More...</a><br /></td></tr>
<tr class="separator:a83db71bb4afce0c0ff060707c2018380"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7024a3679d48172131311740a882199"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#ac7024a3679d48172131311740a882199">clear_interrupt</a> (PROXY&lt; <a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#a03993b90b542fc88f314620165f0b4b4">ClearInterruptFuture</a> &gt; future)</td></tr>
<tr class="memdesc:ac7024a3679d48172131311740a882199"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear interrupt status from this device.  <a href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#ac7024a3679d48172131311740a882199">More...</a><br /></td></tr>
<tr class="separator:ac7024a3679d48172131311740a882199"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ace6d3d462d6a26340ad8b2532986fd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#a8ace6d3d462d6a26340ad8b2532986fd">clear_interrupt</a> (uint8_t clear_mask=0x01)</td></tr>
<tr class="memdesc:a8ace6d3d462d6a26340ad8b2532986fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear interrupt status from this device.  <a href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#a8ace6d3d462d6a26340ad8b2532986fd">More...</a><br /></td></tr>
<tr class="separator:a8ace6d3d462d6a26340ad8b2532986fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd38fce6e1cfac0c6eca209d818b72ec"><td class="memTemplParams" colspan="2">template&lt;board::Timer TIMER&gt; </td></tr>
<tr class="memitem:abd38fce6e1cfac0c6eca209d818b72ec"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#abd38fce6e1cfac0c6eca209d818b72ec">await_interrupt</a> (<a class="el" href="classtimer_1_1_r_t_t.html">timer::RTT</a>&lt; TIMER &gt; &amp;rtt, uint16_t timeout_ms=DEFAULT_TIMEOUT_MS)</td></tr>
<tr class="memdesc:abd38fce6e1cfac0c6eca209d818b72ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for an interrupt condition on <a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html" title="I2C device driver for the VL53L0X ToF ranging chip.">VL53L0X</a> device.  <a href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#abd38fce6e1cfac0c6eca209d818b72ec">More...</a><br /></td></tr>
<tr class="separator:abd38fce6e1cfac0c6eca209d818b72ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5862141562c208d0519d6049c73a1b76"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#a5862141562c208d0519d6049c73a1b76">get_direct_range</a> (PROXY&lt; <a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#a636ae6705cb4cc2946acc8b89699703a">GetDirectRangeFuture</a> &gt; future)</td></tr>
<tr class="memdesc:a5862141562c208d0519d6049c73a1b76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get range measured by this device.  <a href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#a5862141562c208d0519d6049c73a1b76">More...</a><br /></td></tr>
<tr class="separator:a5862141562c208d0519d6049c73a1b76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a794c143fd852c4c5c55040808719b1c5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#a794c143fd852c4c5c55040808719b1c5">get_direct_range</a> (uint16_t &amp;range_mm)</td></tr>
<tr class="memdesc:a794c143fd852c4c5c55040808719b1c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get range measured by this device.  <a href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#a794c143fd852c4c5c55040808719b1c5">More...</a><br /></td></tr>
<tr class="separator:a794c143fd852c4c5c55040808719b1c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82e29546fa72e9d961c02cae43227004"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#a82e29546fa72e9d961c02cae43227004">set_measurement_timing_budget</a> (uint32_t budget_us)</td></tr>
<tr class="memdesc:a82e29546fa72e9d961c02cae43227004"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set new "measurement timing budget" for this device.  <a href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#a82e29546fa72e9d961c02cae43227004">More...</a><br /></td></tr>
<tr class="separator:a82e29546fa72e9d961c02cae43227004"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37bd82e28ad1b866939264b67ba1c88e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#a37bd82e28ad1b866939264b67ba1c88e">get_measurement_timing_budget</a> (uint32_t &amp;budget_us)</td></tr>
<tr class="memdesc:a37bd82e28ad1b866939264b67ba1c88e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get current "measurement timing budget" for this device.  <a href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#a37bd82e28ad1b866939264b67ba1c88e">More...</a><br /></td></tr>
<tr class="separator:a37bd82e28ad1b866939264b67ba1c88e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a7233dd506e05a69fc0f1a1d5aeca9f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#a9a7233dd506e05a69fc0f1a1d5aeca9f">set_sequence_steps</a> (<a class="el" href="classdevices_1_1vl53l0x_1_1_sequence_steps.html">SequenceSteps</a> sequence_steps)</td></tr>
<tr class="memdesc:a9a7233dd506e05a69fc0f1a1d5aeca9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set measurement steps to be executed in sequence by the device during ranging.  <a href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#a9a7233dd506e05a69fc0f1a1d5aeca9f">More...</a><br /></td></tr>
<tr class="separator:a9a7233dd506e05a69fc0f1a1d5aeca9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a052110d0b12206e1e0f259be3be2f50b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#a052110d0b12206e1e0f259be3be2f50b">get_sequence_steps</a> (<a class="el" href="classdevices_1_1vl53l0x_1_1_sequence_steps.html">SequenceSteps</a> &amp;sequence_steps)</td></tr>
<tr class="memdesc:a052110d0b12206e1e0f259be3be2f50b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get current measurement steps executed in sequence by the device during ranging.  <a href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#a052110d0b12206e1e0f259be3be2f50b">More...</a><br /></td></tr>
<tr class="separator:a052110d0b12206e1e0f259be3be2f50b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64f421db9b31125b290be251bec59213"><td class="memTemplParams" colspan="2">template&lt;VcselPeriodType TYPE&gt; </td></tr>
<tr class="memitem:a64f421db9b31125b290be251bec59213"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#a64f421db9b31125b290be251bec59213">set_vcsel_pulse_period</a> (uint8_t period)</td></tr>
<tr class="memdesc:a64f421db9b31125b290be251bec59213"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set new pulse period of the VCSEL for pre-range or final-range step.  <a href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#a64f421db9b31125b290be251bec59213">More...</a><br /></td></tr>
<tr class="separator:a64f421db9b31125b290be251bec59213"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e71f8ef585c7cf6948c386c81a168ba"><td class="memTemplParams" colspan="2">template&lt;VcselPeriodType TYPE&gt; </td></tr>
<tr class="memitem:a1e71f8ef585c7cf6948c386c81a168ba"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#a1e71f8ef585c7cf6948c386c81a168ba">get_vcsel_pulse_period</a> (uint8_t &amp;period)</td></tr>
<tr class="memdesc:a1e71f8ef585c7cf6948c386c81a168ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get current pulse period of the VCSEL for pre-range or final-range step.  <a href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#a1e71f8ef585c7cf6948c386c81a168ba">More...</a><br /></td></tr>
<tr class="separator:a1e71f8ef585c7cf6948c386c81a168ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97febebb693ab16c48bd8d4b23b22fa5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#a97febebb693ab16c48bd8d4b23b22fa5">set_signal_rate_limit</a> (float signal_rate)</td></tr>
<tr class="memdesc:a97febebb693ab16c48bd8d4b23b22fa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set new signal rate limit for ranging.  <a href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#a97febebb693ab16c48bd8d4b23b22fa5">More...</a><br /></td></tr>
<tr class="separator:a97febebb693ab16c48bd8d4b23b22fa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63a44d590069e079e0515ee9945cb46f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#a63a44d590069e079e0515ee9945cb46f">get_signal_rate_limit</a> (float &amp;signal_rate)</td></tr>
<tr class="memdesc:a63a44d590069e079e0515ee9945cb46f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get current signal rate limit for ranging.  <a href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#a63a44d590069e079e0515ee9945cb46f">More...</a><br /></td></tr>
<tr class="separator:a63a44d590069e079e0515ee9945cb46f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad674735b78efacd5bcaa67fdd12685cb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#ad674735b78efacd5bcaa67fdd12685cb">get_power_mode</a> (<a class="el" href="namespacedevices_1_1vl53l0x.html#a58601e220af84e79fca7689a91748e42">PowerMode</a> &amp;power_mode)</td></tr>
<tr class="memdesc:ad674735b78efacd5bcaa67fdd12685cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get current power mode of this <a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html" title="I2C device driver for the VL53L0X ToF ranging chip.">VL53L0X</a> register.  <a href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#ad674735b78efacd5bcaa67fdd12685cb">More...</a><br /></td></tr>
<tr class="separator:ad674735b78efacd5bcaa67fdd12685cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c31eda9d3aa62aa008a2a264a2e4dbf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#a8c31eda9d3aa62aa008a2a264a2e4dbf">get_model</a> (uint8_t &amp;model)</td></tr>
<tr class="memdesc:a8c31eda9d3aa62aa008a2a264a2e4dbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get model of this <a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html" title="I2C device driver for the VL53L0X ToF ranging chip.">VL53L0X</a> register.  <a href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#a8c31eda9d3aa62aa008a2a264a2e4dbf">More...</a><br /></td></tr>
<tr class="separator:a8c31eda9d3aa62aa008a2a264a2e4dbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2be6b02032886b35c995f04ccb47a10"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#ac2be6b02032886b35c995f04ccb47a10">get_revision</a> (uint8_t &amp;revision)</td></tr>
<tr class="memdesc:ac2be6b02032886b35c995f04ccb47a10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get revision of this <a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html" title="I2C device driver for the VL53L0X ToF ranging chip.">VL53L0X</a> register.  <a href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#ac2be6b02032886b35c995f04ccb47a10">More...</a><br /></td></tr>
<tr class="separator:ac2be6b02032886b35c995f04ccb47a10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c1f1421f2e2fb1dd2bcd1c007ab3170"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#a4c1f1421f2e2fb1dd2bcd1c007ab3170">await_interrupt</a> (uint16_t loops=MAX_LOOP)</td></tr>
<tr class="memdesc:a4c1f1421f2e2fb1dd2bcd1c007ab3170"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for an interrupt condition on <a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html" title="I2C device driver for the VL53L0X ToF ranging chip.">VL53L0X</a> device.  <a href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#a4c1f1421f2e2fb1dd2bcd1c007ab3170">More...</a><br /></td></tr>
<tr class="separator:a4c1f1421f2e2fb1dd2bcd1c007ab3170"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8a6f66bce9f717f4d81077cf1a6b1eb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#aa8a6f66bce9f717f4d81077cf1a6b1eb">await_continuous_range</a> (uint16_t &amp;range_mm, uint16_t loops=MAX_LOOP)</td></tr>
<tr class="memdesc:aa8a6f66bce9f717f4d81077cf1a6b1eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for the next continuous ranging measure on <a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html" title="I2C device driver for the VL53L0X ToF ranging chip.">VL53L0X</a> device to be ready and return the result.  <a href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#aa8a6f66bce9f717f4d81077cf1a6b1eb">More...</a><br /></td></tr>
<tr class="separator:aa8a6f66bce9f717f4d81077cf1a6b1eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae960c2e625f7eac7dcceed8ed440d71"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#aae960c2e625f7eac7dcceed8ed440d71">await_single_range</a> (uint16_t &amp;range_mm, uint16_t loops=MAX_LOOP)</td></tr>
<tr class="memdesc:aae960c2e625f7eac7dcceed8ed440d71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a single range action on <a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html" title="I2C device driver for the VL53L0X ToF ranging chip.">VL53L0X</a> device, and wait for the measurement result.  <a href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#aae960c2e625f7eac7dcceed8ed440d71">More...</a><br /></td></tr>
<tr class="separator:aae960c2e625f7eac7dcceed8ed440d71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3a85d18f4030443abf45a6a6579af84"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#ab3a85d18f4030443abf45a6a6579af84">get_reference_SPADs</a> (<a class="el" href="classdevices_1_1vl53l0x_1_1_s_p_a_d_reference.html">SPADReference</a> &amp;spad_ref)</td></tr>
<tr class="memdesc:ab3a85d18f4030443abf45a6a6579af84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the reference SPADs status (enabled or not).  <a href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#ab3a85d18f4030443abf45a6a6579af84">More...</a><br /></td></tr>
<tr class="separator:ab3a85d18f4030443abf45a6a6579af84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad67dcabc700a4e74d9104ec4b23f8ae2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#ad67dcabc700a4e74d9104ec4b23f8ae2">set_reference_SPADs</a> (const <a class="el" href="classdevices_1_1vl53l0x_1_1_s_p_a_d_reference.html">SPADReference</a> &amp;spad_ref)</td></tr>
<tr class="memdesc:ad67dcabc700a4e74d9104ec4b23f8ae2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the reference SPADs status (enabled or not).  <a href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#ad67dcabc700a4e74d9104ec4b23f8ae2">More...</a><br /></td></tr>
<tr class="separator:ad67dcabc700a4e74d9104ec4b23f8ae2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a6665b0898f48a2acab22ed05f33623"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#a2a6665b0898f48a2acab22ed05f33623">get_SPAD_info</a> (<a class="el" href="classdevices_1_1vl53l0x_1_1_s_p_a_d_info.html">SPADInfo</a> &amp;info)</td></tr>
<tr class="memdesc:a2a6665b0898f48a2acab22ed05f33623"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get current SPAD information (number of SPAD aperture or not).  <a href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#a2a6665b0898f48a2acab22ed05f33623">More...</a><br /></td></tr>
<tr class="separator:a2a6665b0898f48a2acab22ed05f33623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69032578b37777488b3f7adbfc21ce39"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#a69032578b37777488b3f7adbfc21ce39">get_sequence_steps_timeout</a> (<a class="el" href="classdevices_1_1vl53l0x_1_1_sequence_steps_timeout.html">SequenceStepsTimeout</a> &amp;timeouts)</td></tr>
<tr class="memdesc:a69032578b37777488b3f7adbfc21ce39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get current timeouts associated to each ranging step.  <a href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#a69032578b37777488b3f7adbfc21ce39">More...</a><br /></td></tr>
<tr class="separator:a69032578b37777488b3f7adbfc21ce39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ae58ef194127eb2b6b07f8697a33dcf"><td class="memTemplParams" colspan="2">template&lt;Register REGISTER, typename T  = uint8_t&gt; </td></tr>
<tr class="memitem:a1ae58ef194127eb2b6b07f8697a33dcf"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#a1ae58ef194127eb2b6b07f8697a33dcf">get_register</a> (PROXY&lt; <a class="el" href="classi2c_1_1_t_read_register_future.html">TReadRegisterFuture</a>&lt; REGISTER, T &gt;&gt; future)</td></tr>
<tr class="memdesc:a1ae58ef194127eb2b6b07f8697a33dcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Directly get value of a <a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html" title="I2C device driver for the VL53L0X ToF ranging chip.">VL53L0X</a> register.  <a href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#a1ae58ef194127eb2b6b07f8697a33dcf">More...</a><br /></td></tr>
<tr class="separator:a1ae58ef194127eb2b6b07f8697a33dcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4e60db7f7cb22bf3ef80f2de40d4df4"><td class="memTemplParams" colspan="2">template&lt;Register REGISTER, typename T  = uint8_t&gt; </td></tr>
<tr class="memitem:ad4e60db7f7cb22bf3ef80f2de40d4df4"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#ad4e60db7f7cb22bf3ef80f2de40d4df4">set_register</a> (PROXY&lt; <a class="el" href="classi2c_1_1_t_write_register_future.html">TWriteRegisterFuture</a>&lt; REGISTER, T &gt;&gt; future)</td></tr>
<tr class="memdesc:ad4e60db7f7cb22bf3ef80f2de40d4df4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Directly set value of a <a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html" title="I2C device driver for the VL53L0X ToF ranging chip.">VL53L0X</a> register.  <a href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#ad4e60db7f7cb22bf3ef80f2de40d4df4">More...</a><br /></td></tr>
<tr class="separator:ad4e60db7f7cb22bf3ef80f2de40d4df4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a604974b689a68b320bc75b60bb28809a"><td class="memTemplParams" colspan="2">template&lt;Register REGISTER, typename T  = uint8_t&gt; </td></tr>
<tr class="memitem:a604974b689a68b320bc75b60bb28809a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#a604974b689a68b320bc75b60bb28809a">get_register</a> (T &amp;value)</td></tr>
<tr class="memdesc:a604974b689a68b320bc75b60bb28809a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Directly get value of a <a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html" title="I2C device driver for the VL53L0X ToF ranging chip.">VL53L0X</a> register.  <a href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#a604974b689a68b320bc75b60bb28809a">More...</a><br /></td></tr>
<tr class="separator:a604974b689a68b320bc75b60bb28809a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53fd655f7491296b662d06b56ba53776"><td class="memTemplParams" colspan="2">template&lt;Register REGISTER, typename T  = uint8_t&gt; </td></tr>
<tr class="memitem:a53fd655f7491296b662d06b56ba53776"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#a53fd655f7491296b662d06b56ba53776">set_register</a> (T value)</td></tr>
<tr class="memdesc:a53fd655f7491296b662d06b56ba53776"><td class="mdescLeft">&#160;</td><td class="mdescRight">Directly set value of a <a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html" title="I2C device driver for the VL53L0X ToF ranging chip.">VL53L0X</a> register.  <a href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#a53fd655f7491296b662d06b56ba53776">More...</a><br /></td></tr>
<tr class="separator:a53fd655f7491296b662d06b56ba53776"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_types_classi2c_1_1_i2_c_device"><td colspan="2" onclick="javascript:toggleInherit('pro_types_classi2c_1_1_i2_c_device')"><img src="closed.png" alt="-"/>&#160;Protected Types inherited from <a class="el" href="classi2c_1_1_i2_c_device.html">i2c::I2CDevice&lt; MANAGER &gt;</a></td></tr>
<tr class="memitem:aaa72ad76688bfbf7057b4fdfa426a95c inherit pro_types_classi2c_1_1_i2_c_device"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classi2c_1_1_i2_c_device.html#aaa72ad76688bfbf7057b4fdfa426a95c">PROXY</a> = typename MANAGER::template <a class="el" href="classi2c_1_1_i2_c_device.html#aaa72ad76688bfbf7057b4fdfa426a95c">PROXY</a>&lt; T &gt;</td></tr>
<tr class="memdesc:aaa72ad76688bfbf7057b4fdfa426a95c inherit pro_types_classi2c_1_1_i2_c_device"><td class="mdescLeft">&#160;</td><td class="mdescRight">The actual type used for all proxies; may be <code><a class="el" href="classlifecycle_1_1_light_proxy.html" title="A light proxy class that encapsulates access to a fixed T instance, or to a dynamic LifeCycle&lt;T&gt; inst...">lifecycle::LightProxy</a></code> or <code><a class="el" href="classlifecycle_1_1_direct_proxy.html" title="A kind of proxy class that encapsulates access to a fixed T instance.">lifecycle::DirectProxy</a></code>.  <a href="classi2c_1_1_i2_c_device.html#aaa72ad76688bfbf7057b4fdfa426a95c">More...</a><br /></td></tr>
<tr class="separator:aaa72ad76688bfbf7057b4fdfa426a95c inherit pro_types_classi2c_1_1_i2_c_device"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2e7c57ed9de99169a280c189724af0a inherit pro_types_classi2c_1_1_i2_c_device"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classi2c_1_1_i2_c_device.html#ac2e7c57ed9de99169a280c189724af0a">ABSTRACT_FUTURE</a> = typename MANAGER::ABSTRACT_FUTURE</td></tr>
<tr class="memdesc:ac2e7c57ed9de99169a280c189724af0a inherit pro_types_classi2c_1_1_i2_c_device"><td class="mdescLeft">&#160;</td><td class="mdescRight">The abstract base class of all futures to be defined for a device.  <a href="classi2c_1_1_i2_c_device.html#ac2e7c57ed9de99169a280c189724af0a">More...</a><br /></td></tr>
<tr class="separator:ac2e7c57ed9de99169a280c189724af0a inherit pro_types_classi2c_1_1_i2_c_device"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad029f30f422ebd435b20e1d2138ff908 inherit pro_types_classi2c_1_1_i2_c_device"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classi2c_1_1_i2_c_device.html#ad029f30f422ebd435b20e1d2138ff908">FUTURE</a> = typename MANAGER::template <a class="el" href="classi2c_1_1_i2_c_device.html#ad029f30f422ebd435b20e1d2138ff908">FUTURE</a>&lt; OUT, IN &gt;</td></tr>
<tr class="memdesc:ad029f30f422ebd435b20e1d2138ff908 inherit pro_types_classi2c_1_1_i2_c_device"><td class="mdescLeft">&#160;</td><td class="mdescRight">The template base class of all futures to be defined for a device.  <a href="classi2c_1_1_i2_c_device.html#ad029f30f422ebd435b20e1d2138ff908">More...</a><br /></td></tr>
<tr class="separator:ad029f30f422ebd435b20e1d2138ff908 inherit pro_types_classi2c_1_1_i2_c_device"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classi2c_1_1_i2_c_device"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classi2c_1_1_i2_c_device')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classi2c_1_1_i2_c_device.html">i2c::I2CDevice&lt; MANAGER &gt;</a></td></tr>
<tr class="memitem:ac9dbb29fefbc1a66a6df687d9874fec4 inherit pro_methods_classi2c_1_1_i2_c_device"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classi2c_1_1_i2_c_device.html#ac9dbb29fefbc1a66a6df687d9874fec4">I2CDevice</a> (<a class="el" href="classi2c_1_1_i2_c_device.html#a7b3f6509519292904a636f4262b404ae">MANAGER</a> &amp;manager, uint8_t device, <a class="el" href="defines_8h.html#addf5ec070e9499d36b7f2009ce736076">UNUSED</a> Mode&lt; MODE &gt; mode, bool auto_stop)</td></tr>
<tr class="memdesc:ac9dbb29fefbc1a66a6df687d9874fec4 inherit pro_methods_classi2c_1_1_i2_c_device"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new I2C device.  <a href="classi2c_1_1_i2_c_device.html#ac9dbb29fefbc1a66a6df687d9874fec4">More...</a><br /></td></tr>
<tr class="separator:ac9dbb29fefbc1a66a6df687d9874fec4 inherit pro_methods_classi2c_1_1_i2_c_device"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42d97ba6a206ff561962c1be1644e2d6 inherit pro_methods_classi2c_1_1_i2_c_device"><td class="memItemLeft" align="right" valign="top"><a id="a42d97ba6a206ff561962c1be1644e2d6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>I2CDevice</b> (const <a class="el" href="classi2c_1_1_i2_c_device.html">I2CDevice</a> &amp;)=delete</td></tr>
<tr class="separator:a42d97ba6a206ff561962c1be1644e2d6 inherit pro_methods_classi2c_1_1_i2_c_device"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3191ed189bb95f9d2c00638f3055123 inherit pro_methods_classi2c_1_1_i2_c_device"><td class="memItemLeft" align="right" valign="top"><a id="aa3191ed189bb95f9d2c00638f3055123"></a>
<a class="el" href="classi2c_1_1_i2_c_device.html">I2CDevice</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classi2c_1_1_i2_c_device.html">I2CDevice</a> &amp;)=delete</td></tr>
<tr class="separator:aa3191ed189bb95f9d2c00638f3055123 inherit pro_methods_classi2c_1_1_i2_c_device"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1325f82f4aaf8290a2d4cc4c70dfe83b inherit pro_methods_classi2c_1_1_i2_c_device"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classi2c_1_1_i2_c_device.html#a1325f82f4aaf8290a2d4cc4c70dfe83b">set_device</a> (uint8_t device)</td></tr>
<tr class="memdesc:a1325f82f4aaf8290a2d4cc4c70dfe83b inherit pro_methods_classi2c_1_1_i2_c_device"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the I2C address of this device.  <a href="classi2c_1_1_i2_c_device.html#a1325f82f4aaf8290a2d4cc4c70dfe83b">More...</a><br /></td></tr>
<tr class="separator:a1325f82f4aaf8290a2d4cc4c70dfe83b inherit pro_methods_classi2c_1_1_i2_c_device"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af937a51b38ea97dee521319c1fc09f46 inherit pro_methods_classi2c_1_1_i2_c_device"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classi2c_1_1_i2_c_device.html#af937a51b38ea97dee521319c1fc09f46">launch_commands</a> (<a class="el" href="classi2c_1_1_i2_c_device.html#aaa72ad76688bfbf7057b4fdfa426a95c">PROXY</a>&lt; <a class="el" href="classi2c_1_1_i2_c_device.html#ac2e7c57ed9de99169a280c189724af0a">ABSTRACT_FUTURE</a> &gt; proxy, <a class="el" href="classutils_1_1range.html">utils::range</a>&lt; <a class="el" href="classi2c_1_1_i2_c_light_command.html">I2CLightCommand</a> &gt; commands)</td></tr>
<tr class="memdesc:af937a51b38ea97dee521319c1fc09f46 inherit pro_methods_classi2c_1_1_i2_c_device"><td class="mdescLeft">&#160;</td><td class="mdescRight">Launch execution (asynchronously or synchronously, depending on MANAGER) of a chain of I2CLightCommand items (constructed with <code><a class="el" href="classi2c_1_1_i2_c_device.html#a75fe1fe6a563488eb06f86266e15c923" title="Build a read I2CLightCommand that can be later pushed to the I2C Manager for proper handling.">read()</a></code> and <code><a class="el" href="classi2c_1_1_i2_c_device.html#a161423972dd35fbd4b32cd1e8048b5ad" title="Build a write I2CLightCommand that can be later pushed to the I2C Manager for proper handling.">write()</a></code> methods).  <a href="classi2c_1_1_i2_c_device.html#af937a51b38ea97dee521319c1fc09f46">More...</a><br /></td></tr>
<tr class="separator:af937a51b38ea97dee521319c1fc09f46 inherit pro_methods_classi2c_1_1_i2_c_device"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac433c1975b0be78ce89071ac7ca7a538 inherit pro_methods_classi2c_1_1_i2_c_device"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classi2c_1_1_i2_c_device.html#ac433c1975b0be78ce89071ac7ca7a538">async_read</a> (<a class="el" href="classi2c_1_1_i2_c_device.html#aaa72ad76688bfbf7057b4fdfa426a95c">PROXY</a>&lt; <a class="el" href="flash_8h.html#a16c40764aaba0de309f5ff429c8bac15">F</a> &gt; future, bool stop=true)</td></tr>
<tr class="memdesc:ac433c1975b0be78ce89071ac7ca7a538 inherit pro_methods_classi2c_1_1_i2_c_device"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper method that asynchronously launches I2C commands for a simple Future performing one write followed by one read (typically for device register reading).  <a href="classi2c_1_1_i2_c_device.html#ac433c1975b0be78ce89071ac7ca7a538">More...</a><br /></td></tr>
<tr class="separator:ac433c1975b0be78ce89071ac7ca7a538 inherit pro_methods_classi2c_1_1_i2_c_device"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dfdb3fb784b939e8140a1c900a8e64e inherit pro_methods_classi2c_1_1_i2_c_device"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classi2c_1_1_i2_c_device.html#a0dfdb3fb784b939e8140a1c900a8e64e">sync_read</a> (T &amp;result)</td></tr>
<tr class="memdesc:a0dfdb3fb784b939e8140a1c900a8e64e inherit pro_methods_classi2c_1_1_i2_c_device"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper method that launches I2C commands for a simple Future performing one write followed by one read (typically for device register reading); the method blocks until the end of the I2C transaction.  <a href="classi2c_1_1_i2_c_device.html#a0dfdb3fb784b939e8140a1c900a8e64e">More...</a><br /></td></tr>
<tr class="separator:a0dfdb3fb784b939e8140a1c900a8e64e inherit pro_methods_classi2c_1_1_i2_c_device"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a877f1d20e75ed28de13314fc7d5a73f0 inherit pro_methods_classi2c_1_1_i2_c_device"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classi2c_1_1_i2_c_device.html#a877f1d20e75ed28de13314fc7d5a73f0">async_write</a> (<a class="el" href="classi2c_1_1_i2_c_device.html#aaa72ad76688bfbf7057b4fdfa426a95c">PROXY</a>&lt; <a class="el" href="flash_8h.html#a16c40764aaba0de309f5ff429c8bac15">F</a> &gt; future, bool stop=true)</td></tr>
<tr class="memdesc:a877f1d20e75ed28de13314fc7d5a73f0 inherit pro_methods_classi2c_1_1_i2_c_device"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper method that asynchronously launches I2C commands for a simple Future performing only one write (typically for device register writing).  <a href="classi2c_1_1_i2_c_device.html#a877f1d20e75ed28de13314fc7d5a73f0">More...</a><br /></td></tr>
<tr class="separator:a877f1d20e75ed28de13314fc7d5a73f0 inherit pro_methods_classi2c_1_1_i2_c_device"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35f45f8b0a60893e99fc8266f834da5d inherit pro_methods_classi2c_1_1_i2_c_device"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classi2c_1_1_i2_c_device.html#a35f45f8b0a60893e99fc8266f834da5d">async_multi_write</a> (<a class="el" href="classi2c_1_1_i2_c_device.html#aaa72ad76688bfbf7057b4fdfa426a95c">PROXY</a>&lt; <a class="el" href="flash_8h.html#a16c40764aaba0de309f5ff429c8bac15">F</a> &gt; future, bool stop=true)</td></tr>
<tr class="memdesc:a35f45f8b0a60893e99fc8266f834da5d inherit pro_methods_classi2c_1_1_i2_c_device"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper method that asynchronously launches I2C commands for a simple Future performing several register writes.  <a href="classi2c_1_1_i2_c_device.html#a35f45f8b0a60893e99fc8266f834da5d">More...</a><br /></td></tr>
<tr class="separator:a35f45f8b0a60893e99fc8266f834da5d inherit pro_methods_classi2c_1_1_i2_c_device"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5733ebd749415b43fbfab76cf6cfc234 inherit pro_methods_classi2c_1_1_i2_c_device"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classi2c_1_1_i2_c_device.html#a5733ebd749415b43fbfab76cf6cfc234">sync_write</a> (const T &amp;value)</td></tr>
<tr class="memdesc:a5733ebd749415b43fbfab76cf6cfc234 inherit pro_methods_classi2c_1_1_i2_c_device"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper method that launches I2C commands for a simple Future performing only one write (typically for device register writing); the method blocks until the end of the I2C transaction.  <a href="classi2c_1_1_i2_c_device.html#a5733ebd749415b43fbfab76cf6cfc234">More...</a><br /></td></tr>
<tr class="separator:a5733ebd749415b43fbfab76cf6cfc234 inherit pro_methods_classi2c_1_1_i2_c_device"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad570da8ac6c407c7046b1f539fa5a8e inherit pro_methods_classi2c_1_1_i2_c_device"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classi2c_1_1_i2_c_device.html#aad570da8ac6c407c7046b1f539fa5a8e">sync_write</a> ()</td></tr>
<tr class="memdesc:aad570da8ac6c407c7046b1f539fa5a8e inherit pro_methods_classi2c_1_1_i2_c_device"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper method that launches I2C commands for a simple Future performing only one write (typically for device register writing); the method blocks until the end of the I2C transaction.  <a href="classi2c_1_1_i2_c_device.html#aad570da8ac6c407c7046b1f539fa5a8e">More...</a><br /></td></tr>
<tr class="separator:aad570da8ac6c407c7046b1f539fa5a8e inherit pro_methods_classi2c_1_1_i2_c_device"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf6df66445e2f4c39501b5621191f51e inherit pro_methods_classi2c_1_1_i2_c_device"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classi2c_1_1_i2_c_device.html#aaf6df66445e2f4c39501b5621191f51e">resolve</a> (<a class="el" href="classi2c_1_1_i2_c_device.html#aaa72ad76688bfbf7057b4fdfa426a95c">PROXY</a>&lt; T &gt; proxy) const</td></tr>
<tr class="memdesc:aaf6df66445e2f4c39501b5621191f51e inherit pro_methods_classi2c_1_1_i2_c_device"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resolve <code>proxy</code> to an actual <code>T</code> (typically a <code>Future</code>).  <a href="classi2c_1_1_i2_c_device.html#aaf6df66445e2f4c39501b5621191f51e">More...</a><br /></td></tr>
<tr class="separator:aaf6df66445e2f4c39501b5621191f51e inherit pro_methods_classi2c_1_1_i2_c_device"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_static_methods_classi2c_1_1_i2_c_device"><td colspan="2" onclick="javascript:toggleInherit('pro_static_methods_classi2c_1_1_i2_c_device')"><img src="closed.png" alt="-"/>&#160;Static Protected Member Functions inherited from <a class="el" href="classi2c_1_1_i2_c_device.html">i2c::I2CDevice&lt; MANAGER &gt;</a></td></tr>
<tr class="memitem:a75fe1fe6a563488eb06f86266e15c923 inherit pro_static_methods_classi2c_1_1_i2_c_device"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="classi2c_1_1_i2_c_light_command.html">I2CLightCommand</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classi2c_1_1_i2_c_device.html#a75fe1fe6a563488eb06f86266e15c923">read</a> (uint8_t read_count=0, bool finish_future=false, bool stop=false)</td></tr>
<tr class="memdesc:a75fe1fe6a563488eb06f86266e15c923 inherit pro_static_methods_classi2c_1_1_i2_c_device"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a read I2CLightCommand that can be later pushed to the I2C Manager for proper handling.  <a href="classi2c_1_1_i2_c_device.html#a75fe1fe6a563488eb06f86266e15c923">More...</a><br /></td></tr>
<tr class="separator:a75fe1fe6a563488eb06f86266e15c923 inherit pro_static_methods_classi2c_1_1_i2_c_device"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a161423972dd35fbd4b32cd1e8048b5ad inherit pro_static_methods_classi2c_1_1_i2_c_device"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="classi2c_1_1_i2_c_light_command.html">I2CLightCommand</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classi2c_1_1_i2_c_device.html#a161423972dd35fbd4b32cd1e8048b5ad">write</a> (uint8_t write_count=0, bool finish_future=false, bool stop=false)</td></tr>
<tr class="memdesc:a161423972dd35fbd4b32cd1e8048b5ad inherit pro_static_methods_classi2c_1_1_i2_c_device"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a write I2CLightCommand that can be later pushed to the I2C Manager for proper handling.  <a href="classi2c_1_1_i2_c_device.html#a161423972dd35fbd4b32cd1e8048b5ad">More...</a><br /></td></tr>
<tr class="separator:a161423972dd35fbd4b32cd1e8048b5ad inherit pro_static_methods_classi2c_1_1_i2_c_device"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a358f5bdfc2a7f4cfbcca0e253f42d676 inherit pro_static_methods_classi2c_1_1_i2_c_device"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classi2c_1_1_i2_c_device.html#aaa72ad76688bfbf7057b4fdfa426a95c">PROXY</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classi2c_1_1_i2_c_device.html#a358f5bdfc2a7f4cfbcca0e253f42d676">make_proxy</a> (const T &amp;target)</td></tr>
<tr class="memdesc:a358f5bdfc2a7f4cfbcca0e253f42d676 inherit pro_static_methods_classi2c_1_1_i2_c_device"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a PROXY from <code>target</code>.  <a href="classi2c_1_1_i2_c_device.html#a358f5bdfc2a7f4cfbcca0e253f42d676">More...</a><br /></td></tr>
<tr class="separator:a358f5bdfc2a7f4cfbcca0e253f42d676 inherit pro_static_methods_classi2c_1_1_i2_c_device"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename MANAGER&gt;<br />
class devices::vl53l0x::VL53L0X&lt; MANAGER &gt;</h3>

<p>I2C device driver for the <a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html" title="I2C device driver for the VL53L0X ToF ranging chip.">VL53L0X</a> ToF ranging chip. </p>
<p>This chip supports both standard and fast I2C modes.</p>
<p>Several levels of API are provided:</p><ul>
<li>low-level API : reserved to developers who know how the <a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html" title="I2C device driver for the VL53L0X ToF ranging chip.">VL53L0X</a> device works and know what they do</li>
<li>mid-level API : for common use where developers need fine level of detail on how the <a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html" title="I2C device driver for the VL53L0X ToF ranging chip.">VL53L0X</a> device shall work</li>
<li>high-level API : for simplest use of the <a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html" title="I2C device driver for the VL53L0X ToF ranging chip.">VL53L0X</a> device</li>
</ul>
<p>Most API comes in synchronous mode only, although it can of course work with an asynchronous I2C Manager. This is due to the highly complex protocol of <a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html" title="I2C device driver for the VL53L0X ToF ranging chip.">VL53L0X</a> device where I2C transactions can be long and would have required highly complex Future classes to be defined with little added value. Only API that were deemed useful in non-blocking mode were also made asynchronous. Synchronous API are blocking until completion and should never be called from an ISR! Asynchronous API can be called from anywhere, but you must await their completion through a Future.</p>
<dl class="section note"><dt>Note</dt><dd>The <a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html" title="I2C device driver for the VL53L0X ToF ranging chip.">VL53L0X</a> device is extremely complex and not well documented; its only complete reference is the bloated C code provided by STM which was not possible to directly use in FastArduino library. Hence it took a lot of experiments to make this device work. Not all original STM API is provided here.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MANAGER</td><td>one of FastArduino available I2C Manager </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="vl53l0x_8h_source.html#l00101">101</a> of file <a class="el" href="vl53l0x_8h_source.html">vl53l0x.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ae755d8e7d051d0969d1d9310dca57f2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae755d8e7d051d0969d1d9310dca57f2d">&#9670;&nbsp;</a></span>GetRangeStatusFuture</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MANAGER &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html">devices::vl53l0x::VL53L0X</a>&lt; <a class="el" href="classi2c_1_1_i2_c_device.html#a7b3f6509519292904a636f4262b404ae">MANAGER</a> &gt;::<a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#ae755d8e7d051d0969d1d9310dca57f2d">GetRangeStatusFuture</a> =  <a class="el" href="classi2c_1_1_t_read_register_future.html">TReadRegisterFuture</a>&lt;Register::RESULT_RANGE_STATUS, <a class="el" href="classdevices_1_1vl53l0x_1_1_device_status.html">DeviceStatus</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Future to get device range status. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#aca4f6aca99f2481fc8f2c48388dfdf78" title="Get current DeviceStatus from this device.">get_range_status()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="vl53l0x_8h_source.html#l00520">520</a> of file <a class="el" href="vl53l0x_8h_source.html">vl53l0x.h</a>.</p>

</div>
</div>
<a id="a9805d95efcc5eaa1a0842f3c8e09191c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9805d95efcc5eaa1a0842f3c8e09191c">&#9670;&nbsp;</a></span>GetInterruptStatusFuture</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MANAGER &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html">devices::vl53l0x::VL53L0X</a>&lt; <a class="el" href="classi2c_1_1_i2_c_device.html#a7b3f6509519292904a636f4262b404ae">MANAGER</a> &gt;::<a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#a9805d95efcc5eaa1a0842f3c8e09191c">GetInterruptStatusFuture</a> =  <a class="el" href="classi2c_1_1_t_read_register_future.html">TReadRegisterFuture</a>&lt;Register::RESULT_INTERRUPT_STATUS, InterruptStatus&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Future to get device current interrupt status. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#a51dd5f693458885893c7205af992e01e" title="Get current InterruptStatus from this device.">get_interrupt_status()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="vl53l0x_8h_source.html#l00744">744</a> of file <a class="el" href="vl53l0x_8h_source.html">vl53l0x.h</a>.</p>

</div>
</div>
<a id="a03993b90b542fc88f314620165f0b4b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03993b90b542fc88f314620165f0b4b4">&#9670;&nbsp;</a></span>ClearInterruptFuture</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MANAGER &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html">devices::vl53l0x::VL53L0X</a>&lt; <a class="el" href="classi2c_1_1_i2_c_device.html#a7b3f6509519292904a636f4262b404ae">MANAGER</a> &gt;::<a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#a03993b90b542fc88f314620165f0b4b4">ClearInterruptFuture</a> =  <a class="el" href="classi2c_1_1_t_write_register_future.html">TWriteRegisterFuture</a>&lt;Register::SYSTEM_INTERRUPT_CLEAR&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Future to clear device interrupt status. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#ac7024a3679d48172131311740a882199" title="Clear interrupt status from this device.">clear_interrupt()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="vl53l0x_8h_source.html#l00789">789</a> of file <a class="el" href="vl53l0x_8h_source.html">vl53l0x.h</a>.</p>

</div>
</div>
<a id="a636ae6705cb4cc2946acc8b89699703a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a636ae6705cb4cc2946acc8b89699703a">&#9670;&nbsp;</a></span>GetDirectRangeFuture</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MANAGER &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html">devices::vl53l0x::VL53L0X</a>&lt; <a class="el" href="classi2c_1_1_i2_c_device.html#a7b3f6509519292904a636f4262b404ae">MANAGER</a> &gt;::<a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#a636ae6705cb4cc2946acc8b89699703a">GetDirectRangeFuture</a> =  <a class="el" href="classi2c_1_1_t_read_register_future.html">TReadRegisterFuture</a>&lt;Register::RESULT_RANGE_MILLIMETER, uint16_t&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Future to get device current range measure. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#a5862141562c208d0519d6049c73a1b76" title="Get range measured by this device.">get_direct_range()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="vl53l0x_8h_source.html#l00863">863</a> of file <a class="el" href="vl53l0x_8h_source.html">vl53l0x.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ae262ba2d39353efb8ff1964d64c30cd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae262ba2d39353efb8ff1964d64c30cd3">&#9670;&nbsp;</a></span>VL53L0X()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MANAGER &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html">devices::vl53l0x::VL53L0X</a>&lt; <a class="el" href="classi2c_1_1_i2_c_device.html#a7b3f6509519292904a636f4262b404ae">MANAGER</a> &gt;::<a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html">VL53L0X</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classi2c_1_1_i2_c_device.html#a7b3f6509519292904a636f4262b404ae">MANAGER</a> &amp;&#160;</td>
          <td class="paramname"><em>manager</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new device driver for a <a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html" title="I2C device driver for the VL53L0X ToF ranging chip.">VL53L0X</a> chip. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">manager</td><td>reference to a suitable MANAGER for this device </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="vl53l0x_8h_source.html#l00124">124</a> of file <a class="el" href="vl53l0x_8h_source.html">vl53l0x.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a7a6410f0460104502ce83eb7ef540a9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a6410f0460104502ce83eb7ef540a9b">&#9670;&nbsp;</a></span>set_address()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MANAGER &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html">devices::vl53l0x::VL53L0X</a>&lt; <a class="el" href="classi2c_1_1_i2_c_device.html#a7b3f6509519292904a636f4262b404ae">MANAGER</a> &gt;::set_address </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>device_address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Change the I2C address of this <a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html" title="I2C device driver for the VL53L0X ToF ranging chip.">VL53L0X</a> device. </p>
<p>For this to work, other I2C devices with the same address shall be shut down during this method call. </p><dl class="section warning"><dt>Warning</dt><dd>Blocking API! </dd></dl>
<dl class="section note"><dt>Note</dt><dd>High-level API</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device_address</td><td>the new I2C address for this device; only 7 LSB are relevant. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if the operation succeeded </td></tr>
    <tr><td class="paramname">false</td><td>if the operation failed </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="vl53l0x_8h_source.html#l00138">138</a> of file <a class="el" href="vl53l0x_8h_source.html">vl53l0x.h</a>.</p>

</div>
</div>
<a id="aa0ca4aab9ad8b6b7e76ca34ee29e2e68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0ca4aab9ad8b6b7e76ca34ee29e2e68">&#9670;&nbsp;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MANAGER &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html">devices::vl53l0x::VL53L0X</a>&lt; <a class="el" href="classi2c_1_1_i2_c_device.html#a7b3f6509519292904a636f4262b404ae">MANAGER</a> &gt;::begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedevices_1_1vl53l0x.html#af48a92ac24c4f93d2513d4969b4d5a67">Profile</a>&#160;</td>
          <td class="paramname"><em>profile</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fully initialize this <a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html" title="I2C device driver for the VL53L0X ToF ranging chip.">VL53L0X</a> device and configures it with provided <code>profile</code>. </p>
<p>Once this method has been called successfully, you can start perform ranging (continuous or not). You may also want to set some GPIO interrupts before ranging. </p><dl class="section warning"><dt>Warning</dt><dd>Blocking API! </dd></dl>
<dl class="section note"><dt>Note</dt><dd>High-level API If you need more custom settings to initalize the device you should turn to mid-level API.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">profile</td><td>the pre-defined Profile to use on this sensor </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if the operation succeeded </td></tr>
    <tr><td class="paramname">false</td><td>if the operation failed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#ab2f73ffeafc9aea3196af584ed39d49f" title="Start continuous ranging on this VL53L0X device.">start_continuous_ranging()</a> </dd>
<dd>
<a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#ac4f4e6608fff114b29b5fc2a0239d66f" title="Perform a single range action on VL53L0X device, and wait for the measurement result.">await_single_range()</a></dd>
<dd>
<a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#ade2b985682bbaf683ef14d03a0f601f0" title="Set new GPIOSettings for this device.">set_GPIO_settings()</a></dd>
<dd>
<a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#a4b1a1492545e40f4ea981a330bb0bd2c" title="Perform 1st stage initialization of this VL53L0X device.">init_data_first()</a> </dd>
<dd>
<a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#a6a8a8c4cf17cf856fd449e25ce89c9a7" title="Perform 2nd stage initialization of this VL53L0X device.">init_static_second()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="vl53l0x_8h_source.html#l00170">170</a> of file <a class="el" href="vl53l0x_8h_source.html">vl53l0x.h</a>.</p>

</div>
</div>
<a id="ac4f4e6608fff114b29b5fc2a0239d66f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4f4e6608fff114b29b5fc2a0239d66f">&#9670;&nbsp;</a></span>await_single_range() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MANAGER &gt; </div>
<div class="memtemplate">
template&lt;board::Timer TIMER&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html">devices::vl53l0x::VL53L0X</a>&lt; <a class="el" href="classi2c_1_1_i2_c_device.html#a7b3f6509519292904a636f4262b404ae">MANAGER</a> &gt;::await_single_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtimer_1_1_r_t_t.html">timer::RTT</a>&lt; TIMER &gt; &amp;&#160;</td>
          <td class="paramname"><em>rtt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t &amp;&#160;</td>
          <td class="paramname"><em>range_mm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>timeout_ms</em> = <code>DEFAULT_TIMEOUT_MS</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform a single range action on <a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html" title="I2C device driver for the VL53L0X ToF ranging chip.">VL53L0X</a> device, and wait for the measurement result. </p>
<p>This shall be used when no continuous ranging is in effect. </p><dl class="section warning"><dt>Warning</dt><dd>Blocking API! </dd></dl>
<dl class="section note"><dt>Note</dt><dd>High-level API </dd>
<dd>
Mid-level API</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TIMER</td><td>the Timer used for <code>rtt</code>; this template argument will be automatically deduced from <code>rtt</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rtt</td><td>the real-time timer to use to count elapsed time </td></tr>
    <tr><td class="paramname">range_mm</td><td>a reference to a variable that will receive the measurement result (in mm) </td></tr>
    <tr><td class="paramname">timeout_ms</td><td>the maximum amount of time to wait for a result; default is 100ms, but it should be higher than the measurement timing budget. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if the operation succeeded </td></tr>
    <tr><td class="paramname">false</td><td>if the operation failed or timed out</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#a82e29546fa72e9d961c02cae43227004" title="Set new &quot;measurement timing budget&quot; for this device.">set_measurement_timing_budget()</a> </dd>
<dd>
<a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#aae960c2e625f7eac7dcceed8ed440d71" title="Perform a single range action on VL53L0X device, and wait for the measurement result.">await_single_range(uint16_t&amp;, uint16_t)</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="vl53l0x_8h_source.html#l00229">229</a> of file <a class="el" href="vl53l0x_8h_source.html">vl53l0x.h</a>.</p>

</div>
</div>
<a id="ab2f73ffeafc9aea3196af584ed39d49f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2f73ffeafc9aea3196af584ed39d49f">&#9670;&nbsp;</a></span>start_continuous_ranging()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MANAGER &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html">devices::vl53l0x::VL53L0X</a>&lt; <a class="el" href="classi2c_1_1_i2_c_device.html#a7b3f6509519292904a636f4262b404ae">MANAGER</a> &gt;::start_continuous_ranging </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>period_ms</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Start continuous ranging on this <a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html" title="I2C device driver for the VL53L0X ToF ranging chip.">VL53L0X</a> device. </p>
<p>This method shall not be called before the device has been properly initialized, either with high-level API <code><a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#aa0ca4aab9ad8b6b7e76ca34ee29e2e68" title="Fully initialize this VL53L0X device and configures it with provided profile.">begin()</a></code> or mid-level API methods <code><a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#a4b1a1492545e40f4ea981a330bb0bd2c" title="Perform 1st stage initialization of this VL53L0X device.">init_data_first()</a></code>, <code><a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#a6a8a8c4cf17cf856fd449e25ce89c9a7" title="Perform 2nd stage initialization of this VL53L0X device.">init_static_second()</a></code> and <code><a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#a8e0a9fa13a07bd23170ce92897707326" title="Perform VL53L0X VHV and Phase calibration.">perform_ref_calibration()</a></code>. Once this method has been called, continuous ranging starts on the device, at the given period. You can check when a sample is ready to read by examining interrupt status or reange status, then you can read the range and clear the interrupt. Or you may prefer just await for new range which is easier to code but will block your program. </p><dl class="section warning"><dt>Warning</dt><dd>Blocking API! </dd></dl>
<dl class="section note"><dt>Note</dt><dd>High-level API </dd>
<dd>
Mid-level API</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">period_ms</td><td>the period, in ms, between 2 consecutive ranging measures; if <code>0</code> (the default), then consecutive measures will follow each other with no delay ("back-to-back" mode). </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if the operation succeeded </td></tr>
    <tr><td class="paramname">false</td><td>if the operation failed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>stop_continuous_range() </dd>
<dd>
<a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#aa483218a8665973bf86c444f9617539d" title="Wait for the next continuous ranging measure on VL53L0X device to be ready and return the result.">await_continuous_range()</a> </dd>
<dd>
<a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#a51dd5f693458885893c7205af992e01e" title="Get current InterruptStatus from this device.">get_interrupt_status()</a> </dd>
<dd>
<a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#aca4f6aca99f2481fc8f2c48388dfdf78" title="Get current DeviceStatus from this device.">get_range_status()</a> </dd>
<dd>
<a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#a5862141562c208d0519d6049c73a1b76" title="Get range measured by this device.">get_direct_range()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="vl53l0x_8h_source.html#l00282">282</a> of file <a class="el" href="vl53l0x_8h_source.html">vl53l0x.h</a>.</p>

</div>
</div>
<a id="aa483218a8665973bf86c444f9617539d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa483218a8665973bf86c444f9617539d">&#9670;&nbsp;</a></span>await_continuous_range() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MANAGER &gt; </div>
<div class="memtemplate">
template&lt;board::Timer TIMER&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html">devices::vl53l0x::VL53L0X</a>&lt; <a class="el" href="classi2c_1_1_i2_c_device.html#a7b3f6509519292904a636f4262b404ae">MANAGER</a> &gt;::await_continuous_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtimer_1_1_r_t_t.html">timer::RTT</a>&lt; TIMER &gt; &amp;&#160;</td>
          <td class="paramname"><em>rtt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t &amp;&#160;</td>
          <td class="paramname"><em>range_mm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>timeout_ms</em> = <code>DEFAULT_TIMEOUT_MS</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wait for the next continuous ranging measure on <a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html" title="I2C device driver for the VL53L0X ToF ranging chip.">VL53L0X</a> device to be ready and return the result. </p>
<p>This shall be used only when continuous ranging is in effect. </p><dl class="section warning"><dt>Warning</dt><dd>Blocking API! </dd></dl>
<dl class="section note"><dt>Note</dt><dd>High-level API </dd>
<dd>
Mid-level API</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TIMER</td><td>the Timer used for <code>rtt</code>; this template argument will be automatically deduced from <code>rtt</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rtt</td><td>the real-time timer to use to count elapsed time </td></tr>
    <tr><td class="paramname">range_mm</td><td>a reference to a variable that will receive the measurement result (in mm) </td></tr>
    <tr><td class="paramname">timeout_ms</td><td>the maximum amount of time to wait for a result; default is 100ms, but it should be higher than the measurement timing budget. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if the operation succeeded </td></tr>
    <tr><td class="paramname">false</td><td>if the operation failed or timed out</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#ab2f73ffeafc9aea3196af584ed39d49f" title="Start continuous ranging on this VL53L0X device.">start_continuous_ranging()</a> </dd>
<dd>
<a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#a82e29546fa72e9d961c02cae43227004" title="Set new &quot;measurement timing budget&quot; for this device.">set_measurement_timing_budget()</a> </dd>
<dd>
<a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#aa8a6f66bce9f717f4d81077cf1a6b1eb" title="Wait for the next continuous ranging measure on VL53L0X device to be ready and return the result.">await_continuous_range(uint16_t&amp;, uint16_t)</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="vl53l0x_8h_source.html#l00324">324</a> of file <a class="el" href="vl53l0x_8h_source.html">vl53l0x.h</a>.</p>

</div>
</div>
<a id="a97a6d9833c513779ebc0c8e7ab98ed43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97a6d9833c513779ebc0c8e7ab98ed43">&#9670;&nbsp;</a></span>stop_continuous_ranging()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MANAGER &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html">devices::vl53l0x::VL53L0X</a>&lt; <a class="el" href="classi2c_1_1_i2_c_device.html#a7b3f6509519292904a636f4262b404ae">MANAGER</a> &gt;::stop_continuous_ranging </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stop continuous ranging on this <a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html" title="I2C device driver for the VL53L0X ToF ranging chip.">VL53L0X</a> device. </p>
<dl class="section warning"><dt>Warning</dt><dd>Blocking API! </dd></dl>
<dl class="section note"><dt>Note</dt><dd>High-level API </dd>
<dd>
Mid-level API</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if the operation succeeded </td></tr>
    <tr><td class="paramname">false</td><td>if the operation failed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>start_continuous_range() </dd></dl>

<p class="definition">Definition at line <a class="el" href="vl53l0x_8h_source.html#l00343">343</a> of file <a class="el" href="vl53l0x_8h_source.html">vl53l0x.h</a>.</p>

</div>
</div>
<a id="af1251ef487dbf56cdbda29135b02f6f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1251ef487dbf56cdbda29135b02f6f9">&#9670;&nbsp;</a></span>reset_device()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MANAGER &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html">devices::vl53l0x::VL53L0X</a>&lt; <a class="el" href="classi2c_1_1_i2_c_device.html#a7b3f6509519292904a636f4262b404ae">MANAGER</a> &gt;::reset_device </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset <a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html" title="I2C device driver for the VL53L0X ToF ranging chip.">VL53L0X</a> device. </p>
<p>After this method is called, the device is in the same state as after power-up, hence device must be reinitialized from scratch. </p><dl class="section warning"><dt>Warning</dt><dd>Blocking API! </dd></dl>
<dl class="section note"><dt>Note</dt><dd>High-level API </dd>
<dd>
Mid-level API</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if the operation succeeded </td></tr>
    <tr><td class="paramname">false</td><td>if the operation failed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#aa0ca4aab9ad8b6b7e76ca34ee29e2e68" title="Fully initialize this VL53L0X device and configures it with provided profile.">begin()</a> </dd>
<dd>
<a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#a4b1a1492545e40f4ea981a330bb0bd2c" title="Perform 1st stage initialization of this VL53L0X device.">init_data_first()</a> </dd>
<dd>
<a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#a6a8a8c4cf17cf856fd449e25ce89c9a7" title="Perform 2nd stage initialization of this VL53L0X device.">init_static_second()</a> </dd>
<dd>
<a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#a8e0a9fa13a07bd23170ce92897707326" title="Perform VL53L0X VHV and Phase calibration.">perform_ref_calibration()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="vl53l0x_8h_source.html#l00365">365</a> of file <a class="el" href="vl53l0x_8h_source.html">vl53l0x.h</a>.</p>

</div>
</div>
<a id="a4b1a1492545e40f4ea981a330bb0bd2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b1a1492545e40f4ea981a330bb0bd2c">&#9670;&nbsp;</a></span>init_data_first()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MANAGER &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html">devices::vl53l0x::VL53L0X</a>&lt; <a class="el" href="classi2c_1_1_i2_c_device.html#a7b3f6509519292904a636f4262b404ae">MANAGER</a> &gt;::init_data_first </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform 1st stage initialization of this <a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html" title="I2C device driver for the VL53L0X ToF ranging chip.">VL53L0X</a> device. </p>
<p><a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html" title="I2C device driver for the VL53L0X ToF ranging chip.">VL53L0X</a> initialization is made of 3 steps before it can perform any ranging:</p><ul>
<li>data init: must be performed once only after device power-up</li>
<li>static init: must be performed at least once, after data init, but can be called several times to changes ranging steps sequence</li>
<li>reference calibration: must be performed once One method exists for each stage.</li>
</ul>
<p>After initalization, you may call methods changing all kinds of settings. Finally, you may then perform ranging, continuously or not.</p>
<dl class="section warning"><dt>Warning</dt><dd>Blocking API! </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Mid-level API If you want simpler initialization of the device, you should turn to high-level API.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if the operation succeeded </td></tr>
    <tr><td class="paramname">false</td><td>if the operation failed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#a6a8a8c4cf17cf856fd449e25ce89c9a7" title="Perform 2nd stage initialization of this VL53L0X device.">init_static_second()</a> </dd>
<dd>
<a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#a8e0a9fa13a07bd23170ce92897707326" title="Perform VL53L0X VHV and Phase calibration.">perform_ref_calibration()</a> </dd>
<dd>
<a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#aa0ca4aab9ad8b6b7e76ca34ee29e2e68" title="Fully initialize this VL53L0X device and configures it with provided profile.">begin()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="vl53l0x_8h_source.html#l00417">417</a> of file <a class="el" href="vl53l0x_8h_source.html">vl53l0x.h</a>.</p>

</div>
</div>
<a id="a6a8a8c4cf17cf856fd449e25ce89c9a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a8a8c4cf17cf856fd449e25ce89c9a7">&#9670;&nbsp;</a></span>init_static_second()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MANAGER &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html">devices::vl53l0x::VL53L0X</a>&lt; <a class="el" href="classi2c_1_1_i2_c_device.html#a7b3f6509519292904a636f4262b404ae">MANAGER</a> &gt;::init_static_second </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdevices_1_1vl53l0x_1_1_g_p_i_o_settings.html">GPIOSettings</a> &amp;&#160;</td>
          <td class="paramname"><em>settings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdevices_1_1vl53l0x_1_1_sequence_steps.html">SequenceSteps</a>&#160;</td>
          <td class="paramname"><em>steps</em> = <code><a class="el" href="classdevices_1_1vl53l0x_1_1_sequence_steps.html#abc9fef218832edf1808741c45c3053b6">SequenceSteps::create</a>().pre_range().final_range().dss()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform 2nd stage initialization of this <a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html" title="I2C device driver for the VL53L0X ToF ranging chip.">VL53L0X</a> device. </p>
<p>This must be called once, or more, after <code><a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#a4b1a1492545e40f4ea981a330bb0bd2c" title="Perform 1st stage initialization of this VL53L0X device.">init_data_first()</a></code> has been called. It allows you to select which ranging steps shall be used afterwards.</p>
<dl class="section warning"><dt>Warning</dt><dd>Blocking API! </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Mid-level API If you want simpler initialization of the device, you should turn to high-level API.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">settings</td><td>intial GPIO settings to set on the device; these settings can be changed anytime later. </td></tr>
    <tr><td class="paramname">steps</td><td>the ranging steps sequence </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if the operation succeeded </td></tr>
    <tr><td class="paramname">false</td><td>if the operation failed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#ade2b985682bbaf683ef14d03a0f601f0" title="Set new GPIOSettings for this device.">set_GPIO_settings()</a> </dd>
<dd>
<a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#a9a7233dd506e05a69fc0f1a1d5aeca9f" title="Set measurement steps to be executed in sequence by the device during ranging.">set_sequence_steps()</a> </dd>
<dd>
<a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#a4b1a1492545e40f4ea981a330bb0bd2c" title="Perform 1st stage initialization of this VL53L0X device.">init_data_first()</a> </dd>
<dd>
<a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#a8e0a9fa13a07bd23170ce92897707326" title="Perform VL53L0X VHV and Phase calibration.">perform_ref_calibration()</a> </dd>
<dd>
<a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#aa0ca4aab9ad8b6b7e76ca34ee29e2e68" title="Fully initialize this VL53L0X device and configures it with provided profile.">begin()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="vl53l0x_8h_source.html#l00455">455</a> of file <a class="el" href="vl53l0x_8h_source.html">vl53l0x.h</a>.</p>

</div>
</div>
<a id="a8e0a9fa13a07bd23170ce92897707326"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e0a9fa13a07bd23170ce92897707326">&#9670;&nbsp;</a></span>perform_ref_calibration()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MANAGER &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html">devices::vl53l0x::VL53L0X</a>&lt; <a class="el" href="classi2c_1_1_i2_c_device.html#a7b3f6509519292904a636f4262b404ae">MANAGER</a> &gt;::perform_ref_calibration </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform <a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html" title="I2C device driver for the VL53L0X ToF ranging chip.">VL53L0X</a> VHV and Phase calibration. </p>
<p>This must be called once before any measurement, but after data and static initalization.</p>
<dl class="section warning"><dt>Warning</dt><dd>Blocking API! </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Mid-level API If you want simpler initialization of the device, you should turn to high-level API.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if the operation succeeded </td></tr>
    <tr><td class="paramname">false</td><td>if the operation failed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#a4b1a1492545e40f4ea981a330bb0bd2c" title="Perform 1st stage initialization of this VL53L0X device.">init_data_first()</a> </dd>
<dd>
<a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#a6a8a8c4cf17cf856fd449e25ce89c9a7" title="Perform 2nd stage initialization of this VL53L0X device.">init_static_second()</a> </dd>
<dd>
<a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#aa0ca4aab9ad8b6b7e76ca34ee29e2e68" title="Fully initialize this VL53L0X device and configures it with provided profile.">begin()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="vl53l0x_8h_source.html#l00496">496</a> of file <a class="el" href="vl53l0x_8h_source.html">vl53l0x.h</a>.</p>

</div>
</div>
<a id="aca4f6aca99f2481fc8f2c48388dfdf78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca4f6aca99f2481fc8f2c48388dfdf78">&#9670;&nbsp;</a></span>get_range_status() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MANAGER &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html">devices::vl53l0x::VL53L0X</a>&lt; <a class="el" href="classi2c_1_1_i2_c_device.html#a7b3f6509519292904a636f4262b404ae">MANAGER</a> &gt;::get_range_status </td>
          <td>(</td>
          <td class="paramtype">PROXY&lt; <a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#ae755d8e7d051d0969d1d9310dca57f2d">GetRangeStatusFuture</a> &gt;&#160;</td>
          <td class="paramname"><em>future</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get current <code><a class="el" href="classdevices_1_1vl53l0x_1_1_device_status.html" title="Status of device as retrieved by VL53L0X::get_range_status().">DeviceStatus</a></code> from this device. </p>
<dl class="section warning"><dt>Warning</dt><dd>Asynchronous API! </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Mid-level API</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">future</td><td>a GetRangeStatusFuture passed by the caller, that will be updated once the current I2C action is finished. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>if no problem occurred during the preparation of I2C transaction </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an error code if something bad happened; for an asynchronous I2C Manager, this typically happens when its queue of I2CCommand is full; for a synchronous I2C Manager, any error on the I2C bus or on the target device will trigger an error here. the list of possible errors</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#a624511dcfa3565eb74721541432998f0" title="Get current DeviceStatus from this device.">get_range_status(DeviceStatus&amp;)</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="vl53l0x_8h_source.html#l00537">537</a> of file <a class="el" href="vl53l0x_8h_source.html">vl53l0x.h</a>.</p>

</div>
</div>
<a id="a624511dcfa3565eb74721541432998f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a624511dcfa3565eb74721541432998f0">&#9670;&nbsp;</a></span>get_range_status() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MANAGER &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html">devices::vl53l0x::VL53L0X</a>&lt; <a class="el" href="classi2c_1_1_i2_c_device.html#a7b3f6509519292904a636f4262b404ae">MANAGER</a> &gt;::get_range_status </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdevices_1_1vl53l0x_1_1_device_status.html">DeviceStatus</a> &amp;&#160;</td>
          <td class="paramname"><em>range_status</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get current <code><a class="el" href="classdevices_1_1vl53l0x_1_1_device_status.html" title="Status of device as retrieved by VL53L0X::get_range_status().">DeviceStatus</a></code> from this device. </p>
<dl class="section warning"><dt>Warning</dt><dd>Blocking API! </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Mid-level API</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">range_status</td><td>a reference to a variable that will receive the device status </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if the operation succeeded </td></tr>
    <tr><td class="paramname">false</td><td>if the operation failed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#aca4f6aca99f2481fc8f2c48388dfdf78" title="Get current DeviceStatus from this device.">get_range_status()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="vl53l0x_8h_source.html#l00554">554</a> of file <a class="el" href="vl53l0x_8h_source.html">vl53l0x.h</a>.</p>

</div>
</div>
<a id="a53e8216f2f8ce75d5c79727b1db5a773"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53e8216f2f8ce75d5c79727b1db5a773">&#9670;&nbsp;</a></span>get_GPIO_settings() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MANAGER &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html">devices::vl53l0x::VL53L0X</a>&lt; <a class="el" href="classi2c_1_1_i2_c_device.html#a7b3f6509519292904a636f4262b404ae">MANAGER</a> &gt;::get_GPIO_settings </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x_1_1_get_g_p_i_o_settings_future.html">GetGPIOSettingsFuture</a> &amp;&#160;</td>
          <td class="paramname"><em>future</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get current <code><a class="el" href="classdevices_1_1vl53l0x_1_1_g_p_i_o_settings.html" title="Settings for behavior of VL53L0X GPIO pin.">GPIOSettings</a></code> from this device. </p>
<dl class="section warning"><dt>Warning</dt><dd>Asynchronous API! </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Mid-level API</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">future</td><td>a <a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x_1_1_get_g_p_i_o_settings_future.html" title="Future to get device current GPIO settings.">GetGPIOSettingsFuture</a> passed by the caller, that will be updated once the current I2C action is finished. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>if no problem occurred during the preparation of I2C transaction </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an error code if something bad happened; for an asynchronous I2C Manager, this typically happens when its queue of I2CCommand is full; for a synchronous I2C Manager, any error on the I2C bus or on the target device will trigger an error here. the list of possible errors</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#ade2b985682bbaf683ef14d03a0f601f0" title="Set new GPIOSettings for this device.">set_GPIO_settings()</a> </dd>
<dd>
<a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#ab6acc0a701ceea05f086a4c3780b83b1" title="Get current GPIOSettings from this device.">get_GPIO_settings(GPIOSettings&amp;)</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="vl53l0x_8h_source.html#l00628">628</a> of file <a class="el" href="vl53l0x_8h_source.html">vl53l0x.h</a>.</p>

</div>
</div>
<a id="ab6acc0a701ceea05f086a4c3780b83b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6acc0a701ceea05f086a4c3780b83b1">&#9670;&nbsp;</a></span>get_GPIO_settings() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MANAGER &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html">devices::vl53l0x::VL53L0X</a>&lt; <a class="el" href="classi2c_1_1_i2_c_device.html#a7b3f6509519292904a636f4262b404ae">MANAGER</a> &gt;::get_GPIO_settings </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdevices_1_1vl53l0x_1_1_g_p_i_o_settings.html">GPIOSettings</a> &amp;&#160;</td>
          <td class="paramname"><em>settings</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get current <code><a class="el" href="classdevices_1_1vl53l0x_1_1_g_p_i_o_settings.html" title="Settings for behavior of VL53L0X GPIO pin.">GPIOSettings</a></code> from this device. </p>
<dl class="section warning"><dt>Warning</dt><dd>Blocking API! </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Mid-level API</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">settings</td><td>a reference to a variable that will receive the current GPIO settings for this device </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if the operation succeeded </td></tr>
    <tr><td class="paramname">false</td><td>if the operation failed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#a3f67a427dfbe6073bc6ba1a50aaf1be2" title="Set new GPIOSettings for this device.">set_GPIO_settings(const GPIOSettings&amp;)</a> </dd>
<dd>
<a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#a53e8216f2f8ce75d5c79727b1db5a773" title="Get current GPIOSettings from this device.">get_GPIO_settings()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="vl53l0x_8h_source.html#l00646">646</a> of file <a class="el" href="vl53l0x_8h_source.html">vl53l0x.h</a>.</p>

</div>
</div>
<a id="ade2b985682bbaf683ef14d03a0f601f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade2b985682bbaf683ef14d03a0f601f0">&#9670;&nbsp;</a></span>set_GPIO_settings() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MANAGER &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html">devices::vl53l0x::VL53L0X</a>&lt; <a class="el" href="classi2c_1_1_i2_c_device.html#a7b3f6509519292904a636f4262b404ae">MANAGER</a> &gt;::set_GPIO_settings </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x_1_1_set_g_p_i_o_settings_future.html">SetGPIOSettingsFuture</a> &amp;&#160;</td>
          <td class="paramname"><em>future</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set new <code><a class="el" href="classdevices_1_1vl53l0x_1_1_g_p_i_o_settings.html" title="Settings for behavior of VL53L0X GPIO pin.">GPIOSettings</a></code> for this device. </p>
<dl class="section warning"><dt>Warning</dt><dd>Asynchronous API! </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Mid-level API</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">future</td><td>a <a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x_1_1_set_g_p_i_o_settings_future.html" title="Future to set device GPIO settings.">SetGPIOSettingsFuture</a> passed by the caller, that will be updated once the current I2C action is finished. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>if no problem occurred during the preparation of I2C transaction </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an error code if something bad happened; for an asynchronous I2C Manager, this typically happens when its queue of I2CCommand is full; for a synchronous I2C Manager, any error on the I2C bus or on the target device will trigger an error here. the list of possible errors</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#a53e8216f2f8ce75d5c79727b1db5a773" title="Get current GPIOSettings from this device.">get_GPIO_settings()</a> </dd>
<dd>
<a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#a3f67a427dfbe6073bc6ba1a50aaf1be2" title="Set new GPIOSettings for this device.">set_GPIO_settings(const GPIOSettings&amp;)</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="vl53l0x_8h_source.html#l00716">716</a> of file <a class="el" href="vl53l0x_8h_source.html">vl53l0x.h</a>.</p>

</div>
</div>
<a id="a3f67a427dfbe6073bc6ba1a50aaf1be2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f67a427dfbe6073bc6ba1a50aaf1be2">&#9670;&nbsp;</a></span>set_GPIO_settings() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MANAGER &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html">devices::vl53l0x::VL53L0X</a>&lt; <a class="el" href="classi2c_1_1_i2_c_device.html#a7b3f6509519292904a636f4262b404ae">MANAGER</a> &gt;::set_GPIO_settings </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdevices_1_1vl53l0x_1_1_g_p_i_o_settings.html">GPIOSettings</a> &amp;&#160;</td>
          <td class="paramname"><em>settings</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set new <code><a class="el" href="classdevices_1_1vl53l0x_1_1_g_p_i_o_settings.html" title="Settings for behavior of VL53L0X GPIO pin.">GPIOSettings</a></code> for this device. </p>
<dl class="section warning"><dt>Warning</dt><dd>Blocking API! </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Mid-level API</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">settings</td><td>new GPIO settings to write to this device </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if the operation succeeded </td></tr>
    <tr><td class="paramname">false</td><td>if the operation failed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#ade2b985682bbaf683ef14d03a0f601f0" title="Set new GPIOSettings for this device.">set_GPIO_settings()</a> </dd>
<dd>
<a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#ab6acc0a701ceea05f086a4c3780b83b1" title="Get current GPIOSettings from this device.">get_GPIO_settings(GPIOSettings&amp;)</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="vl53l0x_8h_source.html#l00733">733</a> of file <a class="el" href="vl53l0x_8h_source.html">vl53l0x.h</a>.</p>

</div>
</div>
<a id="a51dd5f693458885893c7205af992e01e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51dd5f693458885893c7205af992e01e">&#9670;&nbsp;</a></span>get_interrupt_status() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MANAGER &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html">devices::vl53l0x::VL53L0X</a>&lt; <a class="el" href="classi2c_1_1_i2_c_device.html#a7b3f6509519292904a636f4262b404ae">MANAGER</a> &gt;::get_interrupt_status </td>
          <td>(</td>
          <td class="paramtype">PROXY&lt; <a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#a9805d95efcc5eaa1a0842f3c8e09191c">GetInterruptStatusFuture</a> &gt;&#160;</td>
          <td class="paramname"><em>future</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get current <code>InterruptStatus</code> from this device. </p>
<dl class="section warning"><dt>Warning</dt><dd>Asynchronous API! </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Mid-level API</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">future</td><td>a GetInterruptStatusFuture passed by the caller, that will be updated once the current I2C action is finished. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>if no problem occurred during the preparation of I2C transaction </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an error code if something bad happened; for an asynchronous I2C Manager, this typically happens when its queue of I2CCommand is full; for a synchronous I2C Manager, any error on the I2C bus or on the target device will trigger an error here. the list of possible errors</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#ac7024a3679d48172131311740a882199" title="Clear interrupt status from this device.">clear_interrupt()</a> </dd>
<dd>
<a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#a83db71bb4afce0c0ff060707c2018380" title="Get current InterruptStatus from this device.">get_interrupt_status(InterruptStatus&amp;)</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="vl53l0x_8h_source.html#l00762">762</a> of file <a class="el" href="vl53l0x_8h_source.html">vl53l0x.h</a>.</p>

</div>
</div>
<a id="a83db71bb4afce0c0ff060707c2018380"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83db71bb4afce0c0ff060707c2018380">&#9670;&nbsp;</a></span>get_interrupt_status() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MANAGER &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html">devices::vl53l0x::VL53L0X</a>&lt; <a class="el" href="classi2c_1_1_i2_c_device.html#a7b3f6509519292904a636f4262b404ae">MANAGER</a> &gt;::get_interrupt_status </td>
          <td>(</td>
          <td class="paramtype">InterruptStatus &amp;&#160;</td>
          <td class="paramname"><em>status</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get current <code>InterruptStatus</code> from this device. </p>
<dl class="section warning"><dt>Warning</dt><dd>Blocking API! </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Mid-level API</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">status</td><td>a reference to a variable that will receive the current interrupt status of this device </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if the operation succeeded </td></tr>
    <tr><td class="paramname">false</td><td>if the operation failed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#a8ace6d3d462d6a26340ad8b2532986fd" title="Clear interrupt status from this device.">clear_interrupt(uint8_t)</a> </dd>
<dd>
<a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#a51dd5f693458885893c7205af992e01e" title="Get current InterruptStatus from this device.">get_interrupt_status()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="vl53l0x_8h_source.html#l00780">780</a> of file <a class="el" href="vl53l0x_8h_source.html">vl53l0x.h</a>.</p>

</div>
</div>
<a id="ac7024a3679d48172131311740a882199"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7024a3679d48172131311740a882199">&#9670;&nbsp;</a></span>clear_interrupt() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MANAGER &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html">devices::vl53l0x::VL53L0X</a>&lt; <a class="el" href="classi2c_1_1_i2_c_device.html#a7b3f6509519292904a636f4262b404ae">MANAGER</a> &gt;::clear_interrupt </td>
          <td>(</td>
          <td class="paramtype">PROXY&lt; <a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#a03993b90b542fc88f314620165f0b4b4">ClearInterruptFuture</a> &gt;&#160;</td>
          <td class="paramname"><em>future</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear interrupt status from this device. </p>
<dl class="section warning"><dt>Warning</dt><dd>Asynchronous API! </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Mid-level API</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">future</td><td>a ClearInterruptFuture passed by the caller, that will be updated once the current I2C action is finished. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>if no problem occurred during the preparation of I2C transaction </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an error code if something bad happened; for an asynchronous I2C Manager, this typically happens when its queue of I2CCommand is full; for a synchronous I2C Manager, any error on the I2C bus or on the target device will trigger an error here. the list of possible errors</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#a8ace6d3d462d6a26340ad8b2532986fd" title="Clear interrupt status from this device.">clear_interrupt(uint8_t)</a> </dd>
<dd>
<a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#a51dd5f693458885893c7205af992e01e" title="Get current InterruptStatus from this device.">get_interrupt_status()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="vl53l0x_8h_source.html#l00807">807</a> of file <a class="el" href="vl53l0x_8h_source.html">vl53l0x.h</a>.</p>

</div>
</div>
<a id="a8ace6d3d462d6a26340ad8b2532986fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ace6d3d462d6a26340ad8b2532986fd">&#9670;&nbsp;</a></span>clear_interrupt() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MANAGER &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html">devices::vl53l0x::VL53L0X</a>&lt; <a class="el" href="classi2c_1_1_i2_c_device.html#a7b3f6509519292904a636f4262b404ae">MANAGER</a> &gt;::clear_interrupt </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>clear_mask</em> = <code>0x01</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear interrupt status from this device. </p>
<dl class="section warning"><dt>Warning</dt><dd>Blocking API! </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Mid-level API</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clear_mask</td><td>the mask of the interrupts to be cleared </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if the operation succeeded </td></tr>
    <tr><td class="paramname">false</td><td>if the operation failed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#a51dd5f693458885893c7205af992e01e" title="Get current InterruptStatus from this device.">get_interrupt_status()</a> </dd>
<dd>
<a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#ac7024a3679d48172131311740a882199" title="Clear interrupt status from this device.">clear_interrupt()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="vl53l0x_8h_source.html#l00824">824</a> of file <a class="el" href="vl53l0x_8h_source.html">vl53l0x.h</a>.</p>

</div>
</div>
<a id="abd38fce6e1cfac0c6eca209d818b72ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd38fce6e1cfac0c6eca209d818b72ec">&#9670;&nbsp;</a></span>await_interrupt() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MANAGER &gt; </div>
<div class="memtemplate">
template&lt;board::Timer TIMER&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html">devices::vl53l0x::VL53L0X</a>&lt; <a class="el" href="classi2c_1_1_i2_c_device.html#a7b3f6509519292904a636f4262b404ae">MANAGER</a> &gt;::await_interrupt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtimer_1_1_r_t_t.html">timer::RTT</a>&lt; TIMER &gt; &amp;&#160;</td>
          <td class="paramname"><em>rtt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>timeout_ms</em> = <code>DEFAULT_TIMEOUT_MS</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wait for an interrupt condition on <a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html" title="I2C device driver for the VL53L0X ToF ranging chip.">VL53L0X</a> device. </p>
<dl class="section warning"><dt>Warning</dt><dd>Blocking API! </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Mid-level API</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TIMER</td><td>the Timer used for <code>rtt</code>; this template argument will be automatically deduced from <code>rtt</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rtt</td><td>the real-time timer to use to count elapsed time </td></tr>
    <tr><td class="paramname">timeout_ms</td><td>the maximum amount of time to wait for a result; default is 100ms, but it should be higher than the measurement timing budget. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if the operation succeeded </td></tr>
    <tr><td class="paramname">false</td><td>if the operation failed or timed out</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#aa483218a8665973bf86c444f9617539d" title="Wait for the next continuous ranging measure on VL53L0X device to be ready and return the result.">await_continuous_range()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="vl53l0x_8h_source.html#l00846">846</a> of file <a class="el" href="vl53l0x_8h_source.html">vl53l0x.h</a>.</p>

</div>
</div>
<a id="a5862141562c208d0519d6049c73a1b76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5862141562c208d0519d6049c73a1b76">&#9670;&nbsp;</a></span>get_direct_range() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MANAGER &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html">devices::vl53l0x::VL53L0X</a>&lt; <a class="el" href="classi2c_1_1_i2_c_device.html#a7b3f6509519292904a636f4262b404ae">MANAGER</a> &gt;::get_direct_range </td>
          <td>(</td>
          <td class="paramtype">PROXY&lt; <a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#a636ae6705cb4cc2946acc8b89699703a">GetDirectRangeFuture</a> &gt;&#160;</td>
          <td class="paramname"><em>future</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get range measured by this device. </p>
<p>This method does not wait for anything, it just gets the current value in the range register. This is useful only when you know a range is ready to read. In general, this method shall be used only after device interrupt status != 0, then interrupt status should be cleared immediately after. You would probably prefer to use methods that first await for range measure to be ready before returning its value.</p>
<dl class="section warning"><dt>Warning</dt><dd>Asynchronous API! </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Mid-level API</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">future</td><td>a GetDirectRangeFuture passed by the caller, that will be updated once the current I2C action is finished. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>if no problem occurred during the preparation of I2C transaction </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an error code if something bad happened; for an asynchronous I2C Manager, this typically happens when its queue of I2CCommand is full; for a synchronous I2C Manager, any error on the I2C bus or on the target device will trigger an error here. the list of possible errors</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#ac4f4e6608fff114b29b5fc2a0239d66f" title="Perform a single range action on VL53L0X device, and wait for the measurement result.">await_single_range()</a> </dd>
<dd>
<a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#aa483218a8665973bf86c444f9617539d" title="Wait for the next continuous ranging measure on VL53L0X device to be ready and return the result.">await_continuous_range()</a> </dd>
<dd>
<a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#a794c143fd852c4c5c55040808719b1c5" title="Get range measured by this device.">get_direct_range(uint16_t&amp;)</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="vl53l0x_8h_source.html#l00890">890</a> of file <a class="el" href="vl53l0x_8h_source.html">vl53l0x.h</a>.</p>

</div>
</div>
<a id="a794c143fd852c4c5c55040808719b1c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a794c143fd852c4c5c55040808719b1c5">&#9670;&nbsp;</a></span>get_direct_range() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MANAGER &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html">devices::vl53l0x::VL53L0X</a>&lt; <a class="el" href="classi2c_1_1_i2_c_device.html#a7b3f6509519292904a636f4262b404ae">MANAGER</a> &gt;::get_direct_range </td>
          <td>(</td>
          <td class="paramtype">uint16_t &amp;&#160;</td>
          <td class="paramname"><em>range_mm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get range measured by this device. </p>
<p>This method does not wait for anything, it just gets the current value in the range register. This is useful only when you know a range is ready to read. You would probably prefer to use methods that first await for range measure to be ready before returning its value. </p><dl class="section warning"><dt>Warning</dt><dd>Blocking API! </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Mid-level API</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">range_mm</td><td>a reference to a variable that will receive the current range (in mm) stored in the device </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if the operation succeeded </td></tr>
    <tr><td class="paramname">false</td><td>if the operation failed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#ac4f4e6608fff114b29b5fc2a0239d66f" title="Perform a single range action on VL53L0X device, and wait for the measurement result.">await_single_range()</a> </dd>
<dd>
<a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#aa483218a8665973bf86c444f9617539d" title="Wait for the next continuous ranging measure on VL53L0X device to be ready and return the result.">await_continuous_range()</a> </dd>
<dd>
<a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#a5862141562c208d0519d6049c73a1b76" title="Get range measured by this device.">get_direct_range()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="vl53l0x_8h_source.html#l00914">914</a> of file <a class="el" href="vl53l0x_8h_source.html">vl53l0x.h</a>.</p>

</div>
</div>
<a id="a82e29546fa72e9d961c02cae43227004"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82e29546fa72e9d961c02cae43227004">&#9670;&nbsp;</a></span>set_measurement_timing_budget()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MANAGER &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html">devices::vl53l0x::VL53L0X</a>&lt; <a class="el" href="classi2c_1_1_i2_c_device.html#a7b3f6509519292904a636f4262b404ae">MANAGER</a> &gt;::set_measurement_timing_budget </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>budget_us</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set new "measurement timing budget" for this device. </p>
<p>This is the amount of time (in us) that is used to perform a range.</p>
<dl class="section warning"><dt>Warning</dt><dd>Blocking API! </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Mid-level API</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">budget_us</td><td>the new measurement timing budget to use for ranging; it must be bigger than 20000us; the actual minimum value also depends on other device settings, in particular the <code><a class="el" href="classdevices_1_1vl53l0x_1_1_sequence_steps.html" title="Hold VL53L0X sequence steps to use for ranging.">SequenceSteps</a></code> used for ranging. The bigger the budget, the higher the accuracy of measurements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if the operation succeeded </td></tr>
    <tr><td class="paramname">false</td><td>if the operation failed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#a37bd82e28ad1b866939264b67ba1c88e" title="Get current &quot;measurement timing budget&quot; for this device.">get_measurement_timing_budget()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="vl53l0x_8h_source.html#l00935">935</a> of file <a class="el" href="vl53l0x_8h_source.html">vl53l0x.h</a>.</p>

</div>
</div>
<a id="a37bd82e28ad1b866939264b67ba1c88e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37bd82e28ad1b866939264b67ba1c88e">&#9670;&nbsp;</a></span>get_measurement_timing_budget()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MANAGER &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html">devices::vl53l0x::VL53L0X</a>&lt; <a class="el" href="classi2c_1_1_i2_c_device.html#a7b3f6509519292904a636f4262b404ae">MANAGER</a> &gt;::get_measurement_timing_budget </td>
          <td>(</td>
          <td class="paramtype">uint32_t &amp;&#160;</td>
          <td class="paramname"><em>budget_us</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get current "measurement timing budget" for this device. </p>
<p>This is the amount of time (in us) that is used to perform a range. This amount is calculated based on other settings of the device.</p>
<dl class="section warning"><dt>Warning</dt><dd>Blocking API! </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Mid-level API</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">budget_us</td><td>a reference to a variable that will receive the current measurement timing budget for this device </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if the operation succeeded </td></tr>
    <tr><td class="paramname">false</td><td>if the operation failed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#a82e29546fa72e9d961c02cae43227004" title="Set new &quot;measurement timing budget&quot; for this device.">set_measurement_timing_budget()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="vl53l0x_8h_source.html#l00963">963</a> of file <a class="el" href="vl53l0x_8h_source.html">vl53l0x.h</a>.</p>

</div>
</div>
<a id="a9a7233dd506e05a69fc0f1a1d5aeca9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a7233dd506e05a69fc0f1a1d5aeca9f">&#9670;&nbsp;</a></span>set_sequence_steps()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MANAGER &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html">devices::vl53l0x::VL53L0X</a>&lt; <a class="el" href="classi2c_1_1_i2_c_device.html#a7b3f6509519292904a636f4262b404ae">MANAGER</a> &gt;::set_sequence_steps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdevices_1_1vl53l0x_1_1_sequence_steps.html">SequenceSteps</a>&#160;</td>
          <td class="paramname"><em>sequence_steps</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set measurement steps to be executed in sequence by the device during ranging. </p>
<dl class="section warning"><dt>Warning</dt><dd>Blocking API! </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Mid-level API</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sequence_steps</td><td>the sequence steps to use for ranging </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if the operation succeeded </td></tr>
    <tr><td class="paramname">false</td><td>if the operation failed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#a052110d0b12206e1e0f259be3be2f50b" title="Get current measurement steps executed in sequence by the device during ranging.">get_sequence_steps()</a> </dd>
<dd>
<a class="el" href="classdevices_1_1vl53l0x_1_1_sequence_steps.html" title="Hold VL53L0X sequence steps to use for ranging.">SequenceSteps</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="vl53l0x_8h_source.html#l00988">988</a> of file <a class="el" href="vl53l0x_8h_source.html">vl53l0x.h</a>.</p>

</div>
</div>
<a id="a052110d0b12206e1e0f259be3be2f50b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a052110d0b12206e1e0f259be3be2f50b">&#9670;&nbsp;</a></span>get_sequence_steps()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MANAGER &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html">devices::vl53l0x::VL53L0X</a>&lt; <a class="el" href="classi2c_1_1_i2_c_device.html#a7b3f6509519292904a636f4262b404ae">MANAGER</a> &gt;::get_sequence_steps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdevices_1_1vl53l0x_1_1_sequence_steps.html">SequenceSteps</a> &amp;&#160;</td>
          <td class="paramname"><em>sequence_steps</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get current measurement steps executed in sequence by the device during ranging. </p>
<dl class="section warning"><dt>Warning</dt><dd>Blocking API! </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Mid-level API</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sequence_steps</td><td>a reference to a variable that will receive the sequence steps </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if the operation succeeded </td></tr>
    <tr><td class="paramname">false</td><td>if the operation failed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#a9a7233dd506e05a69fc0f1a1d5aeca9f" title="Set measurement steps to be executed in sequence by the device during ranging.">set_sequence_steps()</a> </dd>
<dd>
<a class="el" href="classdevices_1_1vl53l0x_1_1_sequence_steps.html" title="Hold VL53L0X sequence steps to use for ranging.">SequenceSteps</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="vl53l0x_8h_source.html#l01008">1008</a> of file <a class="el" href="vl53l0x_8h_source.html">vl53l0x.h</a>.</p>

</div>
</div>
<a id="a64f421db9b31125b290be251bec59213"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64f421db9b31125b290be251bec59213">&#9670;&nbsp;</a></span>set_vcsel_pulse_period()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MANAGER &gt; </div>
<div class="memtemplate">
template&lt;VcselPeriodType TYPE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html">devices::vl53l0x::VL53L0X</a>&lt; <a class="el" href="classi2c_1_1_i2_c_device.html#a7b3f6509519292904a636f4262b404ae">MANAGER</a> &gt;::set_vcsel_pulse_period </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>period</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set new pulse period of the VCSEL for pre-range or final-range step. </p>
<p>Pulse period is expressed in PCLK, whatever that really means. Changing pulse periods has an impact on range distance. </p><dl class="section warning"><dt>Warning</dt><dd>Blocking API! </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Mid-level API</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TYPE</td><td>the type of pulse period we want to set (pre-range or final-range) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">period</td><td>the new pulse period to use for <code>TYPE</code> step; for pre-range, possible values are 12, 14, 16, 18; for final-range these are 8, 10, 12, 14. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if the operation succeeded </td></tr>
    <tr><td class="paramname">false</td><td>if the operation failed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#a1e71f8ef585c7cf6948c386c81a168ba" title="Get current pulse period of the VCSEL for pre-range or final-range step.">get_vcsel_pulse_period()</a> </dd>
<dd>
<a class="el" href="namespacedevices_1_1vl53l0x.html#a07eefbde97029a7493093997fd81c57a" title="Type of pulse period configured for VL53L0X device VCSEL (Vertical Cavity Surface Emitting Laser).">VcselPeriodType</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="vl53l0x_8h_source.html#l01033">1033</a> of file <a class="el" href="vl53l0x_8h_source.html">vl53l0x.h</a>.</p>

</div>
</div>
<a id="a1e71f8ef585c7cf6948c386c81a168ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e71f8ef585c7cf6948c386c81a168ba">&#9670;&nbsp;</a></span>get_vcsel_pulse_period()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MANAGER &gt; </div>
<div class="memtemplate">
template&lt;VcselPeriodType TYPE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html">devices::vl53l0x::VL53L0X</a>&lt; <a class="el" href="classi2c_1_1_i2_c_device.html#a7b3f6509519292904a636f4262b404ae">MANAGER</a> &gt;::get_vcsel_pulse_period </td>
          <td>(</td>
          <td class="paramtype">uint8_t &amp;&#160;</td>
          <td class="paramname"><em>period</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get current pulse period of the VCSEL for pre-range or final-range step. </p>
<p>Pulse period is expressed in PCLK, whatever that really means. </p><dl class="section warning"><dt>Warning</dt><dd>Blocking API! </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Mid-level API</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TYPE</td><td>the type of pulse period we want to read </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">period</td><td>a reference to a variable that will receive the pulse period </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if the operation succeeded </td></tr>
    <tr><td class="paramname">false</td><td>if the operation failed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#a64f421db9b31125b290be251bec59213" title="Set new pulse period of the VCSEL for pre-range or final-range step.">set_vcsel_pulse_period()</a> </dd>
<dd>
<a class="el" href="namespacedevices_1_1vl53l0x.html#a07eefbde97029a7493093997fd81c57a" title="Type of pulse period configured for VL53L0X device VCSEL (Vertical Cavity Surface Emitting Laser).">VcselPeriodType</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="vl53l0x_8h_source.html#l01054">1054</a> of file <a class="el" href="vl53l0x_8h_source.html">vl53l0x.h</a>.</p>

</div>
</div>
<a id="a97febebb693ab16c48bd8d4b23b22fa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97febebb693ab16c48bd8d4b23b22fa5">&#9670;&nbsp;</a></span>set_signal_rate_limit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MANAGER &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html">devices::vl53l0x::VL53L0X</a>&lt; <a class="el" href="classi2c_1_1_i2_c_device.html#a7b3f6509519292904a636f4262b404ae">MANAGER</a> &gt;::set_signal_rate_limit </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>signal_rate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set new signal rate limit for ranging. </p>
<p>This is a ratio between 0.0 and 1.0; lower values will allow ranging in long distance or in a noisy environment; default is normally 0.25. </p><dl class="section warning"><dt>Warning</dt><dd>Blocking API! </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Mid-level API</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">signal_rate</td><td>the new signal rate limit to use for ranging; must be between 0.0 and 1.0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if the operation succeeded </td></tr>
    <tr><td class="paramname">false</td><td>if the operation failed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#a63a44d590069e079e0515ee9945cb46f" title="Get current signal rate limit for ranging.">get_signal_rate_limit()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="vl53l0x_8h_source.html#l01077">1077</a> of file <a class="el" href="vl53l0x_8h_source.html">vl53l0x.h</a>.</p>

</div>
</div>
<a id="a63a44d590069e079e0515ee9945cb46f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63a44d590069e079e0515ee9945cb46f">&#9670;&nbsp;</a></span>get_signal_rate_limit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MANAGER &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html">devices::vl53l0x::VL53L0X</a>&lt; <a class="el" href="classi2c_1_1_i2_c_device.html#a7b3f6509519292904a636f4262b404ae">MANAGER</a> &gt;::get_signal_rate_limit </td>
          <td>(</td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>signal_rate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get current signal rate limit for ranging. </p>
<p>This is a ratio between 0.0 and 1.0; lower values will allow ranging in long distance or in a noisy environment; default is normally 0.25. </p><dl class="section warning"><dt>Warning</dt><dd>Blocking API! </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Mid-level API</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">signal_rate</td><td>a reference to a variable that will receive the current signal rate limit</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if the operation succeeded </td></tr>
    <tr><td class="paramname">false</td><td>if the operation failed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#a97febebb693ab16c48bd8d4b23b22fa5" title="Set new signal rate limit for ranging.">set_signal_rate_limit()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="vl53l0x_8h_source.html#l01101">1101</a> of file <a class="el" href="vl53l0x_8h_source.html">vl53l0x.h</a>.</p>

</div>
</div>
<a id="ad674735b78efacd5bcaa67fdd12685cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad674735b78efacd5bcaa67fdd12685cb">&#9670;&nbsp;</a></span>get_power_mode()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MANAGER &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html">devices::vl53l0x::VL53L0X</a>&lt; <a class="el" href="classi2c_1_1_i2_c_device.html#a7b3f6509519292904a636f4262b404ae">MANAGER</a> &gt;::get_power_mode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedevices_1_1vl53l0x.html#a58601e220af84e79fca7689a91748e42">PowerMode</a> &amp;&#160;</td>
          <td class="paramname"><em>power_mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get current power mode of this <a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html" title="I2C device driver for the VL53L0X ToF ranging chip.">VL53L0X</a> register. </p>
<dl class="section warning"><dt>Warning</dt><dd>Blocking API! </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Mid-level API</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">power_mode</td><td>a reference to a variable that will receive the revision </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if the operation succeeded </td></tr>
    <tr><td class="paramname">false</td><td>if the operation failed </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="vl53l0x_8h_source.html#l01120">1120</a> of file <a class="el" href="vl53l0x_8h_source.html">vl53l0x.h</a>.</p>

</div>
</div>
<a id="a8c31eda9d3aa62aa008a2a264a2e4dbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c31eda9d3aa62aa008a2a264a2e4dbf">&#9670;&nbsp;</a></span>get_model()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MANAGER &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html">devices::vl53l0x::VL53L0X</a>&lt; <a class="el" href="classi2c_1_1_i2_c_device.html#a7b3f6509519292904a636f4262b404ae">MANAGER</a> &gt;::get_model </td>
          <td>(</td>
          <td class="paramtype">uint8_t &amp;&#160;</td>
          <td class="paramname"><em>model</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get model of this <a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html" title="I2C device driver for the VL53L0X ToF ranging chip.">VL53L0X</a> register. </p>
<p>This is normally a constant (<code>0xEE</code>). </p><dl class="section warning"><dt>Warning</dt><dd>Blocking API! </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Mid-level API</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">model</td><td>a reference to a variable that will receive the model </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if the operation succeeded </td></tr>
    <tr><td class="paramname">false</td><td>if the operation failed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#ac2be6b02032886b35c995f04ccb47a10" title="Get revision of this VL53L0X register.">get_revision()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="vl53l0x_8h_source.html#l01137">1137</a> of file <a class="el" href="vl53l0x_8h_source.html">vl53l0x.h</a>.</p>

</div>
</div>
<a id="ac2be6b02032886b35c995f04ccb47a10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2be6b02032886b35c995f04ccb47a10">&#9670;&nbsp;</a></span>get_revision()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MANAGER &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html">devices::vl53l0x::VL53L0X</a>&lt; <a class="el" href="classi2c_1_1_i2_c_device.html#a7b3f6509519292904a636f4262b404ae">MANAGER</a> &gt;::get_revision </td>
          <td>(</td>
          <td class="paramtype">uint8_t &amp;&#160;</td>
          <td class="paramname"><em>revision</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get revision of this <a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html" title="I2C device driver for the VL53L0X ToF ranging chip.">VL53L0X</a> register. </p>
<p>This is normally a constant (<code>0x10</code>). </p><dl class="section warning"><dt>Warning</dt><dd>Blocking API! </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Mid-level API</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">revision</td><td>a reference to a variable that will receive the revision </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if the operation succeeded </td></tr>
    <tr><td class="paramname">false</td><td>if the operation failed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#a8c31eda9d3aa62aa008a2a264a2e4dbf" title="Get model of this VL53L0X register.">get_model()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="vl53l0x_8h_source.html#l01154">1154</a> of file <a class="el" href="vl53l0x_8h_source.html">vl53l0x.h</a>.</p>

</div>
</div>
<a id="a4c1f1421f2e2fb1dd2bcd1c007ab3170"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c1f1421f2e2fb1dd2bcd1c007ab3170">&#9670;&nbsp;</a></span>await_interrupt() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MANAGER &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html">devices::vl53l0x::VL53L0X</a>&lt; <a class="el" href="classi2c_1_1_i2_c_device.html#a7b3f6509519292904a636f4262b404ae">MANAGER</a> &gt;::await_interrupt </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>loops</em> = <code>MAX_LOOP</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wait for an interrupt condition on <a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html" title="I2C device driver for the VL53L0X ToF ranging chip.">VL53L0X</a> device. </p>
<p>Wait is performed based on a maximum number of loops, not on actual time. This is more difficult to use than <code>await_interrupt(<a class="el" href="classtimer_1_1_r_t_t.html" title="API to handle a real-time timer.">timer::RTT</a>&lt;TIMER&gt;&amp;, uint16_t)</code> </p><dl class="section warning"><dt>Warning</dt><dd>Blocking API! </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Low-level API! Generally you shall not use this API unless you know what you are doing.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">loops</td><td>the maximum number of waiting loops before timeout; default is 2000, but it may not be suitable in every situation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if the operation succeeded </td></tr>
    <tr><td class="paramname">false</td><td>if the operation failed or timed out</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#abd38fce6e1cfac0c6eca209d818b72ec" title="Wait for an interrupt condition on VL53L0X device.">await_interrupt(timer::RTT&lt;TIMER&gt;&amp;, uint16_t)</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="vl53l0x_8h_source.html#l01176">1176</a> of file <a class="el" href="vl53l0x_8h_source.html">vl53l0x.h</a>.</p>

</div>
</div>
<a id="aa8a6f66bce9f717f4d81077cf1a6b1eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8a6f66bce9f717f4d81077cf1a6b1eb">&#9670;&nbsp;</a></span>await_continuous_range() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MANAGER &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html">devices::vl53l0x::VL53L0X</a>&lt; <a class="el" href="classi2c_1_1_i2_c_device.html#a7b3f6509519292904a636f4262b404ae">MANAGER</a> &gt;::await_continuous_range </td>
          <td>(</td>
          <td class="paramtype">uint16_t &amp;&#160;</td>
          <td class="paramname"><em>range_mm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>loops</em> = <code>MAX_LOOP</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wait for the next continuous ranging measure on <a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html" title="I2C device driver for the VL53L0X ToF ranging chip.">VL53L0X</a> device to be ready and return the result. </p>
<p>This shall be used only when continuous ranging is in effect. Wait is performed based on a maximum number of loops, not on actual time. This is more difficult to use than <code>await_continuous_range(<a class="el" href="classtimer_1_1_r_t_t.html" title="API to handle a real-time timer.">timer::RTT</a>&lt;TIMER&gt;&amp;, uint16_t&amp;, uint16_t)</code> </p><dl class="section warning"><dt>Warning</dt><dd>Blocking API! </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Low-level API! Generally you shall not use this API unless you know what you are doing.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">range_mm</td><td>a reference to a variable that will receive the measurement result (in mm) </td></tr>
    <tr><td class="paramname">loops</td><td>the maximum number of waiting loops before timeout; default is 2000, but it may not be suitable in every situation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if the operation succeeded </td></tr>
    <tr><td class="paramname">false</td><td>if the operation failed or timed out</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#ab2f73ffeafc9aea3196af584ed39d49f" title="Start continuous ranging on this VL53L0X device.">start_continuous_ranging()</a> </dd>
<dd>
<a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#a82e29546fa72e9d961c02cae43227004" title="Set new &quot;measurement timing budget&quot; for this device.">set_measurement_timing_budget()</a> </dd>
<dd>
<a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#aa483218a8665973bf86c444f9617539d" title="Wait for the next continuous ranging measure on VL53L0X device to be ready and return the result.">await_continuous_range(timer::RTT&lt;TIMER&gt;&amp;, uint16_t&amp;, uint16_t)</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="vl53l0x_8h_source.html#l01211">1211</a> of file <a class="el" href="vl53l0x_8h_source.html">vl53l0x.h</a>.</p>

</div>
</div>
<a id="aae960c2e625f7eac7dcceed8ed440d71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae960c2e625f7eac7dcceed8ed440d71">&#9670;&nbsp;</a></span>await_single_range() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MANAGER &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html">devices::vl53l0x::VL53L0X</a>&lt; <a class="el" href="classi2c_1_1_i2_c_device.html#a7b3f6509519292904a636f4262b404ae">MANAGER</a> &gt;::await_single_range </td>
          <td>(</td>
          <td class="paramtype">uint16_t &amp;&#160;</td>
          <td class="paramname"><em>range_mm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>loops</em> = <code>MAX_LOOP</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform a single range action on <a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html" title="I2C device driver for the VL53L0X ToF ranging chip.">VL53L0X</a> device, and wait for the measurement result. </p>
<p>This shall be used when no continuous ranging is in effect. Wait is performed based on a maximum number of loops, not on actual time. This is more difficult to use than <code>await_single_range(<a class="el" href="classtimer_1_1_r_t_t.html" title="API to handle a real-time timer.">timer::RTT</a>&lt;TIMER&gt;&amp;, uint16_t&amp;, uint16_t)</code> </p><dl class="section warning"><dt>Warning</dt><dd>Blocking API! </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Low-level API! Generally you shall not use this API unless you know what you are doing.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">range_mm</td><td>a reference to a variable that will receive the measurement result (in mm) </td></tr>
    <tr><td class="paramname">loops</td><td>the maximum number of waiting loops before timeout; default is 2000, but it may not be suitable in every situation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if the operation succeeded </td></tr>
    <tr><td class="paramname">false</td><td>if the operation failed or timed out</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#ac4f4e6608fff114b29b5fc2a0239d66f" title="Perform a single range action on VL53L0X device, and wait for the measurement result.">await_single_range(timer::RTT&lt;TIMER&gt;&amp;, uint16_t&amp;, uint16_t)</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="vl53l0x_8h_source.html#l01238">1238</a> of file <a class="el" href="vl53l0x_8h_source.html">vl53l0x.h</a>.</p>

</div>
</div>
<a id="ab3a85d18f4030443abf45a6a6579af84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3a85d18f4030443abf45a6a6579af84">&#9670;&nbsp;</a></span>get_reference_SPADs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MANAGER &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html">devices::vl53l0x::VL53L0X</a>&lt; <a class="el" href="classi2c_1_1_i2_c_device.html#a7b3f6509519292904a636f4262b404ae">MANAGER</a> &gt;::get_reference_SPADs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdevices_1_1vl53l0x_1_1_s_p_a_d_reference.html">SPADReference</a> &amp;&#160;</td>
          <td class="paramname"><em>spad_ref</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the reference SPADs status (enabled or not). </p>
<dl class="section warning"><dt>Warning</dt><dd>Blocking API! </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Low-level API! Generally you shall not use this API unless you know what you are doing.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spad_ref</td><td>a reference to a variable that will receive the current reference SPADs status </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if the operation succeeded </td></tr>
    <tr><td class="paramname">false</td><td>if the operation failed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#ad67dcabc700a4e74d9104ec4b23f8ae2" title="Set the reference SPADs status (enabled or not).">set_reference_SPADs()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="vl53l0x_8h_source.html#l01268">1268</a> of file <a class="el" href="vl53l0x_8h_source.html">vl53l0x.h</a>.</p>

</div>
</div>
<a id="ad67dcabc700a4e74d9104ec4b23f8ae2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad67dcabc700a4e74d9104ec4b23f8ae2">&#9670;&nbsp;</a></span>set_reference_SPADs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MANAGER &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html">devices::vl53l0x::VL53L0X</a>&lt; <a class="el" href="classi2c_1_1_i2_c_device.html#a7b3f6509519292904a636f4262b404ae">MANAGER</a> &gt;::set_reference_SPADs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdevices_1_1vl53l0x_1_1_s_p_a_d_reference.html">SPADReference</a> &amp;&#160;</td>
          <td class="paramname"><em>spad_ref</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the reference SPADs status (enabled or not). </p>
<dl class="section warning"><dt>Warning</dt><dd>Blocking API! </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Low-level API! Generally you shall not use this API unless you know what you are doing.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spad_ref</td><td>the new reference SPADs status to set </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if the operation succeeded </td></tr>
    <tr><td class="paramname">false</td><td>if the operation failed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#ad67dcabc700a4e74d9104ec4b23f8ae2" title="Set the reference SPADs status (enabled or not).">set_reference_SPADs()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="vl53l0x_8h_source.html#l01287">1287</a> of file <a class="el" href="vl53l0x_8h_source.html">vl53l0x.h</a>.</p>

</div>
</div>
<a id="a2a6665b0898f48a2acab22ed05f33623"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a6665b0898f48a2acab22ed05f33623">&#9670;&nbsp;</a></span>get_SPAD_info()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MANAGER &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html">devices::vl53l0x::VL53L0X</a>&lt; <a class="el" href="classi2c_1_1_i2_c_device.html#a7b3f6509519292904a636f4262b404ae">MANAGER</a> &gt;::get_SPAD_info </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdevices_1_1vl53l0x_1_1_s_p_a_d_info.html">SPADInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get current SPAD information (number of SPAD aperture or not). </p>
<dl class="section warning"><dt>Warning</dt><dd>Blocking API! </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Low-level API! Generally you shall not use this API unless you know what you are doing.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">info</td><td>a reference to a variable that will receive the current reference SPAD information </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if the operation succeeded </td></tr>
    <tr><td class="paramname">false</td><td>if the operation failed </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="vl53l0x_8h_source.html#l01308">1308</a> of file <a class="el" href="vl53l0x_8h_source.html">vl53l0x.h</a>.</p>

</div>
</div>
<a id="a69032578b37777488b3f7adbfc21ce39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69032578b37777488b3f7adbfc21ce39">&#9670;&nbsp;</a></span>get_sequence_steps_timeout()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MANAGER &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html">devices::vl53l0x::VL53L0X</a>&lt; <a class="el" href="classi2c_1_1_i2_c_device.html#a7b3f6509519292904a636f4262b404ae">MANAGER</a> &gt;::get_sequence_steps_timeout </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdevices_1_1vl53l0x_1_1_sequence_steps_timeout.html">SequenceStepsTimeout</a> &amp;&#160;</td>
          <td class="paramname"><em>timeouts</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get current timeouts associated to each ranging step. </p>
<dl class="section warning"><dt>Warning</dt><dd>Blocking API! </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Low-level API! Generally you shall not use this API unless you know what you are doing.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeouts</td><td>a reference to a variable that will receive the current timeouts associated to ranging steps </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if the operation succeeded </td></tr>
    <tr><td class="paramname">false</td><td>if the operation failed </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="vl53l0x_8h_source.html#l01351">1351</a> of file <a class="el" href="vl53l0x_8h_source.html">vl53l0x.h</a>.</p>

</div>
</div>
<a id="a1ae58ef194127eb2b6b07f8697a33dcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ae58ef194127eb2b6b07f8697a33dcf">&#9670;&nbsp;</a></span>get_register() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MANAGER &gt; </div>
<div class="memtemplate">
template&lt;Register REGISTER, typename T  = uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html">devices::vl53l0x::VL53L0X</a>&lt; <a class="el" href="classi2c_1_1_i2_c_device.html#a7b3f6509519292904a636f4262b404ae">MANAGER</a> &gt;::get_register </td>
          <td>(</td>
          <td class="paramtype">PROXY&lt; <a class="el" href="classi2c_1_1_t_read_register_future.html">TReadRegisterFuture</a>&lt; REGISTER, T &gt;&gt;&#160;</td>
          <td class="paramname"><em>future</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Directly get value of a <a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html" title="I2C device driver for the VL53L0X ToF ranging chip.">VL53L0X</a> register. </p>
<dl class="section warning"><dt>Warning</dt><dd>Asynchronous API! </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Low-level API! Generally you shall not use this API unless you know what you are doing.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REGISTER</td><td>the register to read from VL53l)X device </td></tr>
    <tr><td class="paramname">T</td><td>the type of value stored in <code>REGISTER</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">future</td><td>a Future passed by the caller, that will be updated once the current I2C action is finished. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>if no problem occurred during the preparation of I2C transaction </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an error code if something bad happened; for an asynchronous I2C Manager, this typically happens when its queue of I2CCommand is full; for a synchronous I2C Manager, any error on the I2C bus or on the target device will trigger an error here. the list of possible errors</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#ad4e60db7f7cb22bf3ef80f2de40d4df4" title="Directly set value of a VL53L0X register.">set_register()</a> </dd>
<dd>
<a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#a604974b689a68b320bc75b60bb28809a" title="Directly get value of a VL53L0X register.">get_register(T&amp; value)</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="vl53l0x_8h_source.html#l01396">1396</a> of file <a class="el" href="vl53l0x_8h_source.html">vl53l0x.h</a>.</p>

</div>
</div>
<a id="ad4e60db7f7cb22bf3ef80f2de40d4df4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4e60db7f7cb22bf3ef80f2de40d4df4">&#9670;&nbsp;</a></span>set_register() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MANAGER &gt; </div>
<div class="memtemplate">
template&lt;Register REGISTER, typename T  = uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html">devices::vl53l0x::VL53L0X</a>&lt; <a class="el" href="classi2c_1_1_i2_c_device.html#a7b3f6509519292904a636f4262b404ae">MANAGER</a> &gt;::set_register </td>
          <td>(</td>
          <td class="paramtype">PROXY&lt; <a class="el" href="classi2c_1_1_t_write_register_future.html">TWriteRegisterFuture</a>&lt; REGISTER, T &gt;&gt;&#160;</td>
          <td class="paramname"><em>future</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Directly set value of a <a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html" title="I2C device driver for the VL53L0X ToF ranging chip.">VL53L0X</a> register. </p>
<dl class="section warning"><dt>Warning</dt><dd>Asynchronous API! </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Low-level API! Generally you shall not use this API unless you know what you are doing.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REGISTER</td><td>the register to write to VL53l)X device </td></tr>
    <tr><td class="paramname">T</td><td>the type of value stored in <code>REGISTER</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">future</td><td>a Future passed by the caller, that will be updated once the current I2C action is finished. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>if no problem occurred during the preparation of I2C transaction </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an error code if something bad happened; for an asynchronous I2C Manager, this typically happens when its queue of I2CCommand is full; for a synchronous I2C Manager, any error on the I2C bus or on the target device will trigger an error here. the list of possible errors</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#a1ae58ef194127eb2b6b07f8697a33dcf" title="Directly get value of a VL53L0X register.">get_register()</a> </dd>
<dd>
<a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#a53fd655f7491296b662d06b56ba53776" title="Directly set value of a VL53L0X register.">set_register(T value)</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="vl53l0x_8h_source.html#l01422">1422</a> of file <a class="el" href="vl53l0x_8h_source.html">vl53l0x.h</a>.</p>

</div>
</div>
<a id="a604974b689a68b320bc75b60bb28809a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a604974b689a68b320bc75b60bb28809a">&#9670;&nbsp;</a></span>get_register() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MANAGER &gt; </div>
<div class="memtemplate">
template&lt;Register REGISTER, typename T  = uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html">devices::vl53l0x::VL53L0X</a>&lt; <a class="el" href="classi2c_1_1_i2_c_device.html#a7b3f6509519292904a636f4262b404ae">MANAGER</a> &gt;::get_register </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Directly get value of a <a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html" title="I2C device driver for the VL53L0X ToF ranging chip.">VL53L0X</a> register. </p>
<dl class="section warning"><dt>Warning</dt><dd>Blocking API! </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Low-level API! Generally you shall not use this API unless you know what you are doing.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REGISTER</td><td>the register to read from VL53l)X device </td></tr>
    <tr><td class="paramname">T</td><td>the type of value stored in <code>REGISTER</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>a reference to a variable of type <code>T</code>, that will receive the value in register <code>REGISTER</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if the operation succeeded </td></tr>
    <tr><td class="paramname">false</td><td>if the operation failed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#a53fd655f7491296b662d06b56ba53776" title="Directly set value of a VL53L0X register.">set_register(T)</a> </dd>
<dd>
<a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#a1ae58ef194127eb2b6b07f8697a33dcf" title="Directly get value of a VL53L0X register.">get_register()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="vl53l0x_8h_source.html#l01445">1445</a> of file <a class="el" href="vl53l0x_8h_source.html">vl53l0x.h</a>.</p>

</div>
</div>
<a id="a53fd655f7491296b662d06b56ba53776"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53fd655f7491296b662d06b56ba53776">&#9670;&nbsp;</a></span>set_register() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MANAGER &gt; </div>
<div class="memtemplate">
template&lt;Register REGISTER, typename T  = uint8_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html">devices::vl53l0x::VL53L0X</a>&lt; <a class="el" href="classi2c_1_1_i2_c_device.html#a7b3f6509519292904a636f4262b404ae">MANAGER</a> &gt;::set_register </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Directly set value of a <a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html" title="I2C device driver for the VL53L0X ToF ranging chip.">VL53L0X</a> register. </p>
<dl class="section warning"><dt>Warning</dt><dd>Blocking API! </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Low-level API! Generally you shall not use this API unless you know what you are doing.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">REGISTER</td><td>the register to write to VL53l)X device </td></tr>
    <tr><td class="paramname">T</td><td>the type of value stored in <code>REGISTER</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>a value of type <code>T</code> that will be written to register <code>REGISTER</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if the operation succeeded </td></tr>
    <tr><td class="paramname">false</td><td>if the operation failed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#a604974b689a68b320bc75b60bb28809a" title="Directly get value of a VL53L0X register.">get_register(T&amp; value)</a> </dd>
<dd>
<a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html#ad4e60db7f7cb22bf3ef80f2de40d4df4" title="Directly set value of a VL53L0X register.">set_register()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="vl53l0x_8h_source.html#l01468">1468</a> of file <a class="el" href="vl53l0x_8h_source.html">vl53l0x.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>fastarduino/devices/<a class="el" href="vl53l0x_8h_source.html">vl53l0x.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacedevices.html">devices</a></li><li class="navelem"><a class="el" href="namespacedevices_1_1vl53l0x.html">vl53l0x</a></li><li class="navelem"><a class="el" href="classdevices_1_1vl53l0x_1_1_v_l53_l0_x.html">VL53L0X</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
