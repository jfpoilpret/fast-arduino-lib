<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>FastArduino: FastArduino API Tutorial</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">FastArduino
   </div>
   <div id="projectbrief">C++ library to build fast but small Arduino/AVR projects</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('tutorial.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">FastArduino API Tutorial </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md__home_jfpoilpret_electronics_fast-arduino-lib_dox_tutorial"></a></p>
<p>This is FastArduino API step-by-step tutorial.</p>
<p>Only the API is covered here: creating and building a project is not described here, you are supposed to know how to do it already.</p>
<p>Using FastArduino API can be learnt step by step in the preferred following order:</p>
<p>Basics:</p><ol type="1">
<li><a class="el" href="tutorial.html#gpiotime">gpio &amp; time</a></li>
<li><a class="el" href="tutorial.html#uartflash">UART &amp; flash</a></li>
<li><a class="el" href="tutorial.html#analoginput">analog input</a></li>
<li><a class="el" href="tutorial.html#timer">timer</a></li>
<li><a class="el" href="tutorial.html#rtt">real-time timer</a></li>
<li><a class="el" href="tutorial.html#pwm">PWM</a></li>
<li><a class="el" href="tutorial.html#utils">utilities</a></li>
</ol>
<p>Advanced:</p><ol type="1">
<li><a class="el" href="tutorial.html#watchdog">watchdog</a></li>
<li><a class="el" href="tutorial.html#interrupts">interrupts</a></li>
<li><a class="el" href="tutorial.html#events">events, scheduler</a></li>
<li><a class="el" href="tutorial.html#power">power</a></li>
<li><a class="el" href="tutorial.html#eeprom">EEPROM</a></li>
<li><a class="el" href="tutorial.html#spi">SPI devices example</a></li>
<li><a class="el" href="tutorial.html#i2c">I2C devices example</a></li>
<li><a class="el" href="tutorial.html#softuart">software UART</a></li>
</ol>
<p>Supported devices (not yet documented):</p><ol type="1">
<li>SPI</li>
<li>I2C</li>
<li>Other devices: sonar, servo, SIPO</li>
</ol>
<h1><a class="anchor" id="gpiotime"></a>Basics: gpio &amp; time </h1>
<h2>Blink example</h2>
<p>Here is a first example of a FastArduino based program:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="preprocessor">#include &lt;<a class="code" href="gpio_8h.html">fastarduino/gpio.h</a>&gt;</span></div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;<span class="preprocessor">#include &lt;<a class="code" href="time_8h.html">fastarduino/time.h</a>&gt;</span></div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160; </div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;<span class="keywordtype">int</span> main()</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;{</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;    <a class="code" href="namespaceboard.html#a2529f85498783a75dc75c281e0b754d3">board::init</a>();</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    sei();</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160; </div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;    <a class="code" href="namespacegpio.html#a3cbdad86ced6494ca615a425b433fd57">gpio::FAST_PIN&lt;board::DigitalPin::LED&gt;</a> led{<a class="code" href="namespacegpio.html#ae18fafd08668ee17aa5dd415ee3b6041a50a87f0d71f7221582dad4bf507a0f34">gpio::PinMode::OUTPUT</a>};</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;    <span class="keywordflow">while</span> (<span class="keyword">true</span>)</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;    {</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;        led.toggle();</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;        <a class="code" href="namespacetime.html#af13fd17ddf6b751b8161691e608892b2">time::delay_ms</a>(500);</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;    }</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;    <span class="keywordflow">return</span> 0;</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;}</div>
</div><!-- fragment --><p>This example can be broken down into several parts:  </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="gpio_8h.html">fastarduino/gpio.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="time_8h.html">fastarduino/time.h</a>&gt;</span></div>
</div><!-- fragment --><p> This includes the necessary API from FastArduino; in this example, we just use <code><a class="el" href="gpio_8h.html" title="General Purpose (digital) Input Output API.">gpio.h</a></code> (all API for digital input/output) and <code><a class="el" href="time_8h.html" title="Simple time utilities.">time.h</a></code> (API for busy loop delays).</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="namespaceboard.html#a2529f85498783a75dc75c281e0b754d3">board::init</a>();</div>
<div class="line">    sei();</div>
</div><!-- fragment --><p> The next part defines the standard <code>main()</code> function as the entry point of the program; first actions in the <code>main()</code> should always be to call <code><a class="el" href="namespaceboard.html#a2529f85498783a75dc75c281e0b754d3" title="Performs special initialization for the target MCU.">board::init()</a></code> (important initialization for some specific boards), then sooner or later call <code>sei()</code> to enable interrupts again, as interrupts are disabled when <code>main()</code> is initially called.</p>
<div class="fragment"><div class="line">    <a class="code" href="namespacegpio.html#a3cbdad86ced6494ca615a425b433fd57">gpio::FAST_PIN&lt;board::DigitalPin::LED&gt;</a> led{<a class="code" href="namespacegpio.html#ae18fafd08668ee17aa5dd415ee3b6041a50a87f0d71f7221582dad4bf507a0f34">gpio::PinMode::OUTPUT</a>};</div>
</div><!-- fragment --><p> This line declares and initializes a digital pin variable named <code>led</code> as output for the board's LED (i.e. <code>D13</code> on Arduino boards).</p>
<p><code><a class="el" href="namespaceboard.html#a5082846fef8fdfb8c8cbcf1163c7b404" title="Defines all available digital input/output pins of the target MCU.">board::DigitalPin</a></code> is a strong enum class that defines all digital pins <b>for the current target</b>, that target must be defined in the compiler command-line.</p>
<p>The actual type of <code>led</code> is <code><a class="el" href="classgpio_1_1_fast_pin.html" title="API that manipulates one digital IO pin of a given port.">gpio::FastPin</a>&lt;<a class="el" href="namespaceboard.html#a151323e5de5adf93f6bcdfdd64fa1eb1" title="Defines all available ports of the target MCU.">board::Port</a>:PORT_B, 5&gt;</code> which means "the pin number 5 within port B"; since this type is not easy to declare when you only know the number of the pin you need, <code><a class="el" href="namespacegpio.html#a3cbdad86ced6494ca615a425b433fd57" title="Useful alias type to the FastPin type matching a given board::DigitalPin.">gpio::FAST_PIN</a>&lt;board::DigitalPin::LED&gt;</code> is used instead, as this useful template alias maps directly to the right type.</p>
<p><code>led</code> is initialized as an output pin, its initial level is <code>false</code> (i.e. GND) by default.</p>
<div class="fragment"><div class="line">    <span class="keywordflow">while</span> (<span class="keyword">true</span>)</div>
<div class="line">    {</div>
<div class="line">        led.toggle();</div>
<div class="line">        <a class="code" href="namespacetime.html#af13fd17ddf6b751b8161691e608892b2">time::delay_ms</a>(500);</div>
<div class="line">    }</div>
</div><!-- fragment --><p> Then the program enters an endless loop in which, at every iteration:</p>
<ol type="1">
<li>It toggles the level of <code>led</code> pin (D13 on Arduino) from GND to Vcc or from Vcc to GND</li>
<li>It delays execution (i.e. it "waits") for 500 milliseconds</li>
</ol>
<p>This part of the program simply makes your Arduino LED blink at 1Hz frequency!</p>
<p>The last part below is never executed (because of the endless loop above) but is necessary to make the compiler happy, as <code>main()</code> shall return a value: </p><div class="fragment"><div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Congratulation! We have just studied the typical "blink" program.</p>
<p>At this point, it is interesting to compare our first program with the equivalent with standard Arduino API:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;void setup()</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;{</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    pinMode(LED_BUILTIN, OUTPUT);</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;}</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160; </div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;void loop()</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;{</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;    digitalWrite(LED_BUILTIN, HIGH);</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;    delay(500);</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;    digitalWrite(LED_BUILTIN, LOW);</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;    delay(500);</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;}</div>
</div><!-- fragment --><p>Granted that the latter code seems simpler to write! However, it is also simpler to write it wrong, build and upload it to Arduino and only see it not working:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;#define LED 53</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160; </div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;void setup()</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;{</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    pinMode(LED, OUTPUT);</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;}</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160; </div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;void loop()</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;{</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;    digitalWrite(LED, HIGH);</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;    delay(500);</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;    digitalWrite(LED, LOW);</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;    delay(500);</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;}</div>
</div><!-- fragment --><p>The problem here is that Arduino API accept a simple number when they need a pin, hence it is perfectly possible to pass them the number of a pin that does not exist, as in the faulty code above: this code will compile and upload properly to an Arduino UNO, however it will not work, because pin 53 does not exist!</p>
<p>This problem cannot occur with FastArduino as the available pins are stored in a strong enum and it becomes impossible to select a pin that does not exist for the board we target!</p>
<p>Now, what is really interesting in comparing both working code examples is the size of the built program (measured with UNO as a target, FastArduino project built with AVR GCC 9.2.0, Arduino API project built with Arduino CLI 0.7.0):</p>
<p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"></th><th class="markdownTableHeadNone">Arduino API </th><th class="markdownTableHeadNone">FastArduino  </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">code size </td><td class="markdownTableBodyNone">928 bytes </td><td class="markdownTableBodyNone">154 bytes  </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">data size </td><td class="markdownTableBodyNone">9 bytes </td><td class="markdownTableBodyNone">0 byte  </td></tr>
</table>
 As you probably know, Atmel AVR MCU (and Arduino boards that embed them) are much constrained in code and data size, hence we could say that "every byte counts". In the table ablove, one easily sees that Arduino API comes cluttered with lots of code and data, even if you don't need it; on the other hand, FastArduino is highly optimized and will produce code only for what you <b>do</b> use.</p>
<h2>LED Chaser example</h2>
<p>Now <code><a class="el" href="gpio_8h.html" title="General Purpose (digital) Input Output API.">gpio.h</a></code> has more API than just <code><a class="el" href="classgpio_1_1_fast_pin.html" title="API that manipulates one digital IO pin of a given port.">gpio::FastPin</a></code> and <code><a class="el" href="classgpio_1_1_fast_pin_type.html" title="API that manipulates a given digital IO pin of a the target MCU.">gpio::FastPinType</a></code>; it also includes <code><a class="el" href="classgpio_1_1_fast_port.html" title="API that manipulates a whole digital IO port.">gpio::FastPort</a></code> and <code><a class="el" href="classgpio_1_1_fast_masked_port.html" title="API that manipulates a part of a digital IO port.">gpio::FastMaskedPort</a></code> that allow to manipulate several pins at a time, as long as these pis belong to the same Port of the MCU. This allows size and speed optimizations when having to deal with a group of related pins, e.g. if you want to implement a LED chaser project.</p>
<p>With FastArduino, here is a program showing how you could implement a simple 8 LED chaser on UNO:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="preprocessor">#include &lt;<a class="code" href="gpio_8h.html">fastarduino/gpio.h</a>&gt;</span></div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;<span class="preprocessor">#include &lt;<a class="code" href="time_8h.html">fastarduino/time.h</a>&gt;</span></div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160; </div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;<span class="keywordtype">int</span> main()</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;{</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;    <a class="code" href="namespaceboard.html#a2529f85498783a75dc75c281e0b754d3">board::init</a>();</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    sei();</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160; </div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;    <a class="code" href="classgpio_1_1_fast_port.html">gpio::FastPort&lt;board::Port::PORT_D&gt;</a> leds{0xFF, 0x00};</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;    uint8_t pattern = 0x01;</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;    <span class="keywordflow">while</span> (<span class="keyword">true</span>)</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;    {</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;        leds.<a class="code" href="classgpio_1_1_fast_port.html#a910c81c3668585199f4d1dbd669438a8">set_PORT</a>(pattern);</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;        <a class="code" href="namespacetime.html#af13fd17ddf6b751b8161691e608892b2">time::delay_ms</a>(250);</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;        pattern &lt;&lt;= 1;</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;        <span class="keywordflow">if</span> (!pattern) pattern = 0x01;</div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;    }</div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;    <span class="keywordflow">return</span> 0;</div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;}</div>
</div><!-- fragment --><p>In this example, we selected all pins of the same port to connect the 8 LEDs of our chaser. Concretely on UNO, this is port D, which pins are D0-D7.</p>
<p>We thus declare and initialize <code>leds</code> as a <code><a class="el" href="classgpio_1_1_fast_port.html" title="API that manipulates a whole digital IO port.">gpio::FastPort</a>&lt;board::Port::PORT_D&gt;</code> port, with all pins as output (<code>0xFF</code>), with initial level to GND (<code>0x00</code>, all LEDs off).</p>
<p>Then, we will keep track of the current lit LED through <code>pattern</code> byte which each bit represents actually one LED; <code>pattern</code> is initialized with <code>0x01</code> i.e. D0 should be the first LED to be ON.</p>
<p>In the endless loop that follows, we perform the following actions:</p>
<ol type="1">
<li>Set all pins values at once to the current value of <code>pattern</code></li>
<li>Delay execution for 250ms</li>
<li>Shift the only 1 bit of <code>pattern</code> left; note that after 8 shifts, <code>pattern</code> will become <code>0</code>, hence we need to check against this condition to reset <code>pattern</code> to its initial state.</li>
</ol>
<p>This should be rather straightforward to understand if you know C or C++.</p>
<p>Here is an equivalent example with Arduino API:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;const byte LED_PINS[] = {0, 1, 2, 3, 4, 5, 6, 7};</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;const byte NUM_LEDS =  sizeof(LED_PINS) / sizeof(LED_PINS[0]);</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160; </div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;void setup()</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;{</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;    for(byte i = 0; i &lt; NUM_LEDS; i++)</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;        pinMode(LED_PINS[i], OUTPUT);</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;}</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160; </div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;void loop()</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;{</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;    for(byte i = 0; i &lt; NUM_LEDS; i++)</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;    {</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;        digitalWrite(LED_PINS[i], HIGH);</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;        delay(250);</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;        digitalWrite(LED_PINS[i], LOW);</div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;    }</div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;}</div>
</div><!-- fragment --><p>We see, with Arduino API, that we have to deal with each pin individually, which makes the program source code longer and not necessarily easier to understand.</p>
<p>Here is a quick comparison of the sizes for both programs:</p>
<p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"></th><th class="markdownTableHeadNone">Arduino API </th><th class="markdownTableHeadNone">FastArduino  </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">code size </td><td class="markdownTableBodyNone">968 bytes </td><td class="markdownTableBodyNone">168 bytes  </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">data size </td><td class="markdownTableBodyNone">17 bytes </td><td class="markdownTableBodyNone">0 byte  </td></tr>
</table>
</p>
<h1><a class="anchor" id="uartflash"></a>Basics: UART &amp; flash </h1>
<h2>Simple Serial Output example</h2>
<p>Although not often necessary in many finished programs, <code>UART</code> (for serial communication interface) is often very useful for debugging a program while it is being developed; this is why <code>UART</code> is presented now.</p>
<p>Here is a first simple program showing how to display, with FastArduino API, a simple string to the serial output (for UNO, this is connected to USB):</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="preprocessor">#include &lt;<a class="code" href="uart_8h.html">fastarduino/uart.h</a>&gt;</span></div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160; </div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;<span class="keyword">static</span> constexpr <span class="keyword">const</span> uint8_t OUTPUT_BUFFER_SIZE = 64;</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;<span class="keyword">static</span> <span class="keywordtype">char</span> output_buffer[OUTPUT_BUFFER_SIZE];</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160; </div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;<a class="code" href="uart_8h.html#aa33c57bb6fa1e93177abb21fe8fecb10">REGISTER_UATX_ISR</a>(0)</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160; </div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;int main() __attribute__((OS_main));</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;<span class="keywordtype">int</span> main()</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;{</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;    <a class="code" href="namespaceboard.html#a2529f85498783a75dc75c281e0b754d3">board::init</a>();</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;    sei();</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;    </div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;    <a class="code" href="classserial_1_1hard_1_1_u_a_t_x.html">serial::hard::UATX&lt;board::USART::USART0&gt;</a> uart{output_buffer};</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;    uart.<a class="code" href="classserial_1_1hard_1_1_u_a_t_x.html#a64b04d0617b28fd343a01f865dee787e">begin</a>(115200);</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160; </div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;    <a class="code" href="classstreams_1_1ostream.html">streams::ostream</a> out = uart.out();</div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;    out.<a class="code" href="classstreams_1_1ostream.html#a001a2dd6c215d77e06492376bf791870">write</a>(<span class="stringliteral">&quot;Hello, World!\n&quot;</span>);</div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;    out.<a class="code" href="classstreams_1_1ostream.html#a00f6c7bdce1520b119c31cd7dde80ac2">flush</a>();</div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;    <span class="keywordflow">return</span> 0;</div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;}</div>
</div><!-- fragment --><p>As usual, at first we need to include the proper header (<code><a class="el" href="uart_8h.html" title="Hardware serial API.">uart.h</a></code>) to use its API.</p>
<p>Then, we define a buffer that will be used by the <code>UART</code> API to transmit characters to your PC through USB. You may find it cumbersome to do it yourself but it brings a huge advantage: you are the one to decide of the buffer size, whereas in Arduino API, you have no choice. Here, we consider 64 bits to be big enough to store characters that will be transmitted to the PC. How <code>UART</code> is using this buffer is not important to you though.</p>
<p>Then we <em>register an ISR</em> necessary for transmissions to take place; this is done by the <code><a class="el" href="uart_8h.html#aa33c57bb6fa1e93177abb21fe8fecb10" title="Register the necessary ISR (Interrupt Service Routine) for an serial::hard::UATX to work correctly.">REGISTER_UATX_ISR(0)</a></code> macro. Explicit ISR registration is one important design choice of FastArduino: <b>you</b> decide which ISR should be registered to do what. This may again seem cumbersome but once again this gives you the benefit to decie what you need, hence build your application the way you want it.</p>
<p>The code that follows instantiates a <code>uart::hard::UATX</code> object that is using <code>board::USART::USART0</code> (the only one available on UNO) and based on the previously created buffer. Note that <code>UATX</code> class is in charge of <b>only</b> transmitting characters, not receiving. Other classes exist for only receiving (<code>UARX</code>), or for doing both (<code>UART</code>).</p>
<p>Once created, we can set <code>uart</code> ready for transmission, at serial speed of 115200 bps.</p>
<p>Next step consists in extracting, from <code>uart</code>, a <code><a class="el" href="classstreams_1_1ostream.html" title="Output stream wrapper to provide formatted output API, a la C++.">streams::ostream</a></code> that will allow us to send characters or strings to USB: </p><pre class="fragment">out.write("Hello, World!\n");
</pre><p>The last important instruction, <code><a class="el" href="namespacestreams.html#a155684415ba442e665f551819429b3a0" title="Manipulator for an output stream, which will flush the stream buffer.">out.flush()</a></code>, waits for all characters to be transmitted before leaving the program.</p>
<p>Do note the specific <code>main</code> declaration line before its definition: <code>int main() __attribute__((OS_main));</code>. This helps the compiler perform some optimization on this function, and may avoid generating several dozens code instructions in some circumstances. In some situations though, this may increase code size by a few bytes; for your own programs, you would have to compile with and without this line if you want to find what is the best for you.</p>
<p>Here is the equivalent code with Arduino API:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;void setup()</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;{</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;  Serial.begin(115200);</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;  Serial.println(&quot;Hello, World!&quot;);</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;}</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160; </div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;void loop()</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;{</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;}</div>
</div><!-- fragment --><p>Of course, we can see here that the code looks simpler, although one may wonder why we need to define a <code>loop()</code> function that does nothing.</p>
<p>Now let's compare the size of both:</p>
<p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"></th><th class="markdownTableHeadNone">Arduino API </th><th class="markdownTableHeadNone">FastArduino  </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">code size </td><td class="markdownTableBodyNone">1480 bytes </td><td class="markdownTableBodyNone">644 bytes  </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">data size </td><td class="markdownTableBodyNone">202 bytes </td><td class="markdownTableBodyNone">82 bytes  </td></tr>
</table>
 The data size is big because the buffer used by <code>Serial</code> has a hard-coded size (you cannot change it without modifying and recompiling Arduino API). Moreover, when using <code>Serial</code>, 2 buffers are created, one for input and one for output, even though you may only need the latter one!</p>
<p>Now let's take a look at the 82 bytes of data used in the FastArduino version of this example, how are they broken down? </p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Source  </th><th class="markdownTableHeadNone">data size   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>output_buffer</code>  </td><td class="markdownTableBodyNone">64 bytes   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>UATX</code> ISR  </td><td class="markdownTableBodyNone">2 bytes   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">"Hello, World!\n"  </td><td class="markdownTableBodyNone">16 bytes   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><b>TOTAL</b>  </td><td class="markdownTableBodyNone">82 bytes   </td></tr>
</table>
<p>As you can see in the table above, the constant string <code>"Hello, World!\n"</code> occupies 16 bytes of data (i.e. AVR SRAM) in addition to 16 bytes of Flash (as it is part of the program and must be stored permanently). If your program deals with a lot of constant strings like this, you may quickly meet a memory problem with SRAM usage. This is why it is more effective to keep these strings exclusively in Flash (you have no choice) but load them to SRAM only when they are needed, i.e. when they get printed to <code>UATX</code> as in the sample code.</p>
<p>How do we change our program so that this string is only stored in Flash? We can use FastArduino <code>flash</code> API for that, by changing only one line of code: </p><pre class="fragment">out.write(F("Hello, World!\n"));
</pre><p>Note the use of <code><a class="el" href="flash_8h.html#a16c40764aaba0de309f5ff429c8bac15" title="Force string constant to be stored as flash storage.">F()</a></code> macro here: this makes the string reside in Flash only, and then it is being read from Flash "on the fly" by <code>out.write()</code> method; the latter method is overloaded for usual C-strings (initial example) and for C-strings stored in Flash only.</p>
<p>We can compare the impact on sizes:</p>
<p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"></th><th class="markdownTableHeadNone">without F() </th><th class="markdownTableHeadNone">with F()  </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">code size </td><td class="markdownTableBodyNone">644 bytes </td><td class="markdownTableBodyNone">630 bytes  </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">data size </td><td class="markdownTableBodyNone">82 bytes </td><td class="markdownTableBodyNone">66 bytes  </td></tr>
</table>
 We can see here that 16 bytes have been removed from data, this is the size of the string constant.</p>
<p>You may wonder why <code>"Hello, World!\n"</code> occupies 16 bytes, although it should use only 15 bytes (if we account for the terminating &lsquo;&rsquo;\0'` character); this is because the string is stored in Flash and Flash is word-addressable, not byte-addressable on AVR.</p>
<p>Note that Flash can also be used to store other read-only data that you may want to access at runtime at specific times, i.e. data you do not want to be stored permanently on SRAM during all execution of your program.</p>
<p>The following example shows how to:</p><ul>
<li>define, in your source code, read-only data that shall be stored in Flash memory</li>
<li>read that data when you need it</li>
</ul>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="preprocessor">#include &lt;<a class="code" href="flash_8h.html">fastarduino/flash.h</a>&gt;</span></div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160; </div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;<span class="comment">// This is the type of data we want to store in flash</span></div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;<span class="keyword">struct </span>Dummy</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;{</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;    uint16_t a;</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    uint8_t b;</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;    <span class="keywordtype">bool</span> c;</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;    int16_t d;</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;    <span class="keywordtype">char</span> e;</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;};</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160; </div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;<span class="comment">// Define 2 variables of that type, which will be stored in flash</span></div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;<span class="comment">// Note the PROGMEM keyword that says the compiler and linker to put this data to flash</span></div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;<span class="keyword">const</span> Dummy sample1 PROGMEM = {54321, 123, <span class="keyword">true</span>, -22222, <span class="charliteral">&#39;z&#39;</span>};</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;<span class="keyword">const</span> Dummy sample2 PROGMEM = {12345, 231, <span class="keyword">false</span>, -11111, <span class="charliteral">&#39;A&#39;</span>};</div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160; </div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;<span class="comment">// The following function needs value of sample1 to be read from flash</span></div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;<span class="keywordtype">void</span> read_and_use_sample1()</div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;{</div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;    <span class="comment">// value will get copied with sample1 read-only content</span></div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;    Dummy value;</div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;    <span class="comment">// request reading sample1 from flash into local variable value</span></div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;    <a class="code" href="namespaceflash.html#a3308e6ce737b046264e113ced6ba610f">flash::read_flash</a>(&amp;sample1, value);</div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;    <span class="comment">// Here we can use value which is {54321, 123, true, -22222, &#39;z&#39;}</span></div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160; </div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;}</div>
</div><!-- fragment --><h2>Formatted Output example</h2>
<p>Compared to Arduino API, FastArduino brings formatted streams as can be <a href="https://en.wikipedia.org/wiki/Input/output_(C%2B%2B)">found in standard C++</a>; although more verbose than usual C <code>printf()</code> function, formatted streams allow compile-time safety.</p>
<p>Here is an example that prints formatted data to USB:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="preprocessor">#include &lt;<a class="code" href="uart_8h.html">fastarduino/uart.h</a>&gt;</span></div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160; </div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;<span class="keyword">static</span> constexpr <span class="keyword">const</span> uint8_t OUTPUT_BUFFER_SIZE = 64;</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;<span class="keyword">static</span> <span class="keywordtype">char</span> output_buffer[OUTPUT_BUFFER_SIZE];</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160; </div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;<a class="code" href="uart_8h.html#aa33c57bb6fa1e93177abb21fe8fecb10">REGISTER_UATX_ISR</a>(0)</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160; </div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;using namespace <a class="code" href="namespacestreams.html">streams</a>;</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160; </div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;<span class="keywordtype">int</span> main()</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;{</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;    <a class="code" href="namespaceboard.html#a2529f85498783a75dc75c281e0b754d3">board::init</a>();</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;    sei();</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;    </div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;    <a class="code" href="classserial_1_1hard_1_1_u_a_t_x.html">serial::hard::UATX&lt;board::USART::USART0&gt;</a> uart{output_buffer};</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;    uart.<a class="code" href="classserial_1_1hard_1_1_u_a_t_x.html#a64b04d0617b28fd343a01f865dee787e">begin</a>(115200);</div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160; </div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;    ostream out = uart.out();</div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;    uint16_t value = 0x8000;</div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;    out &lt;&lt; <a class="code" href="flash_8h.html#a16c40764aaba0de309f5ff429c8bac15">F</a>(<span class="stringliteral">&quot;value = 0x&quot;</span>) &lt;&lt; <a class="code" href="namespacestreams.html#a91675bd61b31e7382e8655930606f62f">hex</a> &lt;&lt; value </div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;        &lt;&lt; <a class="code" href="flash_8h.html#a16c40764aaba0de309f5ff429c8bac15">F</a>(<span class="stringliteral">&quot;, &quot;</span>) &lt;&lt; <a class="code" href="namespacestreams.html#adaf650921b3a5d448f8aac51dba924d2">dec</a> &lt;&lt; value </div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;        &lt;&lt; <a class="code" href="flash_8h.html#a16c40764aaba0de309f5ff429c8bac15">F</a>(<span class="stringliteral">&quot;, 0&quot;</span>) &lt;&lt; <a class="code" href="namespacestreams.html#a9c09ef93f2d071416214cbe8ed0e1710">oct</a> &lt;&lt; value </div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;        &lt;&lt; <a class="code" href="flash_8h.html#a16c40764aaba0de309f5ff429c8bac15">F</a>(<span class="stringliteral">&quot;, B&quot;</span>) &lt;&lt; <a class="code" href="namespacestreams.html#a79c81dc9afb0ca3ce0495fb7a95e85e1">bin</a> &lt;&lt; value &lt;&lt; <a class="code" href="namespacestreams.html#a25bd12279d518b57e4fb97c533c17b22">endl</a>;</div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;    <span class="keywordflow">return</span> 0;</div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;}</div>
</div><!-- fragment --><p>Here, we still use <code>uart.out()</code>, but here we use its "insertion operator" <code>&lt;&lt;</code>.</p>
<p>If you are used to programming with C++ for more usual systems (e.g. Linux), then you will immediately recognize <a href="http://www.cplusplus.com/reference/ostream/ostream/operator%3C%3C/"><code>std::ostream</code> API</a> which FastArduino library tries to implement with some level of fidelity.</p>
<p>You can also find more details in <code>streams</code> namespace documentation.</p>
<p>Here is the equivalent code with Arduino API:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;void setup()</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;{</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    Serial.begin(115200);</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    unsigned int value = 0x8000;</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    Serial.print(F(&quot;value = 0x&quot;));</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;    Serial.print(value, 16);</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    Serial.print(F(&quot;, &quot;));</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;    Serial.print(value);</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;    Serial.print(F(&quot;, 0&quot;));</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;    Serial.print(value, 8);</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;    Serial.print(F(&quot;, B&quot;));</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;    Serial.println(value, 2);</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;}</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160; </div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;void loop()</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;{</div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;}</div>
</div><!-- fragment --><p>Once again, we can compare the size of both:</p>
<p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"></th><th class="markdownTableHeadNone">Arduino API </th><th class="markdownTableHeadNone">FastArduino  </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">code size </td><td class="markdownTableBodyNone">1856 bytes </td><td class="markdownTableBodyNone">1710 bytes  </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">data size </td><td class="markdownTableBodyNone">188 bytes </td><td class="markdownTableBodyNone">74 bytes  </td></tr>
</table>
 </p><h2>Serial Input example</h2>
<p>FastArduino also implements input streams connected to serial output; here is a simple example:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="preprocessor">#include &lt;<a class="code" href="uart_8h.html">fastarduino/uart.h</a>&gt;</span></div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160; </div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;<span class="keyword">static</span> constexpr <span class="keyword">const</span> uint8_t INPUT_BUFFER_SIZE = 64;</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;<span class="keyword">static</span> <span class="keywordtype">char</span> input_buffer[INPUT_BUFFER_SIZE];</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160; </div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;<a class="code" href="uart_8h.html#a4fed67375824a0fc63e21ecdb7ce0db0">REGISTER_UARX_ISR</a>(0)</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160; </div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;int main()</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;{</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;    <a class="code" href="namespaceboard.html#a2529f85498783a75dc75c281e0b754d3">board::init</a>();</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;    sei();</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;    </div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;    <a class="code" href="classserial_1_1hard_1_1_u_a_r_x.html">serial::hard::UARX&lt;board::USART::USART0&gt;</a> uart{input_buffer};</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;    uart.<a class="code" href="classserial_1_1hard_1_1_u_a_r_x.html#ab990e6d4b45a811a451f1eeaa96faf1b">begin</a>(115200);</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160; </div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;    <a class="code" href="classstreams_1_1istream.html">streams::istream</a> in = uart.in();</div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160; </div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;    <span class="comment">// Wait until a character is ready and get it</span></div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;    <span class="keywordtype">char</span> value;</div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;    in.<a class="code" href="classstreams_1_1istream.html#a32740ec0eb870f855232b32d56fa0ef5">get</a>(value);</div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160; </div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;    <span class="comment">// Wait until a complete string is ready and get it</span></div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;    <span class="keywordtype">char</span> str[64+1];</div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;    in.<a class="code" href="classstreams_1_1istream.html#a32740ec0eb870f855232b32d56fa0ef5">get</a>(str, 64+1);</div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160; </div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;    <span class="keywordflow">return</span> 0;</div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;}</div>
</div><!-- fragment --><p>Note the similarities between this example and UATX example above for all the setup parts. The main differences are:</p><ul>
<li>use <code>UARX</code> type instead of <code>UATX</code></li>
<li><code><a class="el" href="uart_8h.html#a4fed67375824a0fc63e21ecdb7ce0db0" title="Register the necessary ISR (Interrupt Service Routine) for an serial::hard::UARX to work correctly.">REGISTER_UARX_ISR()</a></code> instead of <code><a class="el" href="uart_8h.html#aa33c57bb6fa1e93177abb21fe8fecb10" title="Register the necessary ISR (Interrupt Service Routine) for an serial::hard::UATX to work correctly.">REGISTER_UATX_ISR()</a></code> macro for ISR registration</li>
<li>use <code>istream</code> instead of <code>ostream</code> and <code>uart.in()</code> instead of <code>uart.out()</code></li>
</ul>
<p>Then <code>UARX</code> mainly offers one method, <code>get()</code>, which returns the next character serially received and buffered; if the input buffer is currently empty, then <code>get()</code> will block.</p>
<p>The example uses 2 flavors of this <code>istream</code> method:</p><ul>
<li><code>get(char&amp;)</code>: this method <b>blocks</b> until one character is available on serial input.</li>
<li><code>get(char*, size_t, char)</code>: this blocks until a complete string (terminated by a specified delimiter character, '\n' by default) gets read on serial input and fills the given buffer parameter with that string content.</li>
</ul>
<p>Note that these 2 methods use <code><a class="el" href="namespacetime.html#a5396c009ace06e55985ccf6b7bff179a" title="Utility method used by many FastArduino API in order to &quot;yield&quot; some processor time; concretely it ju...">time::yield()</a></code> while waiting; this may be linked to <code>power</code> management. Please take a look at the documentation for this API for further details.</p>
<h2>Formatted Input example</h2>
<p>Similar to output, input streams supports formatted input, as can be found in standard C++; once again, formatted input streams allow compile-time safety.</p>
<p>The following example uses formatted input to read values from USB:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="preprocessor">#include &lt;<a class="code" href="uart_8h.html">fastarduino/uart.h</a>&gt;</span></div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160; </div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;<span class="comment">// Define vectors we need in the example</span></div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;<a class="code" href="uart_8h.html#a4fed67375824a0fc63e21ecdb7ce0db0">REGISTER_UARX_ISR</a>(0)</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160; </div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;<span class="comment">// Buffers for UARX</span></div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;static const uint8_t INPUT_BUFFER_SIZE = 64;</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;static <span class="keywordtype">char</span> input_buffer[INPUT_BUFFER_SIZE];</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160; </div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;using INPUT = <a class="code" href="namespacestreams.html">streams</a>::istream;</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160; </div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;<span class="keywordtype">int</span> main()</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;{</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;    <a class="code" href="namespaceboard.html#a2529f85498783a75dc75c281e0b754d3">board::init</a>();</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;    sei();</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;    </div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;    <span class="comment">// Start UART</span></div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;    <a class="code" href="classserial_1_1hard_1_1_u_a_r_x.html">serial::hard::UARX&lt;board::USART::USART0&gt;</a> uarx{input_buffer};</div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;    uarx.<a class="code" href="classserial_1_1hard_1_1_u_a_r_x.html#ab990e6d4b45a811a451f1eeaa96faf1b">begin</a>(115200);</div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;    INPUT in = uarx.in();</div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160; </div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;    <span class="comment">// Wait for a char</span></div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;    <span class="keywordtype">char</span> value1;</div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;    in &gt;&gt; <a class="code" href="namespacestreams.html#a76316854cb7b9c0c7688d02c660ed369">streams::skipws</a> &gt;&gt; value1;</div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160; </div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;    <span class="comment">// Wait for an uint16_t</span></div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;    uint16_t value2;</div>
<div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;    in &gt;&gt; <a class="code" href="namespacestreams.html#a76316854cb7b9c0c7688d02c660ed369">streams::skipws</a> &gt;&gt; value2;</div>
<div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160; </div>
<div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;    <span class="keywordflow">return</span> 0;</div>
<div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;}</div>
</div><!-- fragment --><p>Here, we still use <code>uart.in()</code> but we use its "extraction operator" <code>&gt;&gt;</code>. All extractions are blocking and will not return until the required type can be read from the buffer.</p>
<p>If you are used to programming with C++ for more usual systems (e.g. Linux), then you will immediately recognize <a href="http://www.cplusplus.com/reference/istream/istream/operator%3E%3E/"><code>std::istream</code> API</a> which FastArduino library tries to implement with some level of fidelity.</p>
<p>You can also find more details in <code>streams</code> namespace documentation.</p>
<p>We have already seen <code>UATX</code> and <code>UARX</code> as classes for sending, resp. receiving, data through serial. There is also <code>UARX</code> which combines both.</p>
<p>As you know, the number of physical (hardware) UART available on an MCU target is limited, some targets (ATtiny) don't even have any hardware UART at all. For this reason, if you need extra UART featurs to connect to some devices, you can use software UART API, documented in namespace <code><a class="el" href="namespaceserial_1_1soft.html" title="Defines API types used by software UART features.">serial::soft</a></code>. As this is more complicated to use, it is not part of this basic tutorial, but will be addressed later on.</p>
<h1><a class="anchor" id="analoginput"></a>Basics: analog input </h1>
<p>Here is a simple example using analog input API to read a value from some sensor (thermistor, potentiometer, whatever you like) and lights a LED if the read value is above some threshold:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="preprocessor">#include &lt;<a class="code" href="analog__input_8h.html">fastarduino/analog_input.h</a>&gt;</span></div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;<span class="preprocessor">#include &lt;<a class="code" href="gpio_8h.html">fastarduino/gpio.h</a>&gt;</span></div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;<span class="preprocessor">#include &lt;<a class="code" href="time_8h.html">fastarduino/time.h</a>&gt;</span></div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160; </div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;<span class="keyword">const</span> uint16_t THRESHOLD = 500;</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160; </div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;<span class="keywordtype">int</span> main()</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;{</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;    <a class="code" href="namespaceboard.html#a2529f85498783a75dc75c281e0b754d3">board::init</a>();</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;    sei();</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160; </div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;    <a class="code" href="namespacegpio.html#a3cbdad86ced6494ca615a425b433fd57">gpio::FAST_PIN&lt;board::DigitalPin::LED&gt;</a> led{<a class="code" href="namespacegpio.html#ae18fafd08668ee17aa5dd415ee3b6041a50a87f0d71f7221582dad4bf507a0f34">gpio::PinMode::OUTPUT</a>};</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;    <a class="code" href="classanalog_1_1_analog_input.html">analog::AnalogInput&lt;board::AnalogPin::A0&gt;</a> sensor;</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;    <span class="keywordflow">while</span> (<span class="keyword">true</span>)</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;    {</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;        <span class="keywordflow">if</span> (sensor.<a class="code" href="classanalog_1_1_analog_input.html#a56e3701a8e1594347b99b3e0d300e598">sample</a>() &gt; THRESHOLD)</div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;            led.set();</div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;        <span class="keywordflow">else</span></div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;            led.clear();</div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;        <a class="code" href="namespacetime.html#af13fd17ddf6b751b8161691e608892b2">time::delay_ms</a>(100);</div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;    }</div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;    <span class="keywordflow">return</span> 0;</div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;}</div>
</div><!-- fragment --><p>This example is an adaptation of the <a class="el" href="namespacegpio.html">first GPIO example</a> of this tutorial.</p>
<p>The first change consists in including the necessary header:  </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="analog__input_8h.html">fastarduino/analog_input.h</a>&gt;</span></div>
</div><!-- fragment --><p>Then we have the definition of the <code>sensor</code> variable: </p><div class="fragment"><div class="line">    <a class="code" href="classanalog_1_1_analog_input.html">analog::AnalogInput&lt;board::AnalogPin::A0&gt;</a> sensor;</div>
</div><!-- fragment --><p>Here we instantiate <code>AnalogInput</code> for analog pin <code>A0</code> (on Arduino UNO).</p>
<p>In the infinite loop, we then get the current analog value of <code>sensor</code> and compare it to <code>THRESHOLD</code> constant: </p><div class="fragment"><div class="line">        <span class="keywordflow">if</span> (sensor.<a class="code" href="classanalog_1_1_analog_input.html#a56e3701a8e1594347b99b3e0d300e598">sample</a>() &gt; THRESHOLD)</div>
</div><!-- fragment --><p>By default, sample values are on 10 bits (0..1023) represented as <code>uint16_t</code>.</p>
<p>If you don't need such precision, you can define <code>sensor</code> differently: </p><div class="fragment"><div class="line">    <a class="code" href="classanalog_1_1_analog_input.html">analog::AnalogInput&lt;board::AnalogPin::A0, board::AnalogReference::AVCC, uint8_t&gt;</a> sensor;</div>
</div><!-- fragment --><p>Note the two additional template arguments provided to <code>AnalogInput&lt;...&gt;</code>:</p><ul>
<li>the first added argument <code>board::AnalogReference::AVCC</code>, although seldom changed, may become important when you create your own boards from MCU chips; you can further read API documentation if you need more information about it</li>
<li>the second added argument is the type of returned samples, either <code>uint16_t</code> (default value) or <code>uint8_t</code>. The type determines the samples precision:<ul>
<li><code>uint8_t</code>: 8 bits (samples between 0 and 255)</li>
<li><code>uint16_t</code>: 10 bits (samples between 0 and 1023)</li>
</ul>
</li>
</ul>
<p>Now let's compare the first example with the equivalent Arduino core API program:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;void setup()</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;{</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    pinMode(LED_BUILTIN, OUTPUT);</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;}</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160; </div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;const uint16_t THRESHOLD = 500;</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160; </div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;void loop()</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;{</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;    if (analogRead(A0) &gt; THRESHOLD)</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;        digitalWrite(LED_BUILTIN, HIGH);</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;    else</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;        digitalWrite(LED_BUILTIN, LOW);</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;    delay(100);</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;}</div>
</div><!-- fragment --><p>As usual, we compare the size of both:</p>
<p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"></th><th class="markdownTableHeadNone">Arduino API </th><th class="markdownTableHeadNone">FastArduino  </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">code size </td><td class="markdownTableBodyNone">926 bytes </td><td class="markdownTableBodyNone">204 bytes  </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">data size </td><td class="markdownTableBodyNone">9 bytes </td><td class="markdownTableBodyNone">0 byte  </td></tr>
</table>
 Note that Arduino core API does not allow you any other precision than 10 bits.</p>
<h1><a class="anchor" id="timer"></a>Basics: timer </h1>
<p>A timer (it should actually be named "timer/counter") is a logic chip or part of an MCU that just "counts" pulses of a clock at a given frequency. It can have several modes. It is used in many occasions such as:</p><ul>
<li>real time counting</li>
<li>asynchronous tasks (one-shot or periodic) scheduling</li>
<li>PWM signal generation (see <a class="el" href="tutorial.html#pwm">PWM</a> for further details)</li>
</ul>
<p>A timer generally counts up, but it may also, on some occasions, count down; it may trigger interrupts on several events (i.e. when counter reaches some specific limits), it may drive some specific digital output pins, and sometimes it may also be driven by digital input pins (to capture counter value).</p>
<p>There are typically several independent timers on an MCU, but they are not all the same. Timers may differ in:</p><ul>
<li>counter size (8 or 16 bits for AVR timers)</li>
<li>list of settable frequencies (timer frequencies are derived from the MCU clock by prescaler devices)</li>
<li>the timer modes supported</li>
<li>the pins they are connected to</li>
<li>specific capabilities they may have</li>
</ul>
<p>Rather than explaining the theory further, we will start studying a simple example that uses a timer for blinking a LED, a little bit like the first example in this tutorial, but totally driven asynchronously:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="preprocessor">#include &lt;<a class="code" href="gpio_8h.html">fastarduino/gpio.h</a>&gt;</span></div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;<span class="preprocessor">#include &lt;<a class="code" href="timer_8h.html">fastarduino/timer.h</a>&gt;</span></div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160; </div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;constexpr <span class="keyword">const</span> <a class="code" href="namespaceboard.html#aa6b4a447b2fccb95185367644c3f28bb">board::Timer</a> NTIMER = board::Timer::TIMER1;</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;<span class="keyword">using</span> CALCULATOR = <a class="code" href="structtimer_1_1_calculator.html">timer::Calculator&lt;NTIMER&gt;</a>;</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;<span class="keyword">using</span> TIMER = <a class="code" href="classtimer_1_1_timer.html">timer::Timer&lt;NTIMER&gt;</a>;</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;constexpr <span class="keyword">const</span> uint32_t PERIOD_US = 1000000;</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160; </div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;constexpr <span class="keyword">const</span> TIMER::PRESCALER PRESCALER = CALCULATOR::CTC_prescaler(PERIOD_US);</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;constexpr <span class="keyword">const</span> TIMER::TYPE COUNTER = CALCULATOR::CTC_counter(PRESCALER, PERIOD_US);</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160; </div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;<span class="keyword">class </span>Handler</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;{</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;<span class="keyword">public</span>:</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;    Handler(): _led{<a class="code" href="namespacegpio.html#ae18fafd08668ee17aa5dd415ee3b6041a50a87f0d71f7221582dad4bf507a0f34">gpio::PinMode::OUTPUT</a>, <span class="keyword">false</span>} {}</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;    </div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;    <span class="keywordtype">void</span> on_timer()</div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;    {</div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;        _led.toggle();</div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;    }</div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;    </div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;<span class="keyword">private</span>:</div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;    <a class="code" href="namespacegpio.html#a3cbdad86ced6494ca615a425b433fd57">gpio::FAST_PIN&lt;board::DigitalPin::LED&gt;</a> _led;</div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;};</div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160; </div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;<span class="comment">// Define vectors we need in the example</span></div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;<a class="code" href="timer_8h.html#acfce0d4d6115510756da8d720409ed26">REGISTER_TIMER_COMPARE_ISR_METHOD</a>(1, Handler, &amp;Handler::on_timer)</div>
<div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160; </div>
<div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;<span class="keywordtype">int</span> main() __attribute__((OS_main));</div>
<div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;<span class="keywordtype">int</span> main()</div>
<div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;{</div>
<div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;    <a class="code" href="namespaceboard.html#a2529f85498783a75dc75c281e0b754d3">board::init</a>();</div>
<div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;    sei();</div>
<div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;    Handler handler;</div>
<div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;    <a class="code" href="namespaceinterrupt.html#abfd5857208f49006bde8c472497273de">interrupt::register_handler</a>(handler);</div>
<div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;    TIMER <a class="code" href="namespacetimer.html">timer</a>{timer::TimerMode::CTC, PRESCALER, timer::TimerInterrupt::OUTPUT_COMPARE_A};</div>
<div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;    <a class="code" href="namespacetimer.html">timer</a>.begin(COUNTER);</div>
<div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;    </div>
<div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;    <span class="keywordflow">while</span> (<span class="keyword">true</span>) ;</div>
<div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;}</div>
</div><!-- fragment --><p>This example looks much more complex than all previous examples but it is straightforward to understand once explained part after part.</p>
 <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="gpio_8h.html">fastarduino/gpio.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="timer_8h.html">fastarduino/timer.h</a>&gt;</span></div>
</div><!-- fragment --><p> In addition to GPIO, we include the header containing all Timer API.</p>
<p>For this example, we use Arduino UNO, which MCU (ATmega328P) includes 3 timers (named respectively <code>Timer0</code>, <code>Timer1</code>, <code>Timer2</code> in its datasheet), we use Timer1 which is 16-bits in size: </p><div class="fragment"><div class="line">constexpr <span class="keyword">const</span> <a class="code" href="namespaceboard.html#aa6b4a447b2fccb95185367644c3f28bb">board::Timer</a> NTIMER = board::Timer::TIMER1;</div>
<div class="line"><span class="keyword">using</span> CALCULATOR = <a class="code" href="structtimer_1_1_calculator.html">timer::Calculator&lt;NTIMER&gt;</a>;</div>
<div class="line"><span class="keyword">using</span> TIMER = <a class="code" href="classtimer_1_1_timer.html">timer::Timer&lt;NTIMER&gt;</a>;</div>
<div class="line">constexpr <span class="keyword">const</span> uint32_t PERIOD_US = 1000000;</div>
</div><!-- fragment --><p>Although not needed, it is a good practice to define a <code>const</code>, named <code>NTIMER</code> in this snippet, valued with the real timer we intend to use. Then we define 2 new type aliases, <code>CALCULATOR</code> and <code>TIMER</code> that will help us type less code (this is common recommended practice when using C++ templates heavily in programs):</p><ul>
<li><code>CALCULATOR</code> is the type of a class which provides <code>static</code> utility methods that will help us configure the timer we have selected; do note that, since all timers are different, <code>CALCULATOR</code> is specific to one timer only; hence if our program was using 2 distinct timers, we would have to define two distinct calculator type aliases, one for each timer.</li>
<li><code>TIMER</code> is the type of the class that embed all timer API for the specific timer we have selected.</li>
</ul>
<p>Finally we define <code>PERIOD_US</code> the period, in microseconds, at which we want the LED to blink. Please note that this is in fact half the actual period, because this is the time at which we will toggle the LED light.</p>
<div class="fragment"><div class="line">constexpr <span class="keyword">const</span> TIMER::PRESCALER PRESCALER = CALCULATOR::CTC_prescaler(PERIOD_US);</div>
<div class="line">constexpr <span class="keyword">const</span> TIMER::TYPE COUNTER = CALCULATOR::CTC_counter(PRESCALER, PERIOD_US);</div>
</div><!-- fragment --><p> The above snippet defines constant settings, computed by <code>CALCULATOR</code> utility class, that we will later use to initialize our timer:</p><ul>
<li><code>PRESCALER</code> is the <b>optimum</b> prescaler value that we can use for our timer in order to be able to count up to the requested period, i.e. 1 second; the type of prescaler is an <code>enum</code> that depends on each timer (because the list of available prescaler values differ from one timer to another). The prescaler defines the number by which the MCU clock frequency will be divided to provide the pulses used to increment the timer. We don't need to know this value or fix it ourselves because <code>CALCULATOR::CTC_prescaler</code> calculates the best choice for us.</li>
<li><code>COUNTER</code> is the maximum counter value that the timer can reach until 1 second has ellapsed; its type is based on the timer we have selected (i.e. <code>Timer1</code> =&gt; 16 bits =&gt; <code>uint16_t</code>), but we don't need to fix this type ourselves because it depends on the timer we have selected.</li>
</ul>
<p>Note that, although we know in advance which timer we use, we always avoid declaring direct types (such as <code>uint16_t</code>) in order to facilate a potential change to another timer in the future, without having to change several code locations.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>Handler</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    Handler(): _led{<a class="code" href="namespacegpio.html#ae18fafd08668ee17aa5dd415ee3b6041a50a87f0d71f7221582dad4bf507a0f34">gpio::PinMode::OUTPUT</a>, <span class="keyword">false</span>} {}</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> on_timer()</div>
<div class="line">    {</div>
<div class="line">        _led.toggle();</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <a class="code" href="namespacegpio.html#a3cbdad86ced6494ca615a425b433fd57">gpio::FAST_PIN&lt;board::DigitalPin::LED&gt;</a> _led;</div>
<div class="line">};</div>
</div><!-- fragment --><p> Here we define the class which implements the code in charge of blinking the LED every time the timer has reached its maximum value, i.e. every second. There is nothing special to explain here, except that the method <code>on_timer()</code> is a <em>callback function</em> which will get called asynchronously (from interrupt handlers) when the timer reaches its max.</p>
<p>Since timers generate interruptions, we need to "attach" our handler code above to the suitable interruption, this is done through the following line of code: </p><div class="fragment"><div class="line"><a class="code" href="timer_8h.html#acfce0d4d6115510756da8d720409ed26">REGISTER_TIMER_COMPARE_ISR_METHOD</a>(1, Handler, &amp;Handler::on_timer)</div>
</div><!-- fragment --><p> <code>REGISTER_TIMER_COMPARE_ISR_METHOD</code> is a macro that will generate extra code (code you do not need, nor want, to see) to declare the Interrupt Service Routine (<em>ISR</em>) attached to the proper interruption of our selected timer; it takes 3 arguments:</p><ul>
<li><code>1</code> is the timer number (<code>0</code>, <code>1</code> or <code>2</code> on UNO)</li>
<li><code>Handler</code> is the class that contains the code to be called when the interrupt occurs</li>
<li><code>&amp;Handler::on_timer</code> is the Pointer to Member Function (often abbreviated <em>PTMF</em> by usual C++ developers) telling which method from <code>Handler</code> shall be called back when the interrupt occurs In FastArduino, interrupt handling follows some patterns that are further described <a class="el" href="tutorial.html#interrupts">here</a> and won't be developed in detail now.</li>
</ul>
<p>Now we can finally start writing the code of the <code>main()</code> function: </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> main() __attribute__((OS_main));</div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="namespaceboard.html#a2529f85498783a75dc75c281e0b754d3">board::init</a>();</div>
<div class="line">    sei();</div>
<div class="line">    Handler handler;</div>
<div class="line">    <a class="code" href="namespaceinterrupt.html#abfd5857208f49006bde8c472497273de">interrupt::register_handler</a>(handler);</div>
</div><!-- fragment --><p> Past the usual initialization stuff, this code performs an important task regarding interrupt handling: it creates <code>handler</code>, an instance of the <code>Handler</code> class that has been defined before as the class to handle interrupts for the selected timer, and then it <b>registers</b> this handler instance with FastArduino. Now we are sure that interrupts for our timer will call <code>handler.on_timer()</code>.</p>
<p>The last part of the code creates and starts the timer we need in our program: </p><div class="fragment"><div class="line">    TIMER <a class="code" href="namespacetimer.html">timer</a>{timer::TimerMode::CTC, PRESCALER, timer::TimerInterrupt::OUTPUT_COMPARE_A};</div>
<div class="line">    <a class="code" href="namespacetimer.html">timer</a>.begin(COUNTER);</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">while</span> (<span class="keyword">true</span>) ;</div>
<div class="line">}</div>
</div><!-- fragment --><p> <code>timer</code> is the instance of <code><a class="el" href="classtimer_1_1_timer.html" title="General API to handle an AVR timer.">timer::Timer</a></code> API for <code>board::Timer::TIMER1</code>; upon instantiation, it is passed the timer mode to use, the previously calculated clock prescaler, and the interrupt we want to enable.</p>
<p>Here we use <em>CTC</em> mode (Clear Timer on Compare); in this mode the counter is incremented until it reaches a maximum value, then it triggers an interrupt and it clears the counter value back to zero and starts counting up again.</p>
<p>To ensure that our handler to get called back when the timer reaches 1 second, we set <code>timer::TimerInterrupt::OUTPUT_COMPARE_A</code>, which enables the proper interrupt on this timer: when the counter is reached, an interrupt will occur, the properly registered ISR will be called, and in turn it will call our handler.</p>
<p>Then <code>timer.begin()</code> activates the timer with the maximum counter value, that was calculated initially in the program. This value, along with <code>PRESCALER</code>, has been calculated in order for <code>timer</code> to generate an interrupt (i.e. call <code>handler.on_timer()</code>) every second.</p>
<p>Note the infinite loop <code>while (true);</code> at the end of <code>main()</code>: without it the program would terminate immediately, giving no chance to our timer and handler to operate as expected. What is interesting to see here is that the main code does not do anything besides looping forever: all actual stuff happens asynchronously behind the scenes!</p>
<p>I would have liked to perform a size comparison with Arduino API, but unfortunately, the basic Arduino API does not provide an equivalent way to directly access a timer, hence we cannot produce the equivalent code here. Anyway, here is the size for the example above:</p>
<p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"></th><th class="markdownTableHeadNone">FastArduino  </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">code size </td><td class="markdownTableBodyNone">234 bytes  </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">data size </td><td class="markdownTableBodyNone">2 bytes  </td></tr>
</table>
</p>
<h1><a class="anchor" id="rtt"></a>Basics: real-time timer </h1>
<p>A real-time timer is primarily a device that tracks time in standard measurements (ms, us).</p>
<p>It may be used in various situations such as:</p><ul>
<li>delay program execution for some us or ms</li>
<li>capture the duration of some event with good accuracy</li>
<li>implement timeouts in programs waiting for an event to occur</li>
<li>generate periodic events</li>
</ul>
<p>The simple example that follows illustrates the first use case:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="preprocessor">#include &lt;<a class="code" href="gpio_8h.html">fastarduino/gpio.h</a>&gt;</span></div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;<span class="preprocessor">#include &lt;<a class="code" href="realtime__timer_8h.html">fastarduino/realtime_timer.h</a>&gt;</span></div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160; </div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;<a class="code" href="realtime__timer_8h.html#afc2dfeccc5d417ae872d836d4cfb5d8c">REGISTER_RTT_ISR</a>(0)</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160; </div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;const constexpr uint32_t BLINK_DELAY_MS = 500;</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160; </div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;<span class="keywordtype">int</span> main()</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;{</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;    <a class="code" href="namespaceboard.html#a2529f85498783a75dc75c281e0b754d3">board::init</a>();</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;    sei();</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160; </div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;    <a class="code" href="classtimer_1_1_r_t_t.html">timer::RTT&lt;board::Timer::TIMER0&gt;</a> rtt;</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;    rtt.<a class="code" href="classtimer_1_1_r_t_t.html#a9f2975201cfb390d7fb15e930d0c5489">begin</a>();</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160; </div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;    <a class="code" href="namespacegpio.html#a3cbdad86ced6494ca615a425b433fd57">gpio::FAST_PIN&lt;board::DigitalPin::LED&gt;</a> led{<a class="code" href="namespacegpio.html#ae18fafd08668ee17aa5dd415ee3b6041a50a87f0d71f7221582dad4bf507a0f34">gpio::PinMode::OUTPUT</a>};</div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;    <span class="keywordflow">while</span> (<span class="keyword">true</span>)</div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;    {</div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;        led.toggle();</div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;        rtt.<a class="code" href="classtimer_1_1_r_t_t.html#a7d5c189655b98446f08ccd5cf078c912">delay</a>(BLINK_DELAY_MS);</div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;    }</div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;}</div>
</div><!-- fragment --><p>This example looks much like the first blinking example in this tutorial, with a few changes.</p>
<p>First off, as usual the neceaary header file is included:  </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="realtime__timer_8h.html">fastarduino/realtime_timer.h</a>&gt;</span></div>
</div><!-- fragment --><p>Then we need to register an ISR for the RTT feature to work properly: </p><div class="fragment"><div class="line"><a class="code" href="realtime__timer_8h.html#afc2dfeccc5d417ae872d836d4cfb5d8c">REGISTER_RTT_ISR</a>(0)</div>
</div><!-- fragment --><p>Then, in <code>main()</code>, after the usual initialization stuff, we create a real-time timer instance, based on AVR UNO Timer0 (8-bits timer), and start it counting time. </p><div class="fragment"><div class="line">    <a class="code" href="classtimer_1_1_r_t_t.html">timer::RTT&lt;board::Timer::TIMER0&gt;</a> rtt;</div>
<div class="line">    rtt.<a class="code" href="classtimer_1_1_r_t_t.html#a9f2975201cfb390d7fb15e930d0c5489">begin</a>();</div>
</div><!-- fragment --><p>Finally, we have the usual loop, toogling the LED, and then delay for 10s, using the RTT API: </p><div class="fragment"><div class="line">        rtt.<a class="code" href="classtimer_1_1_r_t_t.html#a7d5c189655b98446f08ccd5cf078c912">delay</a>(BLINK_DELAY_MS);</div>
</div><!-- fragment --><p>Let's examine the size of this program and compare it with the first example of this tutorial, which used <code><a class="el" href="namespacetime.html#af13fd17ddf6b751b8161691e608892b2" title="Delay program execution for the given amount of milliseconds.">time::delay_ms()</a></code>:</p>
<p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"></th><th class="markdownTableHeadNone">delay_ms </th><th class="markdownTableHeadNone">RTT::delay  </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">code size </td><td class="markdownTableBodyNone">154 bytes </td><td class="markdownTableBodyNone">372 bytes  </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">data size </td><td class="markdownTableBodyNone">0 byte </td><td class="markdownTableBodyNone">2 bytes  </td></tr>
</table>
 As you can see, code and data size is higher here, so what is the point of using <code><a class="el" href="namespacetime.html#af1e59bdf7c41bd8ff215d69a769a89bf" title="Delay program execution for the given amount of milliseconds.">RTT::delay()</a></code> instead of <code><a class="el" href="namespacetime.html#af13fd17ddf6b751b8161691e608892b2" title="Delay program execution for the given amount of milliseconds.">time::delay_ms()</a></code>? The answer is <b>power consumption</b>:</p><ul>
<li><code><a class="el" href="namespacetime.html#af13fd17ddf6b751b8161691e608892b2" title="Delay program execution for the given amount of milliseconds.">time::delay_ms</a></code> is a busy loop which requires the MCU to be running during the whole delay, hence consuming "active supply current" (about 15mA for an ATmega328P at 16MHz)</li>
<li><code><a class="el" href="namespacetime.html#af1e59bdf7c41bd8ff215d69a769a89bf" title="Delay program execution for the given amount of milliseconds.">RTT::delay()</a></code> will set the MCU to pre-defined sleep mode and will still continue to operate well under most available sleep modes (this depends on which timer gets used, refer to <a href="http://ww1.microchip.com/downloads/en/DeviceDoc/Atmel-42735-8-bit-AVR-Microcontroller-ATmega328-328P_Datasheet.pdf">AVR datasheet</a> for further details); this will alow reduction of supply current, hence power consumption. Current supply will be reduced more or less dramatically according to the selected sleep mode.</li>
</ul>
<p>Another practical use of RTT is to measure the elapsed time between two events. For instance it can be used with an ultrasonic ranging device to measure the duration of an ultrasound wave to do a roundript from the device to an obstacle, then calculate the actual distance in mm. The following snippet shows how it could look like for an HC-SR04 sensor: </p><div class="fragment"><div class="line"><span class="comment">// Declare 2 pins connected to HC-SR04</span></div>
<div class="line"><a class="code" href="namespacegpio.html#a3cbdad86ced6494ca615a425b433fd57">gpio::FAST_PIN&lt;board::DigitalPin::D0&gt;</a> trigger{<a class="code" href="namespacegpio.html#ae18fafd08668ee17aa5dd415ee3b6041a50a87f0d71f7221582dad4bf507a0f34">gpio::PinMode::OUTPUT</a>};</div>
<div class="line"><a class="code" href="namespacegpio.html#a3cbdad86ced6494ca615a425b433fd57">gpio::FAST_PIN&lt;board::DigitalPin::D1&gt;</a> echo{gpio::PinMode::INPUT};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Declare RTT (note: don&#39;t forget to call REGISTER_RTT_ISR(1) macro in your program)</span></div>
<div class="line"><a class="code" href="classtimer_1_1_r_t_t.html">timer::RTT&lt;board::Timer::TIMER1&gt;</a>&amp; rtt;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Send a 10us pulse to the trigger pin</span></div>
<div class="line">trigger.set();</div>
<div class="line"><a class="code" href="namespacetime.html#a258d2da0bcb268278406d4c8cb0dda1c">time::delay_us</a>(10);</div>
<div class="line">trigger.clear();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Wait for echo signal start</span></div>
<div class="line"><span class="keywordflow">while</span> (!echo.value()) ;</div>
<div class="line"><span class="comment">// Reset RTT time</span></div>
<div class="line">rtt.<a class="code" href="classtimer_1_1_r_t_t.html#a7a6aaedc91de46926931990538c8ae26">millis</a>(0);</div>
<div class="line"><span class="comment">// Wait for echo signal end</span></div>
<div class="line"><span class="keywordflow">while</span> (echo.value()) ;</div>
<div class="line"><span class="comment">// Read current time</span></div>
<div class="line"><a class="code" href="classtime_1_1_r_t_t_time.html">time::RTTTime</a> end = rtt.<a class="code" href="classtimer_1_1_r_t_t.html#ac5c7807d1cb3f77fc54685f85b193e32">time</a>();</div>
<div class="line"><span class="comment">// Calculate the echo duration in microseconds</span></div>
<div class="line">uint16_t echo_us = uint16_t(end.<a class="code" href="classtime_1_1_r_t_t_time.html#abe9d6453890926b91e158faf562693f7">millis</a>() * 1000UL + end.<a class="code" href="classtime_1_1_r_t_t_time.html#a8a53c14cd518a7287035a9598ccabaa0">micros</a>());</div>
</div><!-- fragment --><p>Note that this snippet is just an example and is not usable as is: it does not include a timeout mechanism to avoid waiting the echo signal forever (which can happen if the ultrasonic wave does not encounter an obstacle within its possible range, i.e. 4 meters). Also, this approach could be improved by making it interrupt-driven (i.e. having interrupts generated when the <code>echo_pin</code> changes state).</p>
<p>Actually, if you want a complete implementation of HC-SR04 ultrasonic ranging device, then you should take a look at FastArduino provided API in namespace <code><a class="el" href="namespacedevices_1_1sonar.html" title="Defines the API for sonar support.">devices::sonar</a></code>.</p>
<p>Another interesting use of RTT is to perform some periodic actions. FastArduino implements an events handling mechanism that can be connected to an RTT in order to deliver periodic events. This mechanism is <a class="el" href="tutorial.html#events">described later</a> in this tutorial.</p>
<h1><a class="anchor" id="pwm"></a>Basics: PWM </h1>
<p>PWM (<em>Pulse Width modulation</em>) is a technique that can be used to simulate generation of an analog voltage level through a purely digital output. This is done by varying the <em>duty cycle</em> of a rectangular pulse wave, i.e. the ratio of "on" time over the wave period.</p>
<p>PWM is implemented by MCU through timers.</p>
<p>FastArduino includes special support for PWM. The following example demonstrates PWM to increase then decrease the light emitted by a LED:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="preprocessor">#include &lt;<a class="code" href="time_8h.html">fastarduino/time.h</a>&gt;</span></div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;<span class="preprocessor">#include &lt;<a class="code" href="pwm_8h.html">fastarduino/pwm.h</a>&gt;</span></div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160; </div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;<span class="keyword">static</span> constexpr <span class="keyword">const</span> <a class="code" href="namespaceboard.html#aa6b4a447b2fccb95185367644c3f28bb">board::Timer</a> NTIMER = board::Timer::TIMER0;</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;<span class="keyword">using</span> TIMER = <a class="code" href="classtimer_1_1_timer.html">timer::Timer&lt;NTIMER&gt;</a>;</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;<span class="keyword">using</span> CALC = <a class="code" href="structtimer_1_1_calculator.html">timer::Calculator&lt;NTIMER&gt;</a>;</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;<span class="keyword">static</span> constexpr <span class="keyword">const</span> uint16_t PWM_FREQUENCY = 450;</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;<span class="keyword">static</span> constexpr <span class="keyword">const</span> TIMER::PRESCALER PRESCALER = CALC::FastPWM_prescaler(PWM_FREQUENCY);</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160; </div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;<span class="keyword">static</span> constexpr <span class="keyword">const</span> <a class="code" href="namespaceboard.html#a1283eb94244413c14c80cc2f3e8bcb3f">board::PWMPin</a> LED = board::PWMPin::D6_PD6_OC0A;</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;<span class="keyword">using</span> LED_PWM = <a class="code" href="classanalog_1_1_p_w_m_output.html">analog::PWMOutput&lt;LED&gt;</a>;</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160; </div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;<span class="keywordtype">int</span> main()</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;{</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;    <a class="code" href="namespaceboard.html#a2529f85498783a75dc75c281e0b754d3">board::init</a>();</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;    sei();</div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160; </div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;    <span class="comment">// Initialize timer</span></div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;    TIMER <a class="code" href="namespacetimer.html">timer</a>{timer::TimerMode::FAST_PWM, PRESCALER};</div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;    <a class="code" href="namespacetimer.html">timer</a>.begin();</div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;    </div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;    LED_PWM led{<a class="code" href="namespacetimer.html">timer</a>};</div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;    <span class="comment">// Loop of samplings</span></div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;    <span class="keywordflow">while</span> (<span class="keyword">true</span>)</div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;    {</div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;        <span class="keywordflow">for</span> (LED_PWM::TYPE duty = 0; duty &lt; LED_PWM::MAX; ++duty)</div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;        {</div>
<div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;            led.set_duty(duty);</div>
<div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;            <a class="code" href="namespacetime.html#af13fd17ddf6b751b8161691e608892b2">time::delay_ms</a>(50);</div>
<div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;        }</div>
<div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;        <span class="keywordflow">for</span> (LED_PWM::TYPE duty = LED_PWM::MAX; duty &gt; 0; --duty)</div>
<div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;        {</div>
<div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;            led.set_duty(duty);</div>
<div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;            <a class="code" href="namespacetime.html#af13fd17ddf6b751b8161691e608892b2">time::delay_ms</a>(50);</div>
<div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;        }</div>
<div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;    }</div>
<div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;    <span class="keywordflow">return</span> 0;</div>
<div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;}</div>
</div><!-- fragment --><p>The program starts by including the header for PWM API; this will automatically include the timer API header too.</p>
<p>Then a timer is selected for PWM (note that the choice of a timer imposes the choice of possible pins) and a prescaler value computed for it, based on the PWM frequency we want to use, 450Hz, which is generally good enough for most use cases (dimming a LED, rotating a DC motor...):  </p><div class="fragment"><div class="line"><span class="keyword">static</span> constexpr <span class="keyword">const</span> <a class="code" href="namespaceboard.html#aa6b4a447b2fccb95185367644c3f28bb">board::Timer</a> NTIMER = board::Timer::TIMER0;</div>
<div class="line"><span class="keyword">using</span> TIMER = <a class="code" href="classtimer_1_1_timer.html">timer::Timer&lt;NTIMER&gt;</a>;</div>
<div class="line"><span class="keyword">using</span> CALC = <a class="code" href="structtimer_1_1_calculator.html">timer::Calculator&lt;NTIMER&gt;</a>;</div>
<div class="line"><span class="keyword">static</span> constexpr <span class="keyword">const</span> uint16_t PWM_FREQUENCY = 450;</div>
<div class="line"><span class="keyword">static</span> constexpr <span class="keyword">const</span> TIMER::PRESCALER PRESCALER = CALC::FastPWM_prescaler(PWM_FREQUENCY);</div>
</div><!-- fragment --><p>Then we define the pin that will be connected to the LED and the PWMOutput type for this pin: </p><div class="fragment"><div class="line"><span class="keyword">static</span> constexpr <span class="keyword">const</span> <a class="code" href="namespaceboard.html#a1283eb94244413c14c80cc2f3e8bcb3f">board::PWMPin</a> LED = board::PWMPin::D6_PD6_OC0A;</div>
<div class="line"><span class="keyword">using</span> LED_PWM = <a class="code" href="classanalog_1_1_p_w_m_output.html">analog::PWMOutput&lt;LED&gt;</a>;</div>
</div><!-- fragment --><p> Note that <code><a class="el" href="namespaceboard.html#a1283eb94244413c14c80cc2f3e8bcb3f" title="Defines all digital output pins of target MCU, capable of PWM output.">board::PWMPin</a></code> enum limits the pins to PWM-enabled pins; also note the pin name <code>D6_PD6_OC0A</code> includes useful information:</p><ul>
<li>this is pin <code>D6</code> on Arduino UNO</li>
<li>this pin is on <code>PD6</code> i.e. Port D bit #6</li>
<li>this pin is connectable to <code>OC0A</code> i.e. Timer 0 COM A</li>
</ul>
<p>Then, in <code>main()</code>, after the usual initialization code, we initialize and start the timer: </p><div class="fragment"><div class="line">    <span class="comment">// Initialize timer</span></div>
<div class="line">    TIMER <a class="code" href="namespacetimer.html">timer</a>{timer::TimerMode::FAST_PWM, PRESCALER};</div>
<div class="line">    <a class="code" href="namespacetimer.html">timer</a>.begin();</div>
</div><!-- fragment --><p> Notice we use the <em>Fast PWM</em> mode here, but we might as well use <em>Phase Correct PWM</em> mode.</p>
<p>Next we connect the LED pin to the timer: </p><div class="fragment"><div class="line">    LED_PWM led{<a class="code" href="namespacetimer.html">timer</a>};</div>
</div><!-- fragment --><p>In the main loop, we have 2 consecutive loops, the first increases the light, the second decreases it. Both loops vary the duty cycle between its limits: </p><div class="fragment"><div class="line">        <span class="keywordflow">for</span> (LED_PWM::TYPE duty = 0; duty &lt; LED_PWM::MAX; ++duty)</div>
<div class="line">        {</div>
<div class="line">            led.set_duty(duty);</div>
<div class="line">            <a class="code" href="namespacetime.html#af13fd17ddf6b751b8161691e608892b2">time::delay_ms</a>(50);</div>
<div class="line">        }</div>
</div><!-- fragment --><p> Note the use of <code>LED_PWM::TYPE</code>, which depends on the timer selected (8 or 16 bits), and <code>LED_PWM::MAX</code> which provides the maximum value usable for the duty cycle, i.e. the value mapping to 100% duty cycle. Pay attention to the fact that <code>LED_PWM::TYPE</code> is unsigned, this explains the 2nd loop: </p><div class="fragment"><div class="line">        <span class="keywordflow">for</span> (LED_PWM::TYPE duty = LED_PWM::MAX; duty &gt; 0; --duty)</div>
<div class="line">        {</div>
<div class="line">            led.set_duty(duty);</div>
<div class="line">            <a class="code" href="namespacetime.html#af13fd17ddf6b751b8161691e608892b2">time::delay_ms</a>(50);</div>
<div class="line">        }</div>
</div><!-- fragment --><p> Here, we shall not use <code>duty &gt;= 0</code> as the <code>for</code> condition, because that condition would be always <code>true</code>, hence the loop would be infinite.</p>
<p>Now let's compare this example with the Arduino API equivalent:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;#define LED 6</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160; </div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;void setup() {</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;}</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160; </div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;void loop() {</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    for (int duty = 0; duty &lt; 255; ++duty)</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;    {</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;        analogWrite(LED, duty);</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;        delay(50);</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;    }</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;    for (int duty = 255; duty &gt; 0; --duty)</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;    {</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;        analogWrite(LED, duty);</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;        delay(50);</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;    }</div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;}</div>
</div><!-- fragment --><p>Nothing special to comment here, except:</p><ul>
<li><code>duty</code> values are always limited to 255 even though some PWM pins are attached to a 16-bits timer</li>
<li>you cannot choose the PWM mode you want to use, it is fixed by Arduino API and varies depending on which timer is used (e.g. for Arduino UNO, Timer0 uses Fast PWM, whereas Time1 and Timer2 use Phase Correct PWM mode)</li>
<li>you cannot choose the PWM frequency, this is imposed to you by Arduino API and varies depending on which timer is used</li>
<li>you may pass any pin value to <code>analogWrite()</code> and the sketch will still compile and upload but the sketch will not work</li>
</ul>
<p>Comparing sizes once again shows big differences:</p>
<p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"></th><th class="markdownTableHeadNone">Arduino API </th><th class="markdownTableHeadNone">FastArduino  </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">code size </td><td class="markdownTableBodyNone">1102 bytes </td><td class="markdownTableBodyNone">288 bytes  </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">data size </td><td class="markdownTableBodyNone">9 bytes </td><td class="markdownTableBodyNone">0 byte  </td></tr>
</table>
</p>
<h1><a class="anchor" id="utils"></a>Basics: utilities </h1>
<p>FastArduino provides several general utilities, gathered inside one namespace <code>utils</code>.</p>
<p>We will not demonstrate each of these utilities here but just show a few of them in action. In your own programs, if you find yourself in need of some helper stuff that you think deserves to be provided as a general utility, then first take a look at FastArduino <a href="namespaceutils.html">utilities API documentation</a> and check if you don't find it there, or something similar that you could use in your situation.</p>
<p>FastArduino utilities are made of different kinds:</p><ul>
<li>low-level utilities: mostly functions to handle bytes and bits</li>
<li>value conversion utilities: functions to help convert a value from one referential to another, very useful when dealing with sensors of all sorts</li>
</ul>
<h2>Low-level utilities examples</h2>
<p>The few examples in this section will introduce you to a few functions that may prove useful if you need to handle devices that are not natively supported by FastArduino.</p>
<ol type="1">
<li><code><a class="el" href="namespaceutils.html#a53f4a46843c0030ed1388d10c0ad6179" title="Swap 2 bytes of a 2-bytes integer.">utils::swap_bytes</a></code>: this function is useful whenever you use a sensor device that provides you with integer values, coded on 2 bytes, with high byte first and low byte second; since AVR MCU are "little-endian" processors, they expect words in the opposite order: low byte first, high byte second, hence in order to interpret values provided by that device, you need to first swap their bytes. Bytes swap is performed "in-place", i.e. the original value is replace with the converted value. The following example is an excerpt of <code><a class="el" href="hmc5883l_8h.html" title="API to handle HMC5883L 3-axis digital compass I2C chip.">hmc5883l.h</a></code> provided by FastArduino, where magnetic fields in 3 axes have to be converted from big endian (as provided by the HMC5883L) to little endian (as expected by the AVR MCU): <div class="fragment"><div class="line">    <span class="keyword">class </span>MagneticFieldsFuture : <span class="keyword">public</span> ReadRegisterFuture&lt;Sensor3D&gt;</div>
<div class="line">    {</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">        <span class="keywordtype">bool</span> get(Sensor3D&amp; fields)</div>
<div class="line">        {</div>
<div class="line">            <span class="keywordflow">if</span> (!PARENT::get(fields)) <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">            <a class="code" href="namespaceutils.html#a53f4a46843c0030ed1388d10c0ad6179">utils::swap_bytes</a>(fields.x);</div>
<div class="line">            <a class="code" href="namespaceutils.html#a53f4a46843c0030ed1388d10c0ad6179">utils::swap_bytes</a>(fields.y);</div>
<div class="line">            <a class="code" href="namespaceutils.html#a53f4a46843c0030ed1388d10c0ad6179">utils::swap_bytes</a>(fields.z);</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">        }</div>
<div class="line">    };</div>
</div><!-- fragment --></li>
<li><code><a class="el" href="namespaceutils.html#af5b3426ba48caf5ee96ed71fa8b7bb5e" title="Convert Binary-coded decimal byte (each nibble is a digit from 0 to 9) into a natural byte.">utils::bcd_to_binary</a></code>: this function is useful when you use a sensor device that provides values coded as <em>BCD</em> (binary-coded decimal), i.e. where each half-byte (<em>nibble</em>) contains the value of one digit (i.e. <code>0</code> to <code>9</code>), thus holding a range of values from <code>0</code> to <code>99</code>. Many RTC devices use BCD representation for time. In order to perform a calculation on BCD values, you need to first convert them to binary. The opposite function is also provided as <code><a class="el" href="namespaceutils.html#a76076365828136f5178f279fb3c129de" title="Convert a natural integers to a BCD byte (2 digits).">utils::binary_to_bcd</a></code>. The following example is an excerpt of <code><a class="el" href="ds1307_8h.html" title="API to handle Real-Time Clock DS1307 I2C chip.">ds1307.h</a></code> provided by FastArduino, where each datetime field (seconds, minutes, hours...) have to be converted from BCD to binary: <div class="fragment"><div class="line">    <span class="keyword">struct </span>set_tm</div>
<div class="line">    {</div>
<div class="line">        set_tm(<span class="keyword">const</span> tm&amp; datetime)</div>
<div class="line">        {</div>
<div class="line">            tm_.tm_sec = <a class="code" href="namespaceutils.html#a76076365828136f5178f279fb3c129de">utils::binary_to_bcd</a>(datetime.tm_sec);</div>
<div class="line">            tm_.tm_min = <a class="code" href="namespaceutils.html#a76076365828136f5178f279fb3c129de">utils::binary_to_bcd</a>(datetime.tm_min);</div>
<div class="line">            tm_.tm_hour = <a class="code" href="namespaceutils.html#a76076365828136f5178f279fb3c129de">utils::binary_to_bcd</a>(datetime.tm_hour);</div>
<div class="line">            tm_.tm_mday = <a class="code" href="namespaceutils.html#a76076365828136f5178f279fb3c129de">utils::binary_to_bcd</a>(datetime.tm_mday);</div>
<div class="line">            tm_.tm_mon = <a class="code" href="namespaceutils.html#a76076365828136f5178f279fb3c129de">utils::binary_to_bcd</a>(datetime.tm_mon);</div>
<div class="line">            tm_.tm_year = <a class="code" href="namespaceutils.html#a76076365828136f5178f279fb3c129de">utils::binary_to_bcd</a>(datetime.tm_year);</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        uint8_t address_ = TIME_ADDRESS;</div>
<div class="line">        tm tm_;</div>
<div class="line">    };</div>
</div><!-- fragment --></li>
</ol>
<h2>Conversion utilities examples</h2>
<p>Device sensors measure some physical quantity and generally provide you with some integer value that somehow maps to the physical value. hence to make use of the raw value provided by a sensor, you need to convert it to some more meaningful value that you can understand and operate upon.</p>
<p>Or conversely, you may just need to compare the physical value agains some thresholds (e.g. check the gyroscopic speed according to some axis is less than 10/s), and perform some action when this is not true. In this situation, you don't really need to convert the raw sensor value into a physical quantity to compare to the physical threshold, but rather convert (once only) the physical threshold into the corresponding raw value (a constant in your program) and then only compare raw values, which is:</p><ul>
<li>more performant (no conversion needed before comparison)</li>
<li>more size efficient (conversion of threshold can be done at compile time, hence no code is generated for it)</li>
</ul>
<p>FastArduino utilities provide several conversion methods between raw and physical quantities, according to raw and physical ranges (known for each sensor), and unit prefix (e.g. kilo, mega, giga, centi, milli...). These methods are <code>constexpr</code>, which means that, when provided with constant arguments, they will be evaluated at compile-time and return a value that is itself stored as a constant.</p>
<ol type="1">
<li><code><a class="el" href="namespaceutils.html#a78e8ff3db7671b59028ba873086cfa32" title="Convert an absolute physical value, expressed in some given measurement unit, scaled with prefix,...">utils::map_physical_to_raw</a></code>: although it may seem complicated by its list of arguments, this function is actually pretty simple, as demonstrated in the snippet hereafter: <div class="fragment"><div class="line">    <span class="keyword">static</span> constexpr <span class="keyword">const</span> int16_t ACCEL_1 = <a class="code" href="namespaceutils.html#a78e8ff3db7671b59028ba873086cfa32">map_physical_to_raw</a>(500, UnitPrefix::MILLI, 2, 15);</div>
</div><!-- fragment -->In this example, we convert the acceleration value 500mg (g is <em>9.81 m/s/s</em>) to the equivalent raw value as produced by an MPU-6050 accelerometer, using <em>+/-2g</em> range (<code>2</code> is the max physical value we can get with this device using this range) where this raw value is stored on <code>15 bits</code> (+1 bit for the sign), i.e. <code>32767</code> is the raw value returned by the device when the measured acceleration is <code>+2g</code>.</li>
<li><code><a class="el" href="namespaceutils.html#a610e02474f969fc747fa1725b79e252c" title="Convert the raw value, obtained from an electronics device, using precision_bit number of bits (that ...">utils::map_raw_to_physical</a></code>: this method does the exact opposite of <code><a class="el" href="namespaceutils.html#a78e8ff3db7671b59028ba873086cfa32" title="Convert an absolute physical value, expressed in some given measurement unit, scaled with prefix,...">utils::map_physical_to_raw</a></code> with the same parameters, reversed: <div class="fragment"><div class="line">    int16_t rotation = <a class="code" href="namespaceutils.html#a610e02474f969fc747fa1725b79e252c">map_raw_to_physical</a>(raw, UnitPrefix::CENTI, 250, 15);</div>
</div><!-- fragment -->In this example, we convert <code>raw</code> which is returned by the MPU-6050 gyroscope, using range <em>+/-250/s</em> with <code>15 bits</code> precision (+1 bit for the sign), i.e. <code>32767</code> is the raw value returned by the device when the measured rotation speed is <code>+250/s</code>. The calculated value is returned in <em>c/s</em> (centi-degrees per second).</li>
</ol>
<p>In addition to these functions, FastArduino utilities also include the more common <code><a class="el" href="namespaceutils.html#a608f8edf36fb4a7c58dd01232e07c0c8" title="Linearly transform value from range [input_min ; input_max] to range [output_min ; output_max].">utils::map</a></code> and <code><a class="el" href="namespaceutils.html#af1acb8c6f0e6493f88d42b2192e68ba3" title="Constrain value to be greater than or equal to min and lower than or equal to max.">utils::constrain</a></code> which work like their Arduino API equivalent <code><a class="el" href="namespaceutils.html#a608f8edf36fb4a7c58dd01232e07c0c8" title="Linearly transform value from range [input_min ; input_max] to range [output_min ; output_max].">map()</a></code> and <code><a class="el" href="namespaceutils.html#af1acb8c6f0e6493f88d42b2192e68ba3" title="Constrain value to be greater than or equal to min and lower than or equal to max.">constrain()</a></code>.</p>
<h1><a class="anchor" id="watchdog"></a>Advanced: Watchdog </h1>
<p>In general, a watchdog is a device (or part of a device) that is used to frequently check that a system is not hanging. AVR MCU include such a device and this can be programmed to other purposes than checking the system is alive, e.g. as a simple timer with low-power consumption. This is in that purpose that FastArduino defines a specific Watchdog API.</p>
<p>FastArduino defines 2 watchdog classes. The first one, <code>WatchdogSignal</code> allows you to generate watchdog timer interrupts at a given period. The following example is yet another way to blink a LED:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="preprocessor">#include &lt;<a class="code" href="gpio_8h.html">fastarduino/gpio.h</a>&gt;</span></div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;<span class="preprocessor">#include &lt;<a class="code" href="power_8h.html">fastarduino/power.h</a>&gt;</span></div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;<span class="preprocessor">#include &lt;<a class="code" href="watchdog_8h.html">fastarduino/watchdog.h</a>&gt;</span></div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160; </div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;<span class="comment">// Define vectors we need in the example</span></div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;<a class="code" href="watchdog_8h.html#adb4cc81538efc2536ee6e1d06ae4b92f">REGISTER_WATCHDOG_ISR_EMPTY</a>()</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160; </div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;int main() __attribute__((OS_main));</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;<span class="keywordtype">int</span> main()</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;{</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;    <a class="code" href="namespaceboard.html#a2529f85498783a75dc75c281e0b754d3">board::init</a>();</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;    sei();</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160; </div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;    <a class="code" href="namespacegpio.html#a3cbdad86ced6494ca615a425b433fd57">gpio::FAST_PIN&lt;board::DigitalPin::LED&gt;</a> led{<a class="code" href="namespacegpio.html#ae18fafd08668ee17aa5dd415ee3b6041a50a87f0d71f7221582dad4bf507a0f34">gpio::PinMode::OUTPUT</a>};</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160; </div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;    <a class="code" href="classwatchdog_1_1_watchdog_signal.html">watchdog::WatchdogSignal</a> <a class="code" href="namespacewatchdog.html">watchdog</a>;</div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;    <a class="code" href="namespacewatchdog.html">watchdog</a>.begin(watchdog::TimeOut::TO_500ms);</div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;    </div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;    <span class="keywordflow">while</span> (<span class="keyword">true</span>)</div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;    {</div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;        led.toggle();</div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;        <a class="code" href="classpower_1_1_power.html#a0bfb70818b6e364f8e6e0d5745ba254b">power::Power::sleep</a>(board::SleepMode::POWER_DOWN);</div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;    }</div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;}</div>
</div><!-- fragment --><p>In this example, we use <code>watchdog</code> API but also <code>power</code> API in order to reduce power-consumption.</p>
<p>As we use <code>WatchdogSignal</code>, we need to register an ISR, however we do not need any callback, hence we just register an empty ISR.  </p><div class="fragment"><div class="line"><a class="code" href="watchdog_8h.html#adb4cc81538efc2536ee6e1d06ae4b92f">REGISTER_WATCHDOG_ISR_EMPTY</a>()</div>
</div><!-- fragment --><p>Then we have the usual <code>main()</code> function which, after defining <code>led</code> output pin, starts the watchdog timer: </p><div class="fragment"><div class="line">    <a class="code" href="classwatchdog_1_1_watchdog_signal.html">watchdog::WatchdogSignal</a> <a class="code" href="namespacewatchdog.html">watchdog</a>;</div>
<div class="line">    <a class="code" href="namespacewatchdog.html">watchdog</a>.begin(watchdog::TimeOut::TO_500ms);</div>
</div><!-- fragment --><p> Here we use a 500ms timeout period, which means our sleeping code will be awakened every 500ms.</p>
<p>The infinite loop just toggles <code>led</code> pin level and goes to sleep: </p><div class="fragment"><div class="line">    <span class="keywordflow">while</span> (<span class="keyword">true</span>)</div>
<div class="line">    {</div>
<div class="line">        led.toggle();</div>
<div class="line">        <a class="code" href="classpower_1_1_power.html#a0bfb70818b6e364f8e6e0d5745ba254b">power::Power::sleep</a>(board::SleepMode::POWER_DOWN);</div>
<div class="line">    }</div>
</div><!-- fragment --><p> As explained <a class="el" href="tutorial.html#power">later</a>, <code>power::Power::sleep(board::SleepMode::POWER_DOWN)</code> just puts the MCU to sleep until some external interrupts wake it up; in our example, that interrupt is the watchdog timeout interrupt.</p>
<p>The size of this example is not much bigger than the first example of this tutorial:</p>
<p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"></th><th class="markdownTableHeadNone">FastArduino  </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">code size </td><td class="markdownTableBodyNone">190 bytes  </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">data size </td><td class="markdownTableBodyNone">0 byte  </td></tr>
</table>
 FastArduino defines another class, <code>Watchdog</code>. This class allows to use the AVR watchdog timer as a clock for events generation. This will be demonstrated when <a class="el" href="tutorial.html#events">events scheduling</a> is described.</p>
<h1><a class="anchor" id="interrupts"></a>Advanced: Interrupts </h1>
<h2>Introduction to AVR interrupts</h2>
<p>Many AVR MCU features are based upon interrupts, so that the MCU can efficiently react to events such as timer overflow, pin level change, without having to poll for these conditions. Using AVR interrupts makes your program responsive to events relevant to you. This also allows taking advantage of power sleep modes thus reducing energy consumption while the MCU has nothing to do other than wait for events to occur.</p>
<p>Each AVR MCU has a predefined list of interrupts sources, each individually activable, and each with an associated <em>vector</em> which is the address of an Interrupt Service Routine (<b>ISR</b>), executed whenever the matching interrupt occurs. Each ISR is imposed a specific name.</p>
<p>Among common interrupt vectors, you will find for example:</p><ul>
<li><code>TIMERn_OVF_vect</code>: triggered when Timer <em>n</em> overflows</li>
<li><code>INTn_vect</code>: triggered when input pin <em>INTn</em> changes level</li>
<li><code>UARTn_RX_vect</code>: triggered when a new character has been received on serial receiver <code>UARTn</code></li>
<li>...</li>
</ul>
<h2>AVR interrupts handling in FastArduino</h2>
<p>In FastArduino, ISR are created upon your explicit request, FastArduino will never add an ISR without your consent. FastArduino calls this ISR creation a <b>registration</b>.</p>
<p>ISR registration is performed through macros provided by FastArduino. There are essentially 4 flavours of registration macros:</p><ol type="1">
<li>API-specific registration: in this flavour, a FastArduino feature requires to directly be linked to an ISR, through a dedicated macro and a specific registration method (either implicitly called by constructor or explicitly through a specific method). In the previous examples of this tutorial, you have already encountered <code><a class="el" href="uart_8h.html#aa33c57bb6fa1e93177abb21fe8fecb10" title="Register the necessary ISR (Interrupt Service Routine) for an serial::hard::UATX to work correctly.">REGISTER_UATX_ISR()</a></code>, <code><a class="el" href="uart_8h.html#a4fed67375824a0fc63e21ecdb7ce0db0" title="Register the necessary ISR (Interrupt Service Routine) for an serial::hard::UARX to work correctly.">REGISTER_UARX_ISR()</a></code>, <code><a class="el" href="uart_8h.html#a8bd735d1a3a5a0a8e3253fd3f1720b29" title="Register the necessary ISR (Interrupt Service Routine) for an serial::hard::UART to work correctly.">REGISTER_UART_ISR()</a></code> and <code><a class="el" href="realtime__timer_8h.html#afc2dfeccc5d417ae872d836d4cfb5d8c" title="Register the necessary ISR (Interrupt Service Routine) for a timer::RTT to work properly.">REGISTER_RTT_ISR()</a></code>. All macros in this flavour follow the same naming scheme: <code>REGISTER_XXX_ISR</code>, where <em>XXX</em> is the feature handled.</li>
<li>Empty ISR registration: in this flavour, you activate an interrupt but do not want any callback for it, but then you have to define an empty ISR for it; this empty ISR will not increase code size of your program. You may wonder why you would want to enable an interrupt but do nothing when it occurs, in fact this is often used to make the MCU sleep (low power consumption) and wake it once an interrupt occurs. You have already seen such usage in a previous example, where <code><a class="el" href="watchdog_8h.html#adb4cc81538efc2536ee6e1d06ae4b92f" title="Register an empty ISR (Interrupt Service Routine) for a watchdog::WatchdogSignal.">REGISTER_WATCHDOG_ISR_EMPTY()</a></code> was used.</li>
<li>Method callback registration: with this flavour, you activate an interrupt and want a specific method of a given class to be called back when the interrupt occurs; in this flavour, a second step is required inside your code: you need to register an instance of the class that was registered. In this tutorial, previous examples used this approach with <code><a class="el" href="timer_8h.html#acfce0d4d6115510756da8d720409ed26" title="Register the necessary ISR (Interrupt Service Routine) for a timer::Timer with a callback method in C...">REGISTER_TIMER_COMPARE_ISR_METHOD()</a></code> macro and <code>interrupt::register_handler(handler);</code> instance registration in <code>main()</code>. This is probably the most useful approach as it allows to pass an implicit context (<code>this</code> class instance) to the callback.</li>
<li>Function callback registration: with this flavour, you can register one of your functions (global or static) as a callback of an ISR. This approach does not require an extra registration step. This is not used as often as the Method callback registration flavour above.</li>
</ol>
<p>Whenever method callback is needed (typically for flavours 1 and 3 above), then a second registration step is needed.</p>
<p>All FastArduino API respects some guidelines for naming ISR registration macros. All macros are in one of the following formats:</p><ul>
<li><code>REGISTER_XXX_ISR()</code> for API-specific registration</li>
<li><code>REGISTER_XXX_ISR_EMPTY()</code> for empty ISR</li>
<li><code>REGISTER_XXX_ISR_CALLBACK()</code> for method callback</li>
<li><code>REGISTER_XXX_ISR_FUNCTION()</code> for function callback</li>
</ul>
<p>Here is a table showing all FastArduino macros to register ISR (<em>Name</em> is to be replaced in macro name <code>REGISTER_NAME_ISR</code>, <code>REGISTER_NAME_ISR_EMPTY</code>, <code>REGISTER_NAME_ISR_CALLBACK</code> or <code>REGISTER_NAME_ISR_FUNCTION</code>): </p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Header  </th><th class="markdownTableHeadNone">Name  </th><th class="markdownTableHeadNone">Flavours  </th><th class="markdownTableHeadNone">Comments   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code><a class="el" href="analog__comparator_8h.html" title="Analog Comparator API.">analog_comparator.h</a></code>  </td><td class="markdownTableBodyNone"><code>ANALOG_COMPARE</code>  </td><td class="markdownTableBodyNone">2,3,4  </td><td class="markdownTableBodyNone">Called upon Analog Comparator interrupt.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code><a class="el" href="eeprom_8h.html" title="API to handle EEPROM access in read and write modes.">eeprom.h</a></code>  </td><td class="markdownTableBodyNone"><code>EEPROM</code>  </td><td class="markdownTableBodyNone">1,3,4  </td><td class="markdownTableBodyNone">Called when asynchronous EEPROM write is finished.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code><a class="el" href="int_8h.html" title="General API for handling External Interrupt pins.">int.h</a></code>  </td><td class="markdownTableBodyNone"><code>INT</code>  </td><td class="markdownTableBodyNone">2,3,4  </td><td class="markdownTableBodyNone">Called when an INT pin changes level.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code><a class="el" href="pci_8h.html" title="General API for handling Pin Change Interrupts.">pci.h</a></code>  </td><td class="markdownTableBodyNone"><code>PCI</code>  </td><td class="markdownTableBodyNone">2,3,4  </td><td class="markdownTableBodyNone">Called when a PCINT pin changes level.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code><a class="el" href="pulse__timer_8h.html" title="PulseTimer API.">pulse_timer.h</a></code>  </td><td class="markdownTableBodyNone"><code>PULSE_TIMER8_A</code>  </td><td class="markdownTableBodyNone">1  </td><td class="markdownTableBodyNone">Called when a PulseTimer8 overflows or equals OCRA.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code><a class="el" href="pulse__timer_8h.html" title="PulseTimer API.">pulse_timer.h</a></code>  </td><td class="markdownTableBodyNone"><code>PULSE_TIMER8_B</code>  </td><td class="markdownTableBodyNone">1  </td><td class="markdownTableBodyNone">Called when a PulseTimer8 overflows or equals OCRB.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code><a class="el" href="pulse__timer_8h.html" title="PulseTimer API.">pulse_timer.h</a></code>  </td><td class="markdownTableBodyNone"><code>PULSE_TIMER8_AB</code>  </td><td class="markdownTableBodyNone">1  </td><td class="markdownTableBodyNone">Called when a PulseTimer8 overflows or equals OCRA or OCRB.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code><a class="el" href="realtime__timer_8h.html" title="Real-time Timer API.">realtime_timer.h</a></code>  </td><td class="markdownTableBodyNone"><code>RTT</code>  </td><td class="markdownTableBodyNone">1,3,4  </td><td class="markdownTableBodyNone">Called when RTT timer has one more millisecond elapsed.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code><a class="el" href="realtime__timer_8h.html" title="Real-time Timer API.">realtime_timer.h</a></code>  </td><td class="markdownTableBodyNone"><code>RTT_EVENT</code>  </td><td class="markdownTableBodyNone">1  </td><td class="markdownTableBodyNone">Same as above, and trigger RTTEventCallback.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code><a class="el" href="soft__uart_8h.html" title="Software-emulated serial API.">soft_uart.h</a></code>  </td><td class="markdownTableBodyNone"><code>UART_PCI</code>  </td><td class="markdownTableBodyNone">1  </td><td class="markdownTableBodyNone">Called when a start bit is received on a PCINT pin linked to UATX.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code><a class="el" href="soft__uart_8h.html" title="Software-emulated serial API.">soft_uart.h</a></code>  </td><td class="markdownTableBodyNone"><code>UART_INT</code>  </td><td class="markdownTableBodyNone">1  </td><td class="markdownTableBodyNone">Called when a start bit is received on an INT pin linked to UATX.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code><a class="el" href="timer_8h.html" title="Timer API.">timer.h</a></code>  </td><td class="markdownTableBodyNone"><code>COMPARE</code>  </td><td class="markdownTableBodyNone">2,3,4  </td><td class="markdownTableBodyNone">Called when a Timer counter reaches OCRA.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code><a class="el" href="timer_8h.html" title="Timer API.">timer.h</a></code>  </td><td class="markdownTableBodyNone"><code>OVERFLOW</code>  </td><td class="markdownTableBodyNone">2,3,4  </td><td class="markdownTableBodyNone">Called when a Timer counter overflows.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code><a class="el" href="timer_8h.html" title="Timer API.">timer.h</a></code>  </td><td class="markdownTableBodyNone"><code>CAPTURE</code>  </td><td class="markdownTableBodyNone">2,3,4  </td><td class="markdownTableBodyNone">Called when a Timer counter gets captured (when ICP level changes).   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code><a class="el" href="uart_8h.html" title="Hardware serial API.">uart.h</a></code>  </td><td class="markdownTableBodyNone"><code>UATX</code>  </td><td class="markdownTableBodyNone">1  </td><td class="markdownTableBodyNone">Called when one character is finished transmitted on UATX.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code><a class="el" href="uart_8h.html" title="Hardware serial API.">uart.h</a></code>  </td><td class="markdownTableBodyNone"><code>UARX</code>  </td><td class="markdownTableBodyNone">1  </td><td class="markdownTableBodyNone">Called when one character is finished received on UARX.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code><a class="el" href="uart_8h.html" title="Hardware serial API.">uart.h</a></code>  </td><td class="markdownTableBodyNone"><code>UART</code>  </td><td class="markdownTableBodyNone">1  </td><td class="markdownTableBodyNone">Called when one character is finished transmitted/received on UART.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code><a class="el" href="watchdog_8h.html" title="Watchdog API.">watchdog.h</a></code>  </td><td class="markdownTableBodyNone"><code>WATCHDOG_CLOCK</code>  </td><td class="markdownTableBodyNone">1  </td><td class="markdownTableBodyNone">Called when Watchdog timeout occurs, and clock must be updated.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code><a class="el" href="watchdog_8h.html" title="Watchdog API.">watchdog.h</a></code>  </td><td class="markdownTableBodyNone"><code>WATCHDOG_RTT</code>  </td><td class="markdownTableBodyNone">1  </td><td class="markdownTableBodyNone">Called when Watchdog timeout occurs, and RTT clock must be updated.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code><a class="el" href="watchdog_8h.html" title="Watchdog API.">watchdog.h</a></code>  </td><td class="markdownTableBodyNone"><code>WATCHDOG</code>  </td><td class="markdownTableBodyNone">2,3,4  </td><td class="markdownTableBodyNone">Called when WatchdogSignal timeout occurs.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code><a class="el" href="i2c__handler__atmega_8h.html" title="ATmega I2C Manager API.">i2c_handler_atmega.h</a></code>  </td><td class="markdownTableBodyNone"><code>I2C</code>  </td><td class="markdownTableBodyNone">1,3,4  </td><td class="markdownTableBodyNone">Called when I2C status changes (ATmega only).   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code><a class="el" href="sonar_8h.html" title="API to handle ultrasonic distance rangers (aka &quot;sonar&quot;) such as the HC-SR04.">devices/sonar.h</a></code>  </td><td class="markdownTableBodyNone"><code>HCSR04_INT</code>  </td><td class="markdownTableBodyNone">1,3,4  </td><td class="markdownTableBodyNone">Called when HCSR04 echo INT pin changes level.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code><a class="el" href="sonar_8h.html" title="API to handle ultrasonic distance rangers (aka &quot;sonar&quot;) such as the HC-SR04.">devices/sonar.h</a></code>  </td><td class="markdownTableBodyNone"><code>HCSR04_PCI</code>  </td><td class="markdownTableBodyNone">1,3,4  </td><td class="markdownTableBodyNone">Called when HCSR04 echo PCINT pin changes level.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code><a class="el" href="sonar_8h.html" title="API to handle ultrasonic distance rangers (aka &quot;sonar&quot;) such as the HC-SR04.">devices/sonar.h</a></code>  </td><td class="markdownTableBodyNone"><code>HCSR04_RTT_TIMEOUT</code>  </td><td class="markdownTableBodyNone">1,3,4  </td><td class="markdownTableBodyNone">Called when HCSR04 RTT times out (without any echo).   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code><a class="el" href="sonar_8h.html" title="API to handle ultrasonic distance rangers (aka &quot;sonar&quot;) such as the HC-SR04.">devices/sonar.h</a></code>  </td><td class="markdownTableBodyNone"><code>DISTINCT_HCSR04_PCI</code>  </td><td class="markdownTableBodyNone">1  </td><td class="markdownTableBodyNone">Called when HCSR04 any echo PCINT pin changes level.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code><a class="el" href="sonar_8h.html" title="API to handle ultrasonic distance rangers (aka &quot;sonar&quot;) such as the HC-SR04.">devices/sonar.h</a></code>  </td><td class="markdownTableBodyNone"><code>MULTI_HCSR04_PCI</code>  </td><td class="markdownTableBodyNone">3,4  </td><td class="markdownTableBodyNone">Called when MultiHCSR04 any echo PCINT pin changes level.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code><a class="el" href="sonar_8h.html" title="API to handle ultrasonic distance rangers (aka &quot;sonar&quot;) such as the HC-SR04.">devices/sonar.h</a></code>  </td><td class="markdownTableBodyNone"><code>MULTI_HCSR04_RTT_TIMEOUT</code>  </td><td class="markdownTableBodyNone">1,3,4  </td><td class="markdownTableBodyNone">Called when MultiHCSR04 RTT times out (without any echo).   </td></tr>
</table>
<p>For further details on ISR registration in FastArduino, you can check <a href="interrupts_8h.html"><code>interrutps.h</code> API</a> for the general approach, and each individual API documentation for specific interrupts.</p>
<h2>Pin Interrupts</h2>
<p>One very common usage of AVR interrupts is to handle level changes of specific digital input pins. AVR MCU have two kinds of pin interrupts:</p><ul>
<li>External Interrupts: an interrupt can be triggered for a specific pin when its level changes or is equal to some value (high or low); the number of such pins is quite limited (e.g. only 2 on Arduino UNO)</li>
<li>Pin Change Interrupts: an interrupt is triggered when one in a set of pins has a changing level; the same interrupt (hence the same ISR) is used for all pins (typically 8, but not necessarily), thus the ISR must determine, by its own means, which pin has triggered the interrupt; although more pins support this interrupt, it is less convenient to use than external interrupts.</li>
</ul>
<h3>External Interrupts</h3>
<p>External Interrupts are handled with the API provided by <code><a class="el" href="int_8h.html" title="General API for handling External Interrupt pins.">int.h</a></code>. This API is demonstrated in the example below:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="preprocessor">#include &lt;<a class="code" href="gpio_8h.html">fastarduino/gpio.h</a>&gt;</span></div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;<span class="preprocessor">#include &lt;<a class="code" href="int_8h.html">fastarduino/int.h</a>&gt;</span></div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;<span class="preprocessor">#include &lt;<a class="code" href="power_8h.html">fastarduino/power.h</a>&gt;</span></div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160; </div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;constexpr <span class="keyword">const</span> <a class="code" href="namespaceboard.html#adea66670db50b076b2c145657aa587f7">board::ExternalInterruptPin</a> SWITCH = board::ExternalInterruptPin::D2_PD2_EXT0;</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160; </div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;<span class="keyword">class </span>PinChangeHandler</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;{</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;<span class="keyword">public</span>:</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;    PinChangeHandler():_switch{gpio::PinMode::INPUT_PULLUP}, _led{<a class="code" href="namespacegpio.html#ae18fafd08668ee17aa5dd415ee3b6041a50a87f0d71f7221582dad4bf507a0f34">gpio::PinMode::OUTPUT</a>} {}</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;    </div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;    <span class="keywordtype">void</span> on_pin_change()</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;    {</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;        <span class="keywordflow">if</span> (_switch.value())</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;            _led.clear();</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;        <span class="keywordflow">else</span></div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;            _led.set();</div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;    }</div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;    </div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;<span class="keyword">private</span>:</div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;    <a class="code" href="namespacegpio.html#a78705a6beb0840892d7f8f52d0f32bec">gpio::FAST_EXT_PIN&lt;SWITCH&gt;</a> _switch;</div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;    <a class="code" href="namespacegpio.html#a3cbdad86ced6494ca615a425b433fd57">gpio::FAST_PIN&lt;board::DigitalPin::LED&gt;</a> _led;    </div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;};</div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160; </div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;<span class="comment">// Define vectors we need in the example</span></div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;<a class="code" href="int_8h.html#a3e2a8c98468d29717612f7c694a17d59">REGISTER_INT_ISR_METHOD</a>(0, SWITCH, PinChangeHandler, &amp;PinChangeHandler::on_pin_change)</div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160; </div>
<div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;<span class="keywordtype">int</span> main() __attribute__((OS_main));</div>
<div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;<span class="keywordtype">int</span> main()</div>
<div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;{</div>
<div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;    <a class="code" href="namespaceboard.html#a2529f85498783a75dc75c281e0b754d3">board::init</a>();</div>
<div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;    <span class="comment">// Enable interrupts at startup time</span></div>
<div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;    sei();</div>
<div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;    </div>
<div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;    PinChangeHandler handler;</div>
<div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;    <a class="code" href="namespaceinterrupt.html#abfd5857208f49006bde8c472497273de">interrupt::register_handler</a>(handler);</div>
<div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;    <a class="code" href="classinterrupt_1_1_i_n_t_signal.html">interrupt::INTSignal&lt;SWITCH&gt;</a> int0{interrupt::InterruptTrigger::ANY_CHANGE};</div>
<div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;    int0.<a class="code" href="classinterrupt_1_1_i_n_t_signal.html#aba283975bf5d335fccc927f217305e85">enable</a>();</div>
<div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160; </div>
<div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;    <span class="comment">// Event Loop</span></div>
<div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;    <span class="keywordflow">while</span> (<span class="keyword">true</span>)</div>
<div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;    {</div>
<div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;        <a class="code" href="classpower_1_1_power.html#a0bfb70818b6e364f8e6e0d5745ba254b">power::Power::sleep</a>(board::SleepMode::POWER_DOWN);</div>
<div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;    }</div>
<div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;}</div>
</div><!-- fragment --><p>In this example, most of the MCU time is spent sleeping in power down mode. The pin <code>INT0</code> (D2 on UNO) is connected to a push button and used to switch on or off the UNO LED (on D13).</p>
<p>Note how the button pin is defined:  </p><div class="fragment"><div class="line">constexpr <span class="keyword">const</span> <a class="code" href="namespaceboard.html#adea66670db50b076b2c145657aa587f7">board::ExternalInterruptPin</a> SWITCH = board::ExternalInterruptPin::D2_PD2_EXT0;</div>
</div><!-- fragment --><p> Here we use <code><a class="el" href="namespaceboard.html#adea66670db50b076b2c145657aa587f7" title="Defines all digital output pins of target MCU, usable as direct external interrupt pins.">board::ExternalInterruptPin</a></code> enum to find out the possible pins that can be used as External Interrupt pins.</p>
<p>Then we define the class that will handle interrupts occurring when the button pin changes level: </p><div class="fragment"><div class="line"><span class="keyword">class </span>PinChangeHandler</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    PinChangeHandler():_switch{gpio::PinMode::INPUT_PULLUP}, _led{<a class="code" href="namespacegpio.html#ae18fafd08668ee17aa5dd415ee3b6041a50a87f0d71f7221582dad4bf507a0f34">gpio::PinMode::OUTPUT</a>} {}</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> on_pin_change()</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">if</span> (_switch.value())</div>
<div class="line">            _led.clear();</div>
<div class="line">        <span class="keywordflow">else</span></div>
<div class="line">            _led.set();</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <a class="code" href="namespacegpio.html#a78705a6beb0840892d7f8f52d0f32bec">gpio::FAST_EXT_PIN&lt;SWITCH&gt;</a> _switch;</div>
<div class="line">    <a class="code" href="namespacegpio.html#a3cbdad86ced6494ca615a425b433fd57">gpio::FAST_PIN&lt;board::DigitalPin::LED&gt;</a> _led;    </div>
<div class="line">};</div>
</div><!-- fragment --><p> The interesting code here is the <code>on_pin_change()</code> method which be called back when the button is pushed or relaxed, i.e. on any level change. Since this method is called whatever the new pin level, it must explicitly check the button status (i.e. the pin level) to set the right output for the LED pin. Note that, since we use <code>gpio::PinMode::INPUT_PULLUP</code>, the pin value will be <code>false</code> when the button is pushed, and <code>true</code> when it is not.</p>
<p>The next line of code registers <code>PinChangeHandler</code> class and <code>on_pin_change()</code> method as callback for <code>INT0</code> interrupt. </p><div class="fragment"><div class="line"><a class="code" href="int_8h.html#a3e2a8c98468d29717612f7c694a17d59">REGISTER_INT_ISR_METHOD</a>(0, SWITCH, PinChangeHandler, &amp;PinChangeHandler::on_pin_change)</div>
</div><!-- fragment --><p> In addition to the class and method, the macro takes the number of the <code>INT</code> interrupt (<code>0</code>) and the pin connected to this interrupt. Note that the pin reference is redundant; it is passed as a way to ensure that the provided <code>INT</code> number matches the pin that we use, if it doesn't, then your code will not compile.</p>
<p>Then the <code>main()</code> function oincludes the following initialization code: </p><div class="fragment"><div class="line">    PinChangeHandler handler;</div>
<div class="line">    <a class="code" href="namespaceinterrupt.html#abfd5857208f49006bde8c472497273de">interrupt::register_handler</a>(handler);</div>
<div class="line">    <a class="code" href="classinterrupt_1_1_i_n_t_signal.html">interrupt::INTSignal&lt;SWITCH&gt;</a> int0{interrupt::InterruptTrigger::ANY_CHANGE};</div>
<div class="line">    int0.<a class="code" href="classinterrupt_1_1_i_n_t_signal.html#aba283975bf5d335fccc927f217305e85">enable</a>();</div>
</div><!-- fragment --><p> Once the interrupt handler has been instantiated, it must be registered (2nd step of method callback registration). Then an <code>INTSignal</code> is created for <code>INT0</code> and it is set for any level change of the pin. Finally, the interrupt is activated.</p>
<p>Note the infinite loop in <code>main()</code>: </p><div class="fragment"><div class="line">    <span class="keywordflow">while</span> (<span class="keyword">true</span>)</div>
<div class="line">    {</div>
<div class="line">        <a class="code" href="classpower_1_1_power.html#a0bfb70818b6e364f8e6e0d5745ba254b">power::Power::sleep</a>(board::SleepMode::POWER_DOWN);</div>
<div class="line">    }</div>
</div><!-- fragment --><p> With this loop, we set the MCU to sleep in lowest energy consumption mode. Only some interrupts (<code>INT0</code> is one of them) will awaken the MCU from its sleep, immediately after the matching ISR has been called.</p>
<p>Here is the equivalent example with Arduino API:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;#include &lt;avr/sleep.h&gt;</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160; </div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;void onPinChange()</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;{</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    digitalWrite(LED_BUILTIN, !digitalRead(2));</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;}</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160; </div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;void setup()</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;{</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;    pinMode(LED_BUILTIN, OUTPUT);</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;    pinMode(2, INPUT_PULLUP);</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;    attachInterrupt(digitalPinToInterrupt(2), onPinChange, CHANGE);</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;}</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160; </div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;void loop()</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;{</div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;    sleep_enable();</div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;    set_sleep_mode(SLEEP_MODE_PWR_DOWN);</div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;    sleep_cpu();</div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;}</div>
</div><!-- fragment --><p>First note that Arduino API has no API for sleep mode management, hence you have to include <code>&lt;avr/sleep.h&gt;</code> and handle all this by yourself. Also note that you can only attach a function to an interrupt. Arduino API offers no way to attach a class member instead.</p>
<p>Now let's just compare examples sizes, as usual:</p>
<p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"></th><th class="markdownTableHeadNone">Arduino API </th><th class="markdownTableHeadNone">FastArduino  </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">code size </td><td class="markdownTableBodyNone">1114 bytes </td><td class="markdownTableBodyNone">246 bytes  </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">data size </td><td class="markdownTableBodyNone">13 bytes </td><td class="markdownTableBodyNone">2 bytes  </td></tr>
</table>
</p>
<h3>Pin Change Interrupts</h3>
<p>Pin Change Interrupts are handled with the API provided by <code><a class="el" href="pci_8h.html" title="General API for handling Pin Change Interrupts.">pci.h</a></code>. This API is demonstrated in the example below:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="preprocessor">#include &lt;<a class="code" href="gpio_8h.html">fastarduino/gpio.h</a>&gt;</span></div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;<span class="preprocessor">#include &lt;<a class="code" href="pci_8h.html">fastarduino/pci.h</a>&gt;</span></div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;<span class="preprocessor">#include &lt;<a class="code" href="power_8h.html">fastarduino/power.h</a>&gt;</span></div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160; </div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;constexpr <span class="keyword">const</span> <a class="code" href="namespaceboard.html#a7abd24b042402c0691c0ad6db604e7da">board::InterruptPin</a> SWITCH = board::InterruptPin::D14_PC0_PCI1;</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;<span class="preprocessor">#define PCI_NUM 1</span></div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160; </div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;<span class="keyword">class </span>PinChangeHandler</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;{</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;<span class="keyword">public</span>:</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;    PinChangeHandler():_switch{gpio::PinMode::INPUT_PULLUP}, _led{<a class="code" href="namespacegpio.html#ae18fafd08668ee17aa5dd415ee3b6041a50a87f0d71f7221582dad4bf507a0f34">gpio::PinMode::OUTPUT</a>} {}</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;    </div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;    <span class="keywordtype">void</span> on_pin_change()</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;    {</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;        <span class="keywordflow">if</span> (_switch.value())</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;            _led.clear();</div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;        <span class="keywordflow">else</span></div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;            _led.set();</div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;    }</div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;    </div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;<span class="keyword">private</span>:</div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;    <a class="code" href="namespacegpio.html#aaa6f9e5f023592cc0692da0bb37deccd">gpio::FAST_INT_PIN&lt;SWITCH&gt;</a> _switch;</div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;    <a class="code" href="namespacegpio.html#a3cbdad86ced6494ca615a425b433fd57">gpio::FAST_PIN&lt;board::DigitalPin::LED&gt;</a> _led;    </div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;};</div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160; </div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;<span class="comment">// Define vectors we need in the example</span></div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;<a class="code" href="pci_8h.html#a64be10f04dd31643ee243b564a0d910c">REGISTER_PCI_ISR_METHOD</a>(PCI_NUM, PinChangeHandler, &amp;PinChangeHandler::on_pin_change, SWITCH)</div>
<div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160; </div>
<div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;<span class="keywordtype">int</span> main() __attribute__((OS_main));</div>
<div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;<span class="keywordtype">int</span> main()</div>
<div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;{</div>
<div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;    <a class="code" href="namespaceboard.html#a2529f85498783a75dc75c281e0b754d3">board::init</a>();</div>
<div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;    <span class="comment">// Enable interrupts at startup time</span></div>
<div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;    sei();</div>
<div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;    </div>
<div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;    PinChangeHandler handler;</div>
<div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;    <a class="code" href="namespaceinterrupt.html#abfd5857208f49006bde8c472497273de">interrupt::register_handler</a>(handler);</div>
<div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;    <a class="code" href="namespaceinterrupt.html#a440f2d705bc60755a4f81a105caef15c">interrupt::PCI_SIGNAL&lt;SWITCH&gt;</a> pci;</div>
<div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;    </div>
<div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;    pci.enable_pin&lt;SWITCH&gt;();</div>
<div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;    pci.enable();</div>
<div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160; </div>
<div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;    <span class="comment">// Event Loop</span></div>
<div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;    <span class="keywordflow">while</span> (<span class="keyword">true</span>)</div>
<div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;    {</div>
<div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;        <a class="code" href="classpower_1_1_power.html#a0bfb70818b6e364f8e6e0d5745ba254b">power::Power::sleep</a>(board::SleepMode::POWER_DOWN);</div>
<div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;    }</div>
<div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;}</div>
</div><!-- fragment --><p>This example performs the same as the previous example except it uses another pin for the button. Most of the code is similar, hence we will focus only on differences.</p>
<p>The first difference is in the way we define the pin to use as interrupt source:  </p><div class="fragment"><div class="line">constexpr <span class="keyword">const</span> <a class="code" href="namespaceboard.html#a7abd24b042402c0691c0ad6db604e7da">board::InterruptPin</a> SWITCH = board::InterruptPin::D14_PC0_PCI1;</div>
<div class="line"><span class="preprocessor">#define PCI_NUM 1</span></div>
</div><!-- fragment --><p> Here we use <code><a class="el" href="namespaceboard.html#a7abd24b042402c0691c0ad6db604e7da" title="Defines all digital output pins of target MCU, usable as pin change interrupt (PCI) pins.">board::InterruptPin</a></code> enum to find out the possible pins that can be used as Pin Change Interrupt pins. We select pin D14 and see from its name that is belonging to <code>PCINT1</code> interrupt vector. We also define the <code>PCINT</code> number as a constant, <code>PCI_NUM</code>, for later use.</p>
<p>Then we register <code>PinChangeHandler</code> class and <code>on_pin_change()</code> method as callback for <code>PCINT1</code> interrupt. </p><div class="fragment"><div class="line"><a class="code" href="pci_8h.html#a64be10f04dd31643ee243b564a0d910c">REGISTER_PCI_ISR_METHOD</a>(PCI_NUM, PinChangeHandler, &amp;PinChangeHandler::on_pin_change, SWITCH)</div>
</div><!-- fragment --><p>Once we have, as before,registered our handler class, we then create a <code>PCISignal</code> instance that we will use to activate the proper interrupt: </p><div class="fragment"><div class="line">    <a class="code" href="namespaceinterrupt.html#a440f2d705bc60755a4f81a105caef15c">interrupt::PCI_SIGNAL&lt;SWITCH&gt;</a> pci;</div>
<div class="line">    </div>
<div class="line">    pci.enable_pin&lt;SWITCH&gt;();</div>
<div class="line">    pci.enable();</div>
</div><!-- fragment --><p> Note that we use the useful template alias <code>PCI_SIGNAL</code> to find the proper <code>PCISignal</code> directly from the <code><a class="el" href="namespaceboard.html#a7abd24b042402c0691c0ad6db604e7da" title="Defines all digital output pins of target MCU, usable as pin change interrupt (PCI) pins.">board::InterruptPin</a></code>.</p>
<p>Before enabling the <code>PCINT1</code> interrupt, we need to first indicate that we are only interested in changes of the button pin.</p>
<p>For this example, we cannot compare sizes with the Arduino API equivalent because Pin Change Interrupts are not supported by the API.</p>
<h1><a class="anchor" id="events"></a>Advanced: Events, Scheduler </h1>
<p>FastArduino supports (and even encourages) events-driven programming, where events are generally generated and queued by interrupts (timer, pin changes, watchdog...) but not only, and events are then dequeued in an infinite loop (named the "event loop") in <code>main()</code>.</p>
<p>This way of programming allows short handling of interrupts in ISR (important because interrupts are disabled during ISR execution), and defer long tasks execution to the event loop.</p>
<h2>Events API</h2>
<p>We will use the following example to explain the general Event API:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="preprocessor">#include &lt;<a class="code" href="gpio_8h.html">fastarduino/gpio.h</a>&gt;</span></div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;<span class="preprocessor">#include &lt;<a class="code" href="pci_8h.html">fastarduino/pci.h</a>&gt;</span></div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;<span class="preprocessor">#include &lt;<a class="code" href="events_8h.html">fastarduino/events.h</a>&gt;</span></div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;<span class="preprocessor">#include &lt;<a class="code" href="time_8h.html">fastarduino/time.h</a>&gt;</span></div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160; </div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;<span class="preprocessor">#define PCI_NUM 2</span></div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;<span class="keyword">static</span> constexpr <span class="keyword">const</span> <a class="code" href="namespaceboard.html#a151323e5de5adf93f6bcdfdd64fa1eb1">board::Port</a> BUTTONS_PORT = board::Port::PORT_D;</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;<span class="keyword">static</span> constexpr <span class="keyword">const</span> <a class="code" href="namespaceboard.html#a5082846fef8fdfb8c8cbcf1163c7b404">board::DigitalPin</a> LED = board::DigitalPin::LED;</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160; </div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;<span class="keyword">using namespace </span><a class="code" href="namespaceevents.html">events</a>;</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160; </div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;<span class="keyword">using</span> EVENT = <a class="code" href="classevents_1_1_event.html">Event&lt;uint8_t&gt;</a>;</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;<span class="keyword">static</span> constexpr <span class="keyword">const</span> uint8_t BUTTON_EVENT = <a class="code" href="namespaceevents_1_1_type.html#a4c0afb748726e34daf4c20c27c0e0165">Type::USER_EVENT</a>;</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160; </div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;<span class="comment">// Class handling PCI interrupts and transforming them into events</span></div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;<span class="keyword">class </span>EventGenerator</div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;{</div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;<span class="keyword">public</span>:</div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;    EventGenerator(<a class="code" href="classcontainers_1_1_queue.html">containers::Queue&lt;EVENT&gt;</a>&amp; event_queue):event_queue_{event_queue}, buttons_{0x00, 0xFF} {}</div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160; </div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;    <span class="keywordtype">void</span> on_pin_change()</div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;    {</div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;        event_queue_.<a class="code" href="classcontainers_1_1_queue.html#ae506aa92e594cbac6f338c2b65d1e3b6">push_</a>(EVENT{BUTTON_EVENT, buttons_.get_PIN()});</div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;    }</div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160; </div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;<span class="keyword">private</span>:</div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;    <a class="code" href="classcontainers_1_1_queue.html">containers::Queue&lt;EVENT&gt;</a>&amp; event_queue_;</div>
<div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;    <a class="code" href="classgpio_1_1_fast_port.html">gpio::FastPort&lt;BUTTONS_PORT&gt;</a> buttons_;</div>
<div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;};</div>
<div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160; </div>
<div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;<a class="code" href="pci_8h.html#a64be10f04dd31643ee243b564a0d910c">REGISTER_PCI_ISR_METHOD</a>(PCI_NUM, EventGenerator, &amp;EventGenerator::on_pin_change, board::InterruptPin::D0_PD0_PCI2)</div>
<div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160; </div>
<div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;<span class="keywordtype">void</span> blink(uint8_t buttons)</div>
<div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;{</div>
<div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;    <span class="comment">// If no button is pressed, do nothing</span></div>
<div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;    <span class="keywordflow">if</span> (!buttons) <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160; </div>
<div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;    <a class="code" href="namespacegpio.html#a3cbdad86ced6494ca615a425b433fd57">gpio::FAST_PIN&lt;LED&gt;</a> led;</div>
<div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;    <span class="comment">// Buttons are plit in 2 groups of four:</span></div>
<div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;    <span class="comment">// - 1st group sets 5 iterations</span></div>
<div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;    <span class="comment">// - 2nd group sets 10 iterations</span></div>
<div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;    <span class="comment">// Note: we multiply by 2 because one blink iteration means toggling the LED twice</span></div>
<div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;    uint8_t iterations = (buttons &amp; 0x0F ? 5 : 10) * 2;</div>
<div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;    <span class="comment">// In each group, each buttons define the delay between LED toggles</span></div>
<div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;    <span class="comment">// - 1st/5th button: 200ms</span></div>
<div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;    <span class="comment">// - 2nd/6th button: 400ms</span></div>
<div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;    <span class="comment">// - 3rd/7th button: 800ms</span></div>
<div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;    <span class="comment">// - 4th/8th button: 1600ms</span></div>
<div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;    uint16_t <a class="code" href="namespacetime.html#af1e59bdf7c41bd8ff215d69a769a89bf">delay</a> = (buttons &amp; 0x11 ? 200 : buttons &amp; 0x22 ? 400 : buttons &amp; 0x44 ? 800 : 1600);</div>
<div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;    <span class="keywordflow">while</span> (iterations--)</div>
<div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;    {</div>
<div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;        led.toggle();</div>
<div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;        <a class="code" href="namespacetime.html#af13fd17ddf6b751b8161691e608892b2">time::delay_ms</a>(<a class="code" href="namespacetime.html#af1e59bdf7c41bd8ff215d69a769a89bf">delay</a>);</div>
<div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;    }</div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;}</div>
<div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160; </div>
<div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;<span class="keyword">static</span> <span class="keyword">const</span> uint8_t EVENT_QUEUE_SIZE = 32;</div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160; </div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;<span class="keywordtype">int</span> main() __attribute__((OS_main));</div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;<span class="keywordtype">int</span> main()</div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;{</div>
<div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;    <a class="code" href="namespaceboard.html#a2529f85498783a75dc75c281e0b754d3">board::init</a>();</div>
<div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160; </div>
<div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;    <span class="comment">// Prepare event queue</span></div>
<div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;    EVENT buffer[EVENT_QUEUE_SIZE];</div>
<div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;    <a class="code" href="classcontainers_1_1_queue.html">containers::Queue&lt;EVENT&gt;</a> event_queue{buffer};</div>
<div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160; </div>
<div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;    <span class="comment">// Create and register event generator</span></div>
<div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;    EventGenerator generator{event_queue};</div>
<div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;    <a class="code" href="namespaceinterrupt.html#abfd5857208f49006bde8c472497273de">interrupt::register_handler</a>(generator);</div>
<div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160; </div>
<div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;    <span class="comment">// Setup PCI interrupts</span></div>
<div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;    <a class="code" href="classinterrupt_1_1_p_c_i_signal.html">interrupt::PCISignal&lt;PCI_NUM&gt;</a> signal;</div>
<div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;    signal.<a class="code" href="classinterrupt_1_1_p_c_i_signal.html#a7a116409c3029a4d5b869bf68e1fde14">enable_pins_</a>(0xFF);</div>
<div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;    signal.<a class="code" href="classinterrupt_1_1_p_c_i_signal.html#a91c747b1d70bcf54889698401b90f21b">enable_</a>();</div>
<div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160; </div>
<div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;    <span class="comment">// Setup LED pin as output</span></div>
<div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;    <a class="code" href="namespacegpio.html#a3cbdad86ced6494ca615a425b433fd57">gpio::FAST_PIN&lt;LED&gt;</a> led{<a class="code" href="namespacegpio.html#ae18fafd08668ee17aa5dd415ee3b6041a50a87f0d71f7221582dad4bf507a0f34">gpio::PinMode::OUTPUT</a>};</div>
<div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160; </div>
<div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;    <span class="comment">// Enable interrupts at startup time</span></div>
<div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;    sei();</div>
<div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160; </div>
<div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;    <span class="comment">// Event Loop</span></div>
<div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;    <span class="keywordflow">while</span> (<span class="keyword">true</span>)</div>
<div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;    {</div>
<div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;        EVENT <span class="keyword">event</span> = <a class="code" href="namespacecontainers.html#ad31e49a84cd01e80e5c66859820ca8c9">containers::pull</a>(event_queue);</div>
<div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;        <span class="keywordflow">if</span> (event.type() == BUTTON_EVENT)</div>
<div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;            <span class="comment">// Invert levels as 0 means button pushed (and we want 1 instead)</span></div>
<div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;            blink(event.value() ^ 0xFF);</div>
<div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;    }</div>
<div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;    <span class="keywordflow">return</span> 0;</div>
<div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;}</div>
</div><!-- fragment --><p>In this example, 8 buttons are connected to one port and generate Pin Change Interrupts when pressed. The registered ISR generates an event for each pin change; the main event loop pulls one event from the events queue and starts a blinking sequence of the LED connected to D13 (Arduino UNO); the selected sequence (number of blinks and delay between blinks) depends on the pressed button.</p>
<p>First off, you need to include the heeader with FastArduino Events API:  </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="events_8h.html">fastarduino/events.h</a>&gt;</span></div>
</div><!-- fragment --><p>Then we will be using <code>namespace events</code> in our example: </p><div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceevents.html">events</a>;</div>
</div><!-- fragment --><p>Events API defines <code>template&lt;typename T&gt; class Event&lt;T&gt;</code> which basically contains 2 properties:</p><ul>
<li><code>type()</code> which is an <code>uint8_t</code> value used to discriminate different event types. FastArduino predefines a few event types and enables you to define your own types as you need,</li>
<li><code>value()</code> is a <code>T</code> instance which you can use any way you need; each event will transport such a value. If you do not need any additional information on your own events, then you can use <code>void</code> for <code>T</code>.</li>
</ul>
<p>In the example, we use events to transport the state of all 8 buttons (as a <code>uint8_t</code>): </p><div class="fragment"><div class="line"><span class="keyword">using</span> EVENT = Event&lt;uint8_t&gt;;</div>
</div><!-- fragment --><p>We also define a specific event type when buttons state changes: </p><div class="fragment"><div class="line"><span class="keyword">static</span> constexpr <span class="keyword">const</span> uint8_t BUTTON_EVENT = <a class="code" href="namespaceevents_1_1_type.html#a4c0afb748726e34daf4c20c27c0e0165">Type::USER_EVENT</a>;</div>
</div><!-- fragment --><p>Note that <code>Type</code> is a namespace inside <code>events</code> namespace, which lists FastArduino pre-defined Event types as constants: </p><div class="fragment"><div class="line">        <span class="keyword">const</span> uint8_t <a class="code" href="namespaceevents_1_1_type.html#a2c33d039e5fdd277900219bd3cd74eb0">NO_EVENT</a> = 0;</div>
<div class="line">        <span class="keyword">const</span> uint8_t <a class="code" href="namespaceevents_1_1_type.html#a89956491c3bf31c616baf63fcd335405">WDT_TIMER</a> = 1;</div>
<div class="line">        <span class="keyword">const</span> uint8_t <a class="code" href="namespaceevents_1_1_type.html#af865c398a73776e70e023c82d0af6b8d">RTT_TIMER</a> = 2;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// User-defined events start here (in range [128-255]))</span></div>
<div class="line">        <span class="keyword">const</span> uint8_t <a class="code" href="namespaceevents_1_1_type.html#a4c0afb748726e34daf4c20c27c0e0165">USER_EVENT</a> = 128;</div>
</div><!-- fragment --><p>Numbers from 3 to 127 are reserved for FastArduino future enhancements.</p>
<p>The we define the class that will handle Pin Change Interrupts and generate events: </p><div class="fragment"><div class="line"><span class="keyword">class </span>EventGenerator</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    EventGenerator(<a class="code" href="classcontainers_1_1_queue.html">containers::Queue&lt;EVENT&gt;</a>&amp; event_queue):event_queue_{event_queue}, buttons_{0x00, 0xFF} {}</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> on_pin_change()</div>
<div class="line">    {</div>
<div class="line">        event_queue_.<a class="code" href="classcontainers_1_1_queue.html#ae506aa92e594cbac6f338c2b65d1e3b6">push_</a>(EVENT{BUTTON_EVENT, buttons_.get_PIN()});</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <a class="code" href="classcontainers_1_1_queue.html">containers::Queue&lt;EVENT&gt;</a>&amp; event_queue_;</div>
<div class="line">    <a class="code" href="classgpio_1_1_fast_port.html">gpio::FastPort&lt;BUTTONS_PORT&gt;</a> buttons_;</div>
<div class="line">};</div>
</div><!-- fragment --><p> Note the use of <code><a class="el" href="classcontainers_1_1_queue.html" title="Queue of type T_ items.">containers::Queue</a>&lt;EVENT&gt;</code> that represents a <a href="https://en.wikipedia.org/wiki/Circular_buffer">ring-buffer</a> queue to which events are pushed when the state of buttons are changing, and from which events are pulled from the main event loop (as shown later).</p>
<p>The most interesting code is the single line: </p><div class="fragment"><div class="line">        event_queue_.push_(EVENT{BUTTON_EVENT, buttons_.get_PIN()});</div>
</div><!-- fragment --><p>where a new <code>EVENT</code> is instantiated, its value is the current level of all 8 buttons pins; then the new event is pushed to the events queue.</p>
<p>As <a class="el" href="tutorial.html#interrupts">usual</a>, we have to register this handler to the right PCI ISR: </p><div class="fragment"><div class="line"><a class="code" href="pci_8h.html#a64be10f04dd31643ee243b564a0d910c">REGISTER_PCI_ISR_METHOD</a>(PCI_NUM, EventGenerator, &amp;EventGenerator::on_pin_change, board::InterruptPin::D0_PD0_PCI2)</div>
</div><!-- fragment --><p>Next we define the size of the events queue: </p><div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> uint8_t EVENT_QUEUE_SIZE = 32;</div>
</div><!-- fragment --><p> This must be known at compile-time as we do not want dynamic memory allocation in an embedded program.</p>
<p>The actual events queue is instantiated inside <code>main()</code>: </p><div class="fragment"><div class="line">    EVENT buffer[EVENT_QUEUE_SIZE];</div>
<div class="line">    <a class="code" href="classcontainers_1_1_queue.html">containers::Queue&lt;EVENT&gt;</a> event_queue{buffer};</div>
</div><!-- fragment --><p> Note that this is done in 2 steps:</p><ol type="1">
<li>A buffer of the required size is allocated (in the stack for this example); the actual size, in this example, is <code>64</code> bytes, i.e. 32 times 1 byte (event type) + 1 byte (event value).</li>
<li>A <code>Queue</code> is instantiated for this buffer; after this step, you should never directly access <code>buffer</code> from your code.</li>
</ol>
<p>Finally, the <code>main()</code> function has the infinite event loop: </p><div class="fragment"><div class="line">    <span class="keywordflow">while</span> (<span class="keyword">true</span>)</div>
<div class="line">    {</div>
<div class="line">        EVENT <span class="keyword">event</span> = <a class="code" href="namespacecontainers.html#ad31e49a84cd01e80e5c66859820ca8c9">containers::pull</a>(event_queue);</div>
<div class="line">        <span class="keywordflow">if</span> (event.type() == BUTTON_EVENT)</div>
<div class="line">            <span class="comment">// Invert levels as 0 means button pushed (and we want 1 instead)</span></div>
<div class="line">            blink(event.value() ^ 0xFF);</div>
<div class="line">    }</div>
</div><!-- fragment --><p> The call to <code>containers::pull(event_queue)</code> is blocking until an event is available in the queue, i.e. has been pushed by <code>EventGenerator::on_pin_change()</code>. While waiting, this call uses <code><a class="el" href="namespacetime.html#a5396c009ace06e55985ccf6b7bff179a" title="Utility method used by many FastArduino API in order to &quot;yield&quot; some processor time; concretely it ju...">time::yield()</a></code> which may put the MCU in sleep mode (see <a class="el" href="tutorial.html#power">Power management tutorial later</a>).</p>
<p>Once an event is pulled from the event queue, we check its type and call <code>blink()</code> function with the event value, i.e. the state of buttons when Pin Change Interrupt has occurred.</p>
<p>The <code>blink()</code> function simply loops for the requested number of iterations and blinking delay, and returns only when the full blinking sequence is finished. This function is very simple and there is no need to explain it further.</p>
<h2>Event Dispatcher</h2>
<p>In the previous example, only one type of event is expected inside the event loop. In more complex applications though, many more types of events are foreseeable and we may end up with an event loop like: </p><div class="fragment"><div class="line">    <span class="keywordflow">while</span> (<span class="keyword">true</span>)</div>
<div class="line">    {</div>
<div class="line">        EVENT <span class="keyword">event</span> = <a class="code" href="namespacecontainers.html#ad31e49a84cd01e80e5c66859820ca8c9">containers::pull</a>(event_queue);</div>
<div class="line">        <span class="keywordflow">switch</span> (event.type())</div>
<div class="line">        {</div>
<div class="line">            <span class="keywordflow">case</span> EVENT_TYPE_1:</div>
<div class="line">            <span class="comment">// Do something</span></div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line"> </div>
<div class="line">            <span class="keywordflow">case</span> EVENT_TYPE_2:</div>
<div class="line">            <span class="comment">// Do something else</span></div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line"> </div>
<div class="line">            <span class="keywordflow">case</span> EVENT_TYPE_3:</div>
<div class="line">            <span class="comment">// Do yet something else</span></div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line"> </div>
<div class="line">            ...</div>
<div class="line">        }</div>
<div class="line">    }</div>
</div><!-- fragment --><p>This generally makes code less readable and more difficult to maintain.</p>
<p>FastArduino API supports an <em>event dispatching</em> approach, where you define <code>EventHandler</code> classes and register instances for specific event types:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>MyHandler: <span class="keyword">public</span> EventHandler&lt;EVENT&gt;</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    MyHandler() : EventHandler&lt;EVENT&gt;{<a class="code" href="namespaceevents_1_1_type.html#a4c0afb748726e34daf4c20c27c0e0165">Type::USER_EVENT</a>} {}</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> on_event(<span class="keyword">const</span> EVENT&amp; event)<span class="keyword"> override</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">        <span class="comment">// Do something</span></div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    ...</div>
<div class="line">    <span class="comment">// Prepare Handlers</span></div>
<div class="line">    MyHandler handler;</div>
<div class="line">    ...</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Prepare Dispatcher and register Handlers</span></div>
<div class="line">    Dispatcher&lt;EVENT&gt; dispatcher;</div>
<div class="line">    dispatcher.insert(handler);</div>
<div class="line">    ...</div>
<div class="line">}</div>
</div><!-- fragment --><p> With <code><a class="el" href="classevents_1_1_dispatcher.html" title="Utility to dispatch an event to a list of EventHandlers that are registered for its type.">events::Dispatcher</a></code>, you can register one handler for each event type, and then the main event loop is reduced to the simple code below: </p><div class="fragment"><div class="line">    <span class="keywordflow">while</span> (<span class="keyword">true</span>)</div>
<div class="line">    {</div>
<div class="line">        EVENT <span class="keyword">event</span> = <a class="code" href="namespacecontainers.html#ad31e49a84cd01e80e5c66859820ca8c9">pull</a>(event_queue);</div>
<div class="line">        dispatcher.dispatch(event);</div>
<div class="line">    }</div>
</div><!-- fragment --><p>The right event handler gets automatically called for each pulled event.</p>
<p>Note that <code><a class="el" href="classevents_1_1_event_handler.html" title="Abstract event handler, used by Dispatcher to get called back when an event of the expected type is d...">events::EventHandler</a></code> uses a <code>virtual</code> method, hence this may have an impact on memory size consumed in Flash (vtables) and also on method call time.</p>
<h2>Scheduler &amp; Jobs</h2>
<p>Some types of events are generated by FastArduino features. In particular, watchdog and realtime timer features can be setup to trigger some time events at given periods. From these events, FastArduino offers a <code><a class="el" href="classevents_1_1_scheduler.html" title="Schedule jobs at predefined periods of time.">events::Scheduler</a></code> API, that allows you to define periodic <code><a class="el" href="classevents_1_1_job.html" title="Abstract class holding some action to be executed at given periods of time.">events::Job</a></code>s.</p>
<p>The next code demonstrates a new way of blinking a LED by using watchdog generated events and associated jobs:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="preprocessor">#include &lt;<a class="code" href="gpio_8h.html">fastarduino/gpio.h</a>&gt;</span></div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;<span class="preprocessor">#include &lt;<a class="code" href="events_8h.html">fastarduino/events.h</a>&gt;</span></div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;<span class="preprocessor">#include &lt;<a class="code" href="watchdog_8h.html">fastarduino/watchdog.h</a>&gt;</span></div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;<span class="preprocessor">#include &lt;<a class="code" href="scheduler_8h.html">fastarduino/scheduler.h</a>&gt;</span></div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160; </div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;<span class="keyword">using namespace </span><a class="code" href="namespaceevents.html">events</a>;</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;<span class="keyword">using</span> EVENT = <a class="code" href="classevents_1_1_event.html">Event&lt;void&gt;</a>;</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160; </div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;<span class="comment">// Define vectors we need in the example</span></div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;<a class="code" href="watchdog_8h.html#a6998639a03718afa44f5626c17ce8994">REGISTER_WATCHDOG_CLOCK_ISR</a>(EVENT)</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160; </div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;<span class="keyword">static</span> <span class="keyword">const</span> uint32_t PERIOD = 1000;</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160; </div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;<span class="keyword">class </span>LedBlinkerJob: <span class="keyword">public</span> <a class="code" href="classevents_1_1_job.html">Job</a></div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;{</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;<span class="keyword">public</span>:</div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;    LedBlinkerJob() : <a class="code" href="classevents_1_1_job.html">Job</a>{0, PERIOD}, led_{<a class="code" href="namespacegpio.html#ae18fafd08668ee17aa5dd415ee3b6041a50a87f0d71f7221582dad4bf507a0f34">gpio::PinMode::OUTPUT</a>} {}</div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160; </div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;<span class="keyword">protected</span>:</div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;    <span class="keyword">virtual</span> <span class="keywordtype">void</span> on_schedule(<a class="code" href="defines_8h.html#addf5ec070e9499d36b7f2009ce736076">UNUSED</a> uint32_t <a class="code" href="namespacetime.html#a173df6ce2b6d3d6ed1418807e1b70a70">millis</a>)<span class="keyword"> override</span></div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;<span class="keyword">    </span>{</div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;        led_.toggle();</div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;    }</div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;    </div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;<span class="keyword">private</span>:</div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;    <a class="code" href="namespacegpio.html#a3cbdad86ced6494ca615a425b433fd57">gpio::FAST_PIN&lt;board::DigitalPin::LED&gt;</a> led_;</div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;};</div>
<div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160; </div>
<div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;<span class="comment">// Define event queue</span></div>
<div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;<span class="keyword">static</span> <span class="keyword">const</span> uint8_t EVENT_QUEUE_SIZE = 32;</div>
<div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;<span class="keyword">static</span> EVENT buffer[EVENT_QUEUE_SIZE];</div>
<div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;<span class="keyword">static</span> <a class="code" href="classcontainers_1_1_queue.html">containers::Queue&lt;EVENT&gt;</a> event_queue{buffer};</div>
<div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160; </div>
<div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;<span class="keywordtype">int</span> main() __attribute__((OS_main));</div>
<div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;<span class="keywordtype">int</span> main()</div>
<div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;{</div>
<div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;    <a class="code" href="namespaceboard.html#a2529f85498783a75dc75c281e0b754d3">board::init</a>();</div>
<div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;    <span class="comment">// Enable interrupts at startup time</span></div>
<div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;    sei();</div>
<div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160; </div>
<div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;    <span class="comment">// Prepare Dispatcher and Handlers</span></div>
<div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;    <a class="code" href="classevents_1_1_dispatcher.html">Dispatcher&lt;EVENT&gt;</a> dispatcher;</div>
<div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;    <a class="code" href="classwatchdog_1_1_watchdog.html">watchdog::Watchdog&lt;EVENT&gt;</a> <a class="code" href="namespacewatchdog.html">watchdog</a>{event_queue};</div>
<div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;    <a class="code" href="classevents_1_1_scheduler.html">Scheduler&lt;watchdog::Watchdog&lt;EVENT&gt;</a>, EVENT&gt; scheduler{<a class="code" href="namespacewatchdog.html">watchdog</a>, <a class="code" href="namespaceevents_1_1_type.html#a89956491c3bf31c616baf63fcd335405">Type::WDT_TIMER</a>};</div>
<div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;    dispatcher.<a class="code" href="classcontainers_1_1_linked_list.html#ac44c93a96f2aaffe0411565798c6cd67">insert</a>(scheduler);</div>
<div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160; </div>
<div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;    LedBlinkerJob job;</div>
<div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;    scheduler.schedule(job);</div>
<div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;    </div>
<div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;    <span class="comment">// Start watchdog</span></div>
<div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;    <a class="code" href="namespacewatchdog.html">watchdog</a>.begin(watchdog::TimeOut::TO_64ms);</div>
<div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;    </div>
<div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;    <span class="comment">// Event Loop</span></div>
<div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;    <span class="keywordflow">while</span> (<span class="keyword">true</span>)</div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;    {</div>
<div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;        EVENT <span class="keyword">event</span> = <a class="code" href="namespacecontainers.html#ad31e49a84cd01e80e5c66859820ca8c9">pull</a>(event_queue);</div>
<div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;        dispatcher.<a class="code" href="classevents_1_1_dispatcher.html#a97998440c7f6f351f57fb501df3c0dd7">dispatch</a>(event);</div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;    }</div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;}</div>
</div><!-- fragment --><p>FastArduino <code>Scheduler</code> API is defined in its own header, but under the same <code>events</code> namespace:  </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="scheduler_8h.html">fastarduino/scheduler.h</a>&gt;</span></div>
</div><!-- fragment --><p>This API is based on FastArduino events management, hence we need to define the <code>Event</code> type we need: </p><div class="fragment"><div class="line"><span class="keyword">using</span> EVENT = Event&lt;void&gt;;</div>
</div><!-- fragment --><p> FastArduino <code>Scheduler</code> does not use <code>Event</code>'s<code>value</code>, hence we can simply use <code>void</code>, so that one <code>EVENT</code> will be exactly one byte in size.</p>
<p>Next step consists in registering Watchdog clock ISR: </p><div class="fragment"><div class="line"><a class="code" href="watchdog_8h.html#a6998639a03718afa44f5626c17ce8994">REGISTER_WATCHDOG_CLOCK_ISR</a>(EVENT)</div>
</div><!-- fragment --><p>We then define a <code>Job</code> subclass that will be called back at the required period: </p><div class="fragment"><div class="line"><span class="keyword">class </span>LedBlinkerJob: <span class="keyword">public</span> Job</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    LedBlinkerJob() : Job{0, PERIOD}, led_{<a class="code" href="namespacegpio.html#ae18fafd08668ee17aa5dd415ee3b6041a50a87f0d71f7221582dad4bf507a0f34">gpio::PinMode::OUTPUT</a>} {}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">protected</span>:</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> on_schedule(<a class="code" href="defines_8h.html#addf5ec070e9499d36b7f2009ce736076">UNUSED</a> uint32_t <a class="code" href="namespacetime.html#a173df6ce2b6d3d6ed1418807e1b70a70">millis</a>)<span class="keyword"> override</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">        led_.toggle();</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <a class="code" href="namespacegpio.html#a3cbdad86ced6494ca615a425b433fd57">gpio::FAST_PIN&lt;board::DigitalPin::LED&gt;</a> led_;</div>
<div class="line">};</div>
</div><!-- fragment --><p> <code>Job</code> constructor takes 2 arguments:</p><ul>
<li><code>next</code>: the delay in ms after which this job will execute for the first time; <code>0</code> means this job should execute immediately</li>
<li><code>period</code>: the period in ms at which the job shall be re-executed; <code>0</code> means this job will execute only once.</li>
</ul>
<p>In this example, we set the job period to 1000ms, i.e. the actual blink period will be 2s.</p>
<p>The <code>virtual</code> method <code>Job::on_schedule()</code> will get called when the time to executed has elapsed, not necessarily at the exact expected time (the exact time depends on several factors exposed hereafter).</p>
<p>In the example, we then declare the event queue, this time as static memory (not in the stack): </p><div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> uint8_t EVENT_QUEUE_SIZE = 32;</div>
<div class="line"><span class="keyword">static</span> EVENT buffer[EVENT_QUEUE_SIZE];</div>
<div class="line"><span class="keyword">static</span> <a class="code" href="classcontainers_1_1_queue.html">containers::Queue&lt;EVENT&gt;</a> event_queue{buffer};</div>
</div><!-- fragment --><p>In <code>main()</code>, we create a <code>Dispatcher</code> that will be used in the event loop, a <code>Watchdog</code> that will generate and queue <code>Type::WDT_TIMER</code> events on each watchdog timeout, and a <code>Scheduler</code> that will get notified of <code>Type::WDT_TIMER</code> events and will use the created <code>Watchdog</code> as a clock, in order to determine which <code>Job</code>s to call. </p><div class="fragment"><div class="line">    Dispatcher&lt;EVENT&gt; dispatcher;</div>
<div class="line">    <a class="code" href="classwatchdog_1_1_watchdog.html">watchdog::Watchdog&lt;EVENT&gt;</a> <a class="code" href="namespacewatchdog.html">watchdog</a>{event_queue};</div>
<div class="line">    Scheduler&lt;watchdog::Watchdog&lt;EVENT&gt;, EVENT&gt; scheduler{<a class="code" href="namespacewatchdog.html">watchdog</a>, <a class="code" href="namespaceevents_1_1_type.html#a89956491c3bf31c616baf63fcd335405">Type::WDT_TIMER</a>};</div>
<div class="line">    dispatcher.insert(scheduler);</div>
</div><!-- fragment --><p> Note the last code line, which links the <code>Scheduler</code> to the <code>Dispatcher</code> so it can handle proper events.</p>
<p>Next, we instantiate the job that will make the LED blink, and schedule with <code>Scheduler</code>: </p><div class="fragment"><div class="line">    LedBlinkerJob job;</div>
<div class="line">    scheduler.schedule(job);</div>
</div><!-- fragment --><p>We can then start the watchdog with any suitable timeout value (the selected value impacts the accuracy of the watchdog clock): </p><div class="fragment"><div class="line">    <a class="code" href="namespacewatchdog.html">watchdog</a>.begin(watchdog::TimeOut::TO_64ms);</div>
</div><!-- fragment --><p>Finally, then event loop is quite usual: </p><div class="fragment"><div class="line">    <span class="keywordflow">while</span> (<span class="keyword">true</span>)</div>
<div class="line">    {</div>
<div class="line">        EVENT <span class="keyword">event</span> = <a class="code" href="namespacecontainers.html#ad31e49a84cd01e80e5c66859820ca8c9">pull</a>(event_queue);</div>
<div class="line">        dispatcher.dispatch(event);</div>
<div class="line">    }</div>
</div><!-- fragment --><p>Jobs scheduling accuracy depends on several factors:</p><ul>
<li>the accuracy of the <code>CLOCK</code> used for <code>Scheduler</code>; FastArduino provides two possible clocks (but you may also provide your own): <code><a class="el" href="classwatchdog_1_1_watchdog.html" title="Simple API to use watchdog timer as a clock for events generation.">watchdog::Watchdog</a></code> and <code><a class="el" href="classtimer_1_1_r_t_t.html" title="API to handle a real-time timer.">timer::RTT</a></code>.</li>
<li>the CPU occupation of your main event loop, which may trigger a <code>Job</code> long after its expected time.</li>
</ul>
<p>As mentioned above, <code>Scheduler</code> can also work with <code><a class="el" href="classtimer_1_1_r_t_t.html" title="API to handle a real-time timer.">timer::RTT</a></code>, that would mean only a few changes in the previous example, as shown in the next snippet, only showing new lines of code: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="realtime__timer_8h.html">fastarduino/realtime_timer.h</a>&gt;</span></div>
<div class="line">...</div>
<div class="line">static <span class="keyword">const</span> uint16_t RTT_EVENT_PERIOD = 1024;</div>
<div class="line"><a class="code" href="realtime__timer_8h.html#a2fa7e6297d6f853dea35cc5a9f213c46">REGISTER_RTT_EVENT_ISR</a>(0, EVENT, RTT_EVENT_PERIOD)</div>
<div class="line">...</div>
<div class="line">void main()</div>
<div class="line">{</div>
<div class="line">    ...</div>
<div class="line">    <a class="code" href="classtimer_1_1_r_t_t.html">timer::RTT&lt;board::Timer::TIMER0&gt;</a> rtt;</div>
<div class="line">    <a class="code" href="classtimer_1_1_r_t_t_event_callback.html">timer::RTTEventCallback&lt;EVENT, RTT_EVENT_PERIOD&gt;</a> callback{event_queue};</div>
<div class="line">    <a class="code" href="namespaceinterrupt.html#abfd5857208f49006bde8c472497273de">interrupt::register_handler</a>(callback);</div>
<div class="line">    ...</div>
<div class="line">    Scheduler&lt;timer::RTT&lt;board::Timer::TIMER0&gt;, EVENT&gt; scheduler{rtt, <a class="code" href="namespaceevents_1_1_type.html#af865c398a73776e70e023c82d0af6b8d">Type::RTT_TIMER</a>};</div>
<div class="line">    ...</div>
<div class="line">    rtt.<a class="code" href="classtimer_1_1_r_t_t.html#a9f2975201cfb390d7fb15e930d0c5489">begin</a>();</div>
<div class="line">    ...</div>
<div class="line">}</div>
</div><!-- fragment --><p> Since this code uses a realtime timer, two lines of code instantiate, then start one such timer: </p><div class="fragment"><div class="line">    <a class="code" href="classtimer_1_1_r_t_t.html">timer::RTT&lt;board::Timer::TIMER0&gt;</a> rtt;</div>
<div class="line">    ...</div>
<div class="line">    rtt.<a class="code" href="classtimer_1_1_r_t_t.html#a9f2975201cfb390d7fb15e930d0c5489">begin</a>();</div>
</div><!-- fragment --><p> In addition, we use <code><a class="el" href="classtimer_1_1_r_t_t_event_callback.html" title="Utility to generate events from an RTT instance at a given period.">timer::RTTEventCallback</a></code> utility class, which purpose is to generate events from RTT ticks: </p><div class="fragment"><div class="line">    <a class="code" href="classtimer_1_1_r_t_t_event_callback.html">timer::RTTEventCallback&lt;EVENT, RTT_EVENT_PERIOD&gt;</a> callback{event_queue};</div>
<div class="line">    <a class="code" href="namespaceinterrupt.html#abfd5857208f49006bde8c472497273de">interrupt::register_handler</a>(callback);</div>
</div><!-- fragment --><p>Here we create a callback that will generate an event every <code>RTT_EVENT_PERIOD</code> milliseconds.</p>
<p>We also need to register the right ISR for the RTT and the callback: </p><div class="fragment"><div class="line"><a class="code" href="realtime__timer_8h.html#a2fa7e6297d6f853dea35cc5a9f213c46">REGISTER_RTT_EVENT_ISR</a>(0, EVENT, RTT_EVENT_PERIOD)</div>
</div><!-- fragment --><p> Now the scheduler can be instantiated with the RTT instance as its clock and <code>Type::RTT_TIMER</code> as the type of events to listen to: </p><div class="fragment"><div class="line">    Scheduler&lt;timer::RTT&lt;board::Timer::TIMER0&gt;, EVENT&gt; scheduler{rtt, <a class="code" href="namespaceevents_1_1_type.html#af865c398a73776e70e023c82d0af6b8d">Type::RTT_TIMER</a>};</div>
</div><!-- fragment --><h1><a class="anchor" id="power"></a>Advanced: Power Management </h1>
<p>AVR MCU support various sleep modes that you can use to reduce power consumption of your circuits.</p>
<p>Each sleep mode has distinct characteristics regarding:</p><ul>
<li>maximum current consumed</li>
<li>list of wake-up signals (interrupts)</li>
<li>time to wake up from sleep</li>
</ul>
<p>FastArduino support for AVR power modes is quite simple, gathered in <code>namespace power</code> and consists in a single class <code><a class="el" href="classpower_1_1_power.html" title="This class contains the API for handling power sleep modes.">power::Power</a></code> with 3 static methods.</p>
<p>In addition, the available sleep modes for a given MCU are defined in <code><a class="el" href="namespaceboard.html#ae62717162088fee094efad7ff669183d" title="Defines all available sleep modes for target MCU.">board::SleepMode</a></code> enumerated type.</p>
<p>Here is a simple example:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="preprocessor">#include &lt;<a class="code" href="gpio_8h.html">fastarduino/gpio.h</a>&gt;</span></div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;<span class="preprocessor">#include &lt;<a class="code" href="power_8h.html">fastarduino/power.h</a>&gt;</span></div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;<span class="preprocessor">#include &lt;<a class="code" href="watchdog_8h.html">fastarduino/watchdog.h</a>&gt;</span></div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160; </div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;<span class="comment">// Define vectors we need in the example</span></div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;<a class="code" href="watchdog_8h.html#adb4cc81538efc2536ee6e1d06ae4b92f">REGISTER_WATCHDOG_ISR_EMPTY</a>()</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160; </div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;int main() __attribute__((OS_main));</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;<span class="keywordtype">int</span> main()</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;{</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;    <a class="code" href="namespaceboard.html#a2529f85498783a75dc75c281e0b754d3">board::init</a>();</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;    sei();</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160; </div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;    <a class="code" href="namespacegpio.html#a3cbdad86ced6494ca615a425b433fd57">gpio::FAST_PIN&lt;board::DigitalPin::LED&gt;</a> led{<a class="code" href="namespacegpio.html#ae18fafd08668ee17aa5dd415ee3b6041a50a87f0d71f7221582dad4bf507a0f34">gpio::PinMode::OUTPUT</a>};</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160; </div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;    <a class="code" href="classwatchdog_1_1_watchdog_signal.html">watchdog::WatchdogSignal</a> <a class="code" href="namespacewatchdog.html">watchdog</a>;</div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;    <a class="code" href="namespacewatchdog.html">watchdog</a>.begin(watchdog::TimeOut::TO_500ms);</div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;    </div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;    <span class="keywordflow">while</span> (<span class="keyword">true</span>)</div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;    {</div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;        led.toggle();</div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;        <a class="code" href="classpower_1_1_power.html#a0bfb70818b6e364f8e6e0d5745ba254b">power::Power::sleep</a>(board::SleepMode::POWER_DOWN);</div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;    }</div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;}</div>
</div><!-- fragment --><p>You may have recognized it: this is the example presented in the <a class="el" href="tutorial.html#watchdog">Watchdog section</a> of this tutorial.</p>
<p>In the main loop, we just toggle the LED pin and go to <code>board::SleepMode::POWER_DOWN</code> sleep mode (the mode that consumes the least current of all).</p>
<p>The <code>Power::sleep()</code> method will return only when the MCU is awakened by an external signal, in this example, the signal used is the watchdog timeout interrupt (every 500ms).</p>
<p>Note that the <code><a class="el" href="namespacetime.html#a5396c009ace06e55985ccf6b7bff179a" title="Utility method used by many FastArduino API in order to &quot;yield&quot; some processor time; concretely it ju...">time::yield()</a></code> method just calls <code>Power::sleep()</code> (with current default sleep mode) and this method is used by other FastArduino API on several occasions whenever these API need to wait for something:</p><ul>
<li><code><a class="el" href="classwatchdog_1_1_watchdog_r_t_t.html#aea02a3b9597f346d30b0781fae69506d" title="Delay program execution for the given amount of milliseconds.">watchdog::Watchdog::delay()</a></code> while waiting for time to elapse for the given delay</li>
<li><code><a class="el" href="classtimer_1_1_r_t_t.html#a7d5c189655b98446f08ccd5cf078c912" title="Delay program execution for the given amount of milliseconds.">timer::RTT::delay()</a></code> while waiting for time to elapse for the given delay</li>
<li><code><a class="el" href="classstreams_1_1ostreambuf.html#a2e65481b6a64791d5584818b687ddf7e" title="Wait until all buffer content has been pulled by a consumer.">streams::ostreambuf::pubsync()</a></code> while waiting until all stream content has been read by a consumer (e.g. UART)</li>
<li><code><a class="el" href="namespacecontainers.html#ad31e49a84cd01e80e5c66859820ca8c9" title="Pull an item from the beginning of queue.">containers::pull()</a></code> and <code><a class="el" href="namespacecontainers.html#abb750042e76f224f2e2a7baeb2e5998a" title="Peek an item from the beginning of queue.">containers::peek()</a></code> while waiting for an item to be pushed to a queue</li>
<li><code><a class="el" href="classdevices_1_1rf_1_1_n_r_f24_l01.html" title="SPI device driver for Nordic Semiconductor nRF24L01+ support, without IRQ support.">devices::rf::NRF24L01</a></code> when sending or receving payload</li>
</ul>
<p>Hence when using any of these API, it is important to select the proper sleep mode, based on your power consumption requirements.</p>
<h1><a class="anchor" id="eeprom"></a>Advanced: EEPROM </h1>
<p>All AVR MCU include an EEPROM (Electrically Erasable Programmable Read-Only Memory) which can be useful for storing data that:</p><ul>
<li>is quite stable but may change from time to time</li>
<li>is fixed but different for every MCU (for a large series of similar circuits)</li>
</ul>
<p>Typical examples of use of EEPROM cells include (but are not limited to):</p><ul>
<li>Circuit unique ID (e.g. used in a network of devices)</li>
<li>WIFI credentials</li>
<li>Calibration value (for internal RC clock)</li>
<li>Sequence of tones frequencies &amp; periods for an alarm melody</li>
</ul>
<p>In these examples, writing EEPROM cells would happen only once (or a few times), while reading would occur at startup.</p>
<h2>Reading EEPROM content</h2>
<p>Often, writing EEPROM can be done directly through an ISP programmer (UNO USB programming does not support EEPROM writing) and only reading is needed in a program. The next example illustrates this situation.</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="preprocessor">#include &lt;<a class="code" href="eeprom_8h.html">fastarduino/eeprom.h</a>&gt;</span></div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;<span class="preprocessor">#include &lt;<a class="code" href="tones_8h.html">fastarduino/devices/tones.h</a>&gt;</span></div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;<span class="preprocessor">#include &lt;<a class="code" href="time_8h.html">fastarduino/time.h</a>&gt;</span></div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160; </div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;<span class="comment">// Board-dependent settings</span></div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;<span class="keyword">static</span> constexpr <span class="keyword">const</span> <a class="code" href="namespaceboard.html#aa6b4a447b2fccb95185367644c3f28bb">board::Timer</a> NTIMER = board::Timer::TIMER1;</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;<span class="keyword">static</span> constexpr <span class="keyword">const</span> <a class="code" href="namespaceboard.html#a1283eb94244413c14c80cc2f3e8bcb3f">board::PWMPin</a> <a class="code" href="namespacegpio.html#ae18fafd08668ee17aa5dd415ee3b6041aa84cc046d48610b05c21fd3670d0c829">OUTPUT</a> = board::PWMPin::D9_PB1_OC1A;</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160; </div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;<span class="keyword">using</span> <a class="code" href="namespacedevices_1_1audio.html#ad5cef39b1f81f50bd23e0a4f4cf555aa">devices::audio::Tone</a>;</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;<span class="keyword">using namespace </span><a class="code" href="namespaceeeprom.html">eeprom</a>;</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;<span class="keyword">using</span> GENERATOR = <a class="code" href="classdevices_1_1audio_1_1_tone_generator.html">devices::audio::ToneGenerator&lt;NTIMER, OUTPUT&gt;</a>;</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160; </div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;<span class="keyword">struct </span>TonePlay</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;{</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;    <a class="code" href="namespacedevices_1_1audio.html#ad5cef39b1f81f50bd23e0a4f4cf555aa">Tone</a> tone;</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;    uint16_t ms;</div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;};</div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160; </div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;<span class="comment">// Melody to be played</span></div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;TonePlay music[] EEMEM =</div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;{</div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;    <span class="comment">// Intro</span></div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;    {Tone::A1, 500},</div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;    {Tone::A1, 500},</div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;    {Tone::A1, 500},</div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;    {Tone::F1, 350},</div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;    {Tone::C2, 150},</div>
<div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;    {Tone::A1, 500},</div>
<div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;    {Tone::F1, 350},</div>
<div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;    {Tone::C2, 150},</div>
<div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;    {Tone::A1, 650},</div>
<div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160; </div>
<div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;    <span class="comment">// Marker for end of melody</span></div>
<div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;    {Tone::USER0, 0}</div>
<div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;};</div>
<div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160; </div>
<div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;<span class="keywordtype">int</span> main()</div>
<div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;{</div>
<div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;    sei();</div>
<div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;    GENERATOR generator;</div>
<div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;    TonePlay* play = music;</div>
<div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;    <span class="keywordflow">while</span> (<span class="keyword">true</span>)</div>
<div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;    {</div>
<div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;        TonePlay tone;</div>
<div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;        <a class="code" href="classeeprom_1_1_e_e_p_r_o_m.html#a046768eae9f26564b1039a13b88bb8c1">EEPROM::read</a>(play, tone);</div>
<div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;        <span class="keywordflow">if</span> (tone.tone == Tone::USER0)</div>
<div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;            <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;        generator.start_tone(tone.tone);</div>
<div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;        <a class="code" href="namespacetime.html#af13fd17ddf6b751b8161691e608892b2">time::delay_ms</a>(tone.ms);</div>
<div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;        generator.stop_tone();</div>
<div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;        ++play;</div>
<div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;    }</div>
<div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;}</div>
</div><!-- fragment --><p>This example plays a short melody, stored in EEPROM, to a buzzer wired on Arduino UNO D9 pin. It uses FastArduino <code><a class="el" href="classdevices_1_1audio_1_1_tone_generator.html" title="API class for tone generation to a buzzer (or better an amplifier) connected to pin OUTPUT.">devices::audio::ToneGenerator</a></code> support to generate square waves at the required frequencies, in order to generate a melody intro that Star Wars fan will recognize!</p>
<p>Past the headers inclusion, UNO-specific definitions (timer and output pin) and various <code>using</code> directives, the example defines <code>struct TonePlay</code> which embeds a <code>Tone</code> (frequency) and a duration, which is then used in an array of notes to be played:  </p><div class="fragment"><div class="line"><span class="keyword">struct </span>TonePlay</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="namespacedevices_1_1audio.html#ad5cef39b1f81f50bd23e0a4f4cf555aa">Tone</a> tone;</div>
<div class="line">    uint16_t ms;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Melody to be played</span></div>
<div class="line">TonePlay music[] EEMEM =</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Intro</span></div>
<div class="line">    {Tone::A1, 500},</div>
<div class="line">    {Tone::A1, 500},</div>
<div class="line">    {Tone::A1, 500},</div>
<div class="line">    {Tone::F1, 350},</div>
<div class="line">    {Tone::C2, 150},</div>
<div class="line">    {Tone::A1, 500},</div>
<div class="line">    {Tone::F1, 350},</div>
<div class="line">    {Tone::C2, 150},</div>
<div class="line">    {Tone::A1, 650},</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Marker for end of melody</span></div>
<div class="line">    {Tone::USER0, 0}</div>
<div class="line">};</div>
</div><!-- fragment --><p> Note that <code>music</code> array is defined with <code>EEMEM</code> attribute, which tells the compiler that this array shall be stored in EEPROM and not in Flash or SRAM.</p>
<p>The advantages of storing the melody in EEPROM are:</p><ul>
<li>it can easily be changed to another melody without any change to the program (flash)</li>
<li>it does not use Flash memory for storage</li>
<li>it does not use SRAM memory in runtime (although it might, if entirely read from EEPROM to SRAM, but why would you do that?)</li>
</ul>
<p>Note, however, that for some Arduino boards (e.g. UNO), storing a melody to the EEPROM may require using a specific device, called an ISP programmer. This is beacuse some Arduino bootloaders do not support EEPROM upload.</p>
<p>The important part of the program is the loop where each note is read for EEPROM before being played: </p><div class="fragment"><div class="line">    TonePlay* play = music;</div>
<div class="line">    <span class="keywordflow">while</span> (<span class="keyword">true</span>)</div>
<div class="line">    {</div>
<div class="line">        TonePlay tone;</div>
<div class="line">        EEPROM::read(play, tone);</div>
</div><!-- fragment --><p> In this snippet, <code>play</code> is used just as an "index" (an address actually) to the current note in <code>music</code> array. Beware that <code>play</code> cannot be used directly in your program because it points nowhere actually, really.</p>
<p>The interesting bit here is <code>EEPROM::read(play, tone);</code> which uses <code>play</code> address as a reference to the next note in EEPROM, reads the EEPROM content at this location and copies it into <code>tone</code>.</p>
<p>At the end of the loop, <code>play</code> address gets incremented in order to point to the next note of <code>music</code> in EEPROM: </p><div class="fragment"><div class="line">        ++play;</div>
<div class="line">    }</div>
</div><!-- fragment --><p>At this point, you may wonder when the <code>while (true)</code> loop exits. Since the program does not in advance what melody it is going to play, it it not possible to use a <code>for</code> loop with an upper boundary as we could do if <code>music</code> was directly in SRAM.</p>
<p>Thus, we use another way to determine the end of the meoldy to play: we use a special <code>Tone</code>, <code>Tone::END</code>, which is just a marker of the end of the melody; we check it for every tone read from EEPROM: </p><div class="fragment"><div class="line">        EEPROM::read(play, tone);</div>
<div class="line">        <span class="keywordflow">if</span> (tone.tone == <a class="code" href="namespacedevices_1_1audio_1_1_special_tone.html#a4221d7dbfd3adda995e653697bdf28a1">Tone::END</a>)</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
</div><!-- fragment --><p> All this is all good but how do we upload the melody to the EEPROM the first time?</p>
<p>FastArduino make system takes care of this:</p>
<ol type="1">
<li><code>make build</code> not only generates a <code>.hex</code> file for code upload to the flash, it also generates a <code>.eep</code> file with all content to be uploaded to EEPROM: this is based on all variables defined with attribute <code>EEMEM</code> in your program.</li>
<li><code>make eeprom</code> uses the above <code>.eep</code> file an upload it to the MCU to program EEPROM content.</li>
</ol>
<p>IMPORTANT: note that, as relevant as this example can be for this tutorial, you do not need to write all this code, with FastArduino, to play a sequence of tones: you may use <code>TonePlayer</code> class that odes it all for you, and can handle arrays stored in SRAM, EEPROM or Flash memory.</p>
<h2>Writing content to EEPROM</h2>
<p>There are also programs that may need to store content to EEPROM during their execution. This is possible with FastArduino EEPROM support.</p>
<p>Please do note, however, that the number of writes an EEPROM can support is rather limited (100'000 as per AVR MCU datasheet), hence you should refrain from writing too many times to the EEPROM.</p>
<p>Also, do note that writing a byte to the EEPROM is not the same as writing a byte to SRAM, this is much slower (typically between 1.8ms and 3.4ms).</p>
<p>The following example stores a WIFI access point name and password in EEPROM; through USB connected to a serial console, it asks the user if she wants to use current settings (provided there are already WIFI settings in EEPROM), and if not, it asks the user to fill in new WIFI credentials and stores them to EEPROM for next time the program will be reset.</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="preprocessor">#include &lt;string.h&gt;</span></div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;<span class="preprocessor">#include &lt;<a class="code" href="eeprom_8h.html">fastarduino/eeprom.h</a>&gt;</span></div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;<span class="preprocessor">#include &lt;<a class="code" href="uart_8h.html">fastarduino/uart.h</a>&gt;</span></div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160; </div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;<span class="comment">// Define vectors we need in the example</span></div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;<a class="code" href="uart_8h.html#a8bd735d1a3a5a0a8e3253fd3f1720b29">REGISTER_UART_ISR</a>(0)</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;static const <a class="code" href="namespaceboard.html">board</a>::<a class="code" href="namespaceboard.html#a8541ca1f10a050c4356d6ccd76d9a907">USART</a> <a class="code" href="namespaceboard.html#a8541ca1f10a050c4356d6ccd76d9a907">USART</a> = <a class="code" href="namespaceboard.html">board</a>::<a class="code" href="namespaceboard.html#a8541ca1f10a050c4356d6ccd76d9a907">USART</a>::USART0;</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160; </div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;<span class="comment">// Buffers for UART</span></div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;static const uint8_t INPUT_BUFFER_SIZE = 64;</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;static const uint8_t OUTPUT_BUFFER_SIZE = 64;</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;static <span class="keywordtype">char</span> input_buffer[INPUT_BUFFER_SIZE];</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;static <span class="keywordtype">char</span> output_buffer[OUTPUT_BUFFER_SIZE];</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160; </div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;<span class="comment">// EEPROM stored information</span></div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;static const uint8_t MAX_LEN = 64;</div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;<span class="keywordtype">char</span> wifi_name[MAX_LEN+1] EEMEM = &quot;&quot;;</div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;<span class="keywordtype">char</span> wifi_password[MAX_LEN+1] EEMEM = &quot;&quot;;</div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160; </div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;using namespace <a class="code" href="namespaceeeprom.html">eeprom</a>;</div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;using <a class="code" href="namespacestreams.html">streams</a>::<a class="code" href="namespacestreams.html#a25bd12279d518b57e4fb97c533c17b22">endl</a>;</div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;using <a class="code" href="namespacestreams.html">streams</a>::<a class="code" href="namespacestreams.html#a155684415ba442e665f551819429b3a0">flush</a>;</div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;using <a class="code" href="namespacestreams.html">streams</a>::<a class="code" href="namespacestreams.html#a69896b602e1678789bbad7b9fa98e3a3">noskipws</a>;</div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;using <a class="code" href="namespacestreams.html">streams</a>::<a class="code" href="namespacestreams.html#a76316854cb7b9c0c7688d02c660ed369">skipws</a>;</div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160; </div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;<span class="keywordtype">int</span> main()</div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;{</div>
<div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;    <a class="code" href="namespaceboard.html#a2529f85498783a75dc75c281e0b754d3">board::init</a>();</div>
<div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;    sei();</div>
<div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;    </div>
<div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;    <span class="comment">// Start UART</span></div>
<div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;    <a class="code" href="classserial_1_1hard_1_1_u_a_r_t.html">serial::hard::UART&lt;USART&gt;</a> uart{input_buffer, output_buffer};</div>
<div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;    uart.<a class="code" href="classserial_1_1hard_1_1_u_a_r_t.html#ae89048a3748401f4e1c6defa02bca8f6">begin</a>(115200);</div>
<div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160; </div>
<div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;    <a class="code" href="classstreams_1_1istream.html">streams::istream</a> in = uart.in();</div>
<div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;    <a class="code" href="classstreams_1_1ostream.html">streams::ostream</a> out = uart.out();</div>
<div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160; </div>
<div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;    <span class="comment">// Get current WIFI name/password from EEPROM</span></div>
<div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;    <span class="keywordtype">char</span> wifi[MAX_LEN+1];</div>
<div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;    EEPROM::read(wifi_name, wifi, MAX_LEN+1);</div>
<div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;    <span class="keywordtype">char</span> password[MAX_LEN+1];</div>
<div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;    EEPROM::read(wifi_password, password, MAX_LEN+1);</div>
<div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160; </div>
<div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;    <span class="comment">// If WIFI present check if user wants to keep it</span></div>
<div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;    <span class="keywordtype">bool</span> ask = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;    <span class="keywordflow">if</span> (strlen(wifi))</div>
<div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;    {</div>
<div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;        <span class="keywordtype">char</span> answer;</div>
<div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;        out &lt;&lt; <a class="code" href="flash_8h.html#a16c40764aaba0de309f5ff429c8bac15">F</a>(<span class="stringliteral">&quot;Do you want to use WIFI `&quot;</span>) &lt;&lt; wifi &lt;&lt; <a class="code" href="flash_8h.html#a16c40764aaba0de309f5ff429c8bac15">F</a>(<span class="stringliteral">&quot;`? [Y/n] :&quot;</span>) &lt;&lt; <a class="code" href="namespacestreams.html#a155684415ba442e665f551819429b3a0">flush</a>;</div>
<div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;        in &gt;&gt; <a class="code" href="namespacestreams.html#a76316854cb7b9c0c7688d02c660ed369">skipws</a> &gt;&gt; answer;</div>
<div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;        in.<a class="code" href="classstreams_1_1istream.html#a99dafd2dce58830708b65dd4f4b6136f">ignore</a>(0, <span class="charliteral">&#39;\n&#39;</span>);</div>
<div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;        ask = (toupper(answer) == <span class="charliteral">&#39;N&#39;</span>);</div>
<div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;    }</div>
<div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160; </div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;    <span class="comment">// Ask for WIKI name &amp; password if needed</span></div>
<div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;    <span class="keywordflow">if</span> (ask)</div>
<div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;    {</div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;        out &lt;&lt; <a class="code" href="flash_8h.html#a16c40764aaba0de309f5ff429c8bac15">F</a>(<span class="stringliteral">&quot;Enter WIFI name: &quot;</span>) &lt;&lt; <a class="code" href="namespacestreams.html#a155684415ba442e665f551819429b3a0">flush</a>;</div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;        in.<a class="code" href="classstreams_1_1istream.html#ab2b480d5069588a6e9c97e89dfd7c4d8">getline</a>(wifi, MAX_LEN+1);</div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;        out &lt;&lt; <a class="code" href="flash_8h.html#a16c40764aaba0de309f5ff429c8bac15">F</a>(<span class="stringliteral">&quot;Enter WIFI password: &quot;</span>) &lt;&lt; <a class="code" href="namespacestreams.html#a155684415ba442e665f551819429b3a0">flush</a>;</div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;        in.<a class="code" href="classstreams_1_1istream.html#ab2b480d5069588a6e9c97e89dfd7c4d8">getline</a>(password, MAX_LEN+1);</div>
<div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;        <span class="comment">// Store new settings to EEPROM</span></div>
<div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;        EEPROM::write(wifi_name, wifi, strlen(wifi) + 1);</div>
<div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;        EEPROM::write(wifi_password, password, strlen(password) + 1);</div>
<div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;    }</div>
<div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160; </div>
<div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;    <span class="comment">// Start real program here, using wifi and password</span></div>
<div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;    <span class="comment">//...</span></div>
<div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;    out &lt;&lt; <a class="code" href="flash_8h.html#a16c40764aaba0de309f5ff429c8bac15">F</a>(<span class="stringliteral">&quot;WIFI: &quot;</span>) &lt;&lt; wifi &lt;&lt; <a class="code" href="namespacestreams.html#a25bd12279d518b57e4fb97c533c17b22">endl</a>;</div>
<div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;    out &lt;&lt; <a class="code" href="flash_8h.html#a16c40764aaba0de309f5ff429c8bac15">F</a>(<span class="stringliteral">&quot;Password: &quot;</span>) &lt;&lt; password &lt;&lt; <a class="code" href="namespacestreams.html#a25bd12279d518b57e4fb97c533c17b22">endl</a>;</div>
<div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;}</div>
</div><!-- fragment --><p>Most of this snippet is code that deals with input/output streams through UART; we will not explain it here as it is already demonstrated in a previous tutorial section.</p>
<p>We will focus on EEPROM sections:  </p><div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> uint8_t MAX_LEN = 64;</div>
<div class="line"><span class="keywordtype">char</span> wifi_name[MAX_LEN+1] EEMEM = <span class="stringliteral">&quot;&quot;</span>;</div>
<div class="line"><span class="keywordtype">char</span> wifi_password[MAX_LEN+1] EEMEM = <span class="stringliteral">&quot;&quot;</span>;</div>
</div><!-- fragment --><p> Here we define <code>wifi_name</code> and <code>wifi_password</code> as strings of 64 characters maximum (+ terminating &lsquo;&rsquo;\0'`), stored in EEPROM and both "initialized" as empty strings.</p>
<p>Initialization here does not mean that these variables will automatically be empty string the first time this program is executed. It means that after <code>make build</code> is invoked, an <code>.eep</code> file is generated in order to be uploaded to EEPROM, and that file contains both variables as empty strings. Hence, provided you have uploaded that <code>.eep</code> file to your MCU EEPROM, both variables will then be empty strings when first read from EEPTOM by your program.</p>
<p>In the <code>main()</code> function, we then read both variables from EEPROM into local variables: </p><div class="fragment"><div class="line">    <span class="keywordtype">char</span> wifi[MAX_LEN+1];</div>
<div class="line">    EEPROM::read(wifi_name, wifi, MAX_LEN+1);</div>
<div class="line">    <span class="keywordtype">char</span> password[MAX_LEN+1];</div>
<div class="line">    EEPROM::read(wifi_password, password, MAX_LEN+1);</div>
</div><!-- fragment --><p> Here we use <code>EEPROM::read(uint16_t address, T* value, uint16_t count)</code> function template, instantiated with <code>T = char</code>: we have to specify the count of characters to be read, i.e. the maximum allowed string size, plus the null termination.</p>
<p>As in the previous example, we use <code>wifi_name</code> and <code>wifi_password</code> variables to provide the address in EEPROM, of the location of these 2 strings.</p>
<p>Later in <code>main()</code>, if the user decided to enter a new WIFI netwrok name and pasword, those are written immediately to EEPROM: </p><div class="fragment"><div class="line">        EEPROM::write(wifi_name, wifi, strlen(wifi) + 1);</div>
<div class="line">        EEPROM::write(wifi_password, password, strlen(password) + 1);</div>
</div><!-- fragment --><p> The <code>EEPROM::write()</code> function arguments are similar to <code>EEPROM::read()</code> arguments.</p>
<p>Note that here, we do not have to write the full string allocated space to the EEPROM but only the currently relevant count of characters, e.g. if <code>wifi</code> was input as <code>"Dummy"</code>, we will write only <code>6</code> characters for <code>wifi_name</code> in EEPROM, i.e. the actual string length <code>5</code> + <code>1</code> for null termination. This is particularly improtant to do this as writing bytes to EEPROM is very slow (up to ~4ms) so we want to limit that writing time to the strict minimum necessary.</p>
<p>Because writing content to the EEPROM is a very slow operation, there are situations where you do not want to "stop" your program running because it is waiting for <code>EEPROM::write()</code> operations to complete.</p>
<p>This is the reason why <code>eeprom</code> namespace also defines a <code>QueuedWriter</code> class that uses interruptions to write content to EEPROM, allowing your <code>main()</code> function to run normally during EEPROM writes. For more details, please check the API.</p>
<h1><a class="anchor" id="spi"></a>Advanced: SPI devices example </h1>
<p>FastArduino supports SPI (<a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface">Serial Peripheral Interface</a>) as provided by all AVR MCU (ATmega MCU support SPI natively, ATtiny MCU support it through their USI, Universal Serial Interface).</p>
<p>FastArduino also brings specific support to some SPI devices:</p><ul>
<li>NRF24L01P (radio-frequency device)</li>
<li>WinBond chips (flash memory devices)</li>
</ul>
<p>Basically, FastArduino core SPI API is limited to the following:</p><ul>
<li><code><a class="el" href="namespacespi.html#a7829182c423612511a05fa0434d7673e" title="This function must be called once in your program, before any use of an SPI device.">spi::init()</a></code> function to call once before any use of SPI in your program</li>
<li><code><a class="el" href="classspi_1_1_s_p_i_device.html" title="Base class for any SPI slave device.">spi::SPIDevice</a></code> class that is the abstract base class of all concrete SPI devices</li>
</ul>
<p>Although very important, this sole API is useless for any tutorial example! If you want to develop an API for your own SPI device then please refer to <code><a class="el" href="classspi_1_1_s_p_i_device.html" title="Base class for any SPI slave device.">spi::SPIDevice</a></code> API documentation.</p>
<p>Hence, to illustrate SPI usage in this tutorial, we will focus on a concrete example with the WinBond memory chip.</p>
<p>The following example reads, erases, writes and reads again flash memory:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="preprocessor">#include &lt;<a class="code" href="winbond_8h.html">fastarduino/devices/winbond.h</a>&gt;</span></div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;<span class="preprocessor">#include &lt;<a class="code" href="time_8h.html">fastarduino/time.h</a>&gt;</span></div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;<span class="preprocessor">#include &lt;<a class="code" href="uart_8h.html">fastarduino/uart.h</a>&gt;</span></div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160; </div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;<span class="keyword">static</span> <span class="keyword">const</span> uint8_t OUTPUT_BUFFER_SIZE = 64;</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;<span class="keyword">static</span> <span class="keywordtype">char</span> output_buffer[OUTPUT_BUFFER_SIZE];</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;constexpr <span class="keyword">const</span> <a class="code" href="namespaceboard.html#a8541ca1f10a050c4356d6ccd76d9a907">board::USART</a> UART = board::USART::USART0;</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;<a class="code" href="uart_8h.html#aa33c57bb6fa1e93177abb21fe8fecb10">REGISTER_UATX_ISR</a>(0)</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160; </div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;using namespace <a class="code" href="namespacestreams.html">streams</a>;</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160; </div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;constexpr const <a class="code" href="namespaceboard.html">board</a>::<a class="code" href="namespaceboard.html#a5082846fef8fdfb8c8cbcf1163c7b404">DigitalPin</a> CS = <a class="code" href="namespaceboard.html">board</a>::<a class="code" href="namespaceboard.html#a5082846fef8fdfb8c8cbcf1163c7b404">DigitalPin</a>::D7_PD7;</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;constexpr const <span class="keywordtype">size_t</span> DATA_SIZE = 256;</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;static uint8_t data[DATA_SIZE];</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;constexpr const uint32_t PAGE = 0x010000;</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160; </div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;<span class="keywordtype">int</span> main()</div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;{</div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;    <a class="code" href="namespaceboard.html#a2529f85498783a75dc75c281e0b754d3">board::init</a>();</div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;    sei();</div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160; </div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;    <a class="code" href="classserial_1_1hard_1_1_u_a_t_x.html">serial::hard::UATX&lt;UART&gt;</a> uart{output_buffer};</div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;    uart.<a class="code" href="classserial_1_1hard_1_1_u_a_t_x.html#a64b04d0617b28fd343a01f865dee787e">begin</a>(115200);</div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;    ostream out = uart.out();</div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160; </div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;    <span class="comment">// Initialize SPI and device</span></div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;    <a class="code" href="namespacespi.html#a7829182c423612511a05fa0434d7673e">spi::init</a>();</div>
<div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;    <a class="code" href="classdevices_1_1_win_bond.html">devices::WinBond&lt;CS&gt;</a> <a class="code" href="namespaceflash.html">flash</a>;</div>
<div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;    <a class="code" href="namespacetime.html#af13fd17ddf6b751b8161691e608892b2">time::delay_ms</a>(1000);   </div>
<div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;    out &lt;&lt; <a class="code" href="flash_8h.html#a16c40764aaba0de309f5ff429c8bac15">F</a>(<span class="stringliteral">&quot;S: &quot;</span>) &lt;&lt; <a class="code" href="namespacestreams.html#a91675bd61b31e7382e8655930606f62f">hex</a> &lt;&lt; <a class="code" href="namespaceflash.html">flash</a>.status().value &lt;&lt; <a class="code" href="namespacestreams.html#a25bd12279d518b57e4fb97c533c17b22">endl</a>;</div>
<div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160; </div>
<div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;    <span class="comment">// Read and display one page of flash memory</span></div>
<div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;    <a class="code" href="namespaceflash.html">flash</a>.read_data(PAGE, data, <span class="keyword">sizeof</span> data);</div>
<div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;    out &lt;&lt; <a class="code" href="flash_8h.html#a16c40764aaba0de309f5ff429c8bac15">F</a>(<span class="stringliteral">&quot;RD, S: &quot;</span>) &lt;&lt; <a class="code" href="namespacestreams.html#a91675bd61b31e7382e8655930606f62f">hex</a> &lt;&lt; <a class="code" href="namespaceflash.html">flash</a>.status().value &lt;&lt; <a class="code" href="namespacestreams.html#a25bd12279d518b57e4fb97c533c17b22">endl</a>;</div>
<div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;    out &lt;&lt; <a class="code" href="flash_8h.html#a16c40764aaba0de309f5ff429c8bac15">F</a>(<span class="stringliteral">&quot;Pg RD:&quot;</span>) &lt;&lt; <a class="code" href="namespacestreams.html#a25bd12279d518b57e4fb97c533c17b22">endl</a>;</div>
<div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;    <span class="keywordflow">for</span> (uint16_t i = 0; i &lt; <span class="keyword">sizeof</span> data; ++i)</div>
<div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;    {</div>
<div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;        out &lt;&lt; <a class="code" href="namespacestreams.html#a91675bd61b31e7382e8655930606f62f">hex</a> &lt;&lt; data[i] &lt;&lt; <span class="charliteral">&#39; &#39;</span>;</div>
<div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;        <span class="keywordflow">if</span> ((i + 1) % 16 == 0) out &lt;&lt; <a class="code" href="namespacestreams.html#a25bd12279d518b57e4fb97c533c17b22">endl</a>;</div>
<div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;    }</div>
<div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;    out &lt;&lt; <a class="code" href="namespacestreams.html#a25bd12279d518b57e4fb97c533c17b22">endl</a>;</div>
<div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;    </div>
<div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;    <span class="comment">// Erase one page of flash memory before writing</span></div>
<div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;    <a class="code" href="namespaceflash.html">flash</a>.enable_write();</div>
<div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;    <a class="code" href="namespaceflash.html">flash</a>.erase_sector(PAGE);</div>
<div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;    out &lt;&lt; <a class="code" href="flash_8h.html#a16c40764aaba0de309f5ff429c8bac15">F</a>(<span class="stringliteral">&quot;Erase, S: &quot;</span>) &lt;&lt; <a class="code" href="namespacestreams.html#a91675bd61b31e7382e8655930606f62f">hex</a> &lt;&lt; <a class="code" href="namespaceflash.html">flash</a>.status().value &lt;&lt; <a class="code" href="namespacestreams.html#a25bd12279d518b57e4fb97c533c17b22">endl</a>;</div>
<div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;    <a class="code" href="namespaceflash.html">flash</a>.wait_until_ready(10);</div>
<div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;    out &lt;&lt; <a class="code" href="flash_8h.html#a16c40764aaba0de309f5ff429c8bac15">F</a>(<span class="stringliteral">&quot;Wait, S: &quot;</span>) &lt;&lt; <a class="code" href="namespacestreams.html#a91675bd61b31e7382e8655930606f62f">hex</a> &lt;&lt; <a class="code" href="namespaceflash.html">flash</a>.status().value &lt;&lt; <a class="code" href="namespacestreams.html#a25bd12279d518b57e4fb97c533c17b22">endl</a>;</div>
<div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160; </div>
<div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;    <span class="comment">// Write one page of flash memory</span></div>
<div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;    <span class="keywordflow">for</span> (uint16_t i = 0; i &lt; <span class="keyword">sizeof</span> data; ++i) data[i] = uint8_t(i);</div>
<div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;    <a class="code" href="namespaceflash.html">flash</a>.enable_write();</div>
<div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;    <a class="code" href="namespaceflash.html">flash</a>.write_page(PAGE, data, (DATA_SIZE &gt;= 256 ? 0 : DATA_SIZE));</div>
<div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;    out &lt;&lt; <a class="code" href="flash_8h.html#a16c40764aaba0de309f5ff429c8bac15">F</a>(<span class="stringliteral">&quot;Write, S: &quot;</span>) &lt;&lt; <a class="code" href="namespacestreams.html#a91675bd61b31e7382e8655930606f62f">hex</a> &lt;&lt; <a class="code" href="namespaceflash.html">flash</a>.status().value &lt;&lt; <a class="code" href="namespacestreams.html#a25bd12279d518b57e4fb97c533c17b22">endl</a>;</div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;    <a class="code" href="namespaceflash.html">flash</a>.wait_until_ready(10);</div>
<div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;    out &lt;&lt; <a class="code" href="flash_8h.html#a16c40764aaba0de309f5ff429c8bac15">F</a>(<span class="stringliteral">&quot;Wait, S: &quot;</span>) &lt;&lt; <a class="code" href="namespacestreams.html#a91675bd61b31e7382e8655930606f62f">hex</a> &lt;&lt; <a class="code" href="namespaceflash.html">flash</a>.status().value &lt;&lt; <a class="code" href="namespacestreams.html#a25bd12279d518b57e4fb97c533c17b22">endl</a>;</div>
<div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;    </div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;    <span class="comment">// Read back and display page of flash memory just written</span></div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;    <span class="keywordflow">for</span> (uint16_t i = 0; i &lt; <span class="keyword">sizeof</span> data; ++i) data[i] = 0;</div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;    <a class="code" href="namespaceflash.html">flash</a>.read_data(PAGE, data, <span class="keyword">sizeof</span> data);</div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;    out &lt;&lt; <a class="code" href="flash_8h.html#a16c40764aaba0de309f5ff429c8bac15">F</a>(<span class="stringliteral">&quot;Read, S: &quot;</span>) &lt;&lt; <a class="code" href="namespacestreams.html#a91675bd61b31e7382e8655930606f62f">hex</a> &lt;&lt; <a class="code" href="namespaceflash.html">flash</a>.status().value &lt;&lt; <a class="code" href="namespacestreams.html#a25bd12279d518b57e4fb97c533c17b22">endl</a>;</div>
<div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;    out &lt;&lt; <a class="code" href="flash_8h.html#a16c40764aaba0de309f5ff429c8bac15">F</a>(<span class="stringliteral">&quot;Pg RD:&quot;</span>) &lt;&lt; <a class="code" href="namespacestreams.html#a25bd12279d518b57e4fb97c533c17b22">endl</a>;</div>
<div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;    <span class="keywordflow">for</span> (uint16_t i = 0; i &lt; <span class="keyword">sizeof</span> data; ++i)</div>
<div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;    {</div>
<div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;        out &lt;&lt; <a class="code" href="namespacestreams.html#a91675bd61b31e7382e8655930606f62f">hex</a> &lt;&lt; data[i] &lt;&lt; <span class="charliteral">&#39; &#39;</span>;</div>
<div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;        <span class="keywordflow">if</span> ((i + 1) % 16 == 0) out &lt;&lt; <a class="code" href="namespacestreams.html#a25bd12279d518b57e4fb97c533c17b22">endl</a>;</div>
<div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;    }</div>
<div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;    out &lt;&lt; <a class="code" href="namespacestreams.html#a25bd12279d518b57e4fb97c533c17b22">endl</a>;</div>
<div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;}</div>
</div><!-- fragment --><p>The first important piece of code initializes the SPI system and the WinBond device:  </p><div class="fragment"><div class="line">    <span class="comment">// Initialize SPI and device</span></div>
<div class="line">    <a class="code" href="namespacespi.html#a7829182c423612511a05fa0434d7673e">spi::init</a>();</div>
<div class="line">    <a class="code" href="classdevices_1_1_win_bond.html">devices::WinBond&lt;CS&gt;</a> <a class="code" href="namespaceflash.html">flash</a>;</div>
<div class="line">    <a class="code" href="namespacetime.html#af13fd17ddf6b751b8161691e608892b2">time::delay_ms</a>(1000);   </div>
<div class="line">    out &lt;&lt; <a class="code" href="flash_8h.html#a16c40764aaba0de309f5ff429c8bac15">F</a>(<span class="stringliteral">&quot;S: &quot;</span>) &lt;&lt; <a class="code" href="namespacestreams.html#a91675bd61b31e7382e8655930606f62f">hex</a> &lt;&lt; <a class="code" href="namespaceflash.html">flash</a>.status().value &lt;&lt; <a class="code" href="namespacestreams.html#a25bd12279d518b57e4fb97c533c17b22">endl</a>;</div>
</div><!-- fragment --><p> Note that <code><a class="el" href="classdevices_1_1_win_bond.html" title="SPI device driver for WinBond flash memory chips, like W25Q80BV (8 Mbit flash).">devices::WinBond</a></code> is a template that takes as parameter the <code><a class="el" href="namespaceboard.html#a5082846fef8fdfb8c8cbcf1163c7b404" title="Defines all available digital input/output pins of the target MCU.">board::DigitalPin</a></code> that will be used as "Chip Select" pin (<b>CS</b>, part of SPI wiring).</p>
<p><code>status()</code> returns the WinBond status as specified in the chip datasheet and implemented in FastArduino <code><a class="el" href="winbond_8h.html" title="API to handle WinBond flash memory chips through SPI interface.">winbond.h</a></code>.</p>
<p>Next code piece is reading a part of a flash page from the device: </p><div class="fragment"><div class="line">    <a class="code" href="namespaceflash.html">flash</a>.read_data(PAGE, data, <span class="keyword">sizeof</span> data);</div>
</div><!-- fragment --><p> There is nothing special to mention here, the API is straightforward.</p>
<p>Then the example write one page of flash memory. This must be done in 2 steps:</p><ol type="1">
<li>Erase flash page</li>
<li>Write flash page</li>
</ol>
<div class="fragment"><div class="line">    <span class="comment">// Erase one page of flash memory before writing</span></div>
<div class="line">    <a class="code" href="namespaceflash.html">flash</a>.enable_write();</div>
<div class="line">    <a class="code" href="namespaceflash.html">flash</a>.erase_sector(PAGE);</div>
<div class="line">    out &lt;&lt; <a class="code" href="flash_8h.html#a16c40764aaba0de309f5ff429c8bac15">F</a>(<span class="stringliteral">&quot;Erase, S: &quot;</span>) &lt;&lt; <a class="code" href="namespacestreams.html#a91675bd61b31e7382e8655930606f62f">hex</a> &lt;&lt; <a class="code" href="namespaceflash.html">flash</a>.status().value &lt;&lt; <a class="code" href="namespacestreams.html#a25bd12279d518b57e4fb97c533c17b22">endl</a>;</div>
<div class="line">    <a class="code" href="namespaceflash.html">flash</a>.wait_until_ready(10);</div>
<div class="line">    out &lt;&lt; <a class="code" href="flash_8h.html#a16c40764aaba0de309f5ff429c8bac15">F</a>(<span class="stringliteral">&quot;Wait, S: &quot;</span>) &lt;&lt; <a class="code" href="namespacestreams.html#a91675bd61b31e7382e8655930606f62f">hex</a> &lt;&lt; <a class="code" href="namespaceflash.html">flash</a>.status().value &lt;&lt; <a class="code" href="namespacestreams.html#a25bd12279d518b57e4fb97c533c17b22">endl</a>;</div>
</div><!-- fragment --><p> Any write action must be preceded with a call to <code>enable_write()</code> and followed by <code>wait_until_ready()</code> (because writing to flash memory is rather long, all timing values can be found in the datasheet). FastArduino provides API for every case.</p>
<p>Erasing, like writing, cannot be done on single bytes, but must be done on packs of bytes (e.g. pages, sectors, blocks, as defined in WinBond datasheet).</p>
<p>Here is the code performing the writing: </p><div class="fragment"><div class="line">    <span class="comment">// Write one page of flash memory</span></div>
<div class="line">    <span class="keywordflow">for</span> (uint16_t i = 0; i &lt; <span class="keyword">sizeof</span> data; ++i) data[i] = uint8_t(i);</div>
<div class="line">    <a class="code" href="namespaceflash.html">flash</a>.enable_write();</div>
<div class="line">    <a class="code" href="namespaceflash.html">flash</a>.write_page(PAGE, data, (DATA_SIZE &gt;= 256 ? 0 : DATA_SIZE));</div>
<div class="line">    out &lt;&lt; <a class="code" href="flash_8h.html#a16c40764aaba0de309f5ff429c8bac15">F</a>(<span class="stringliteral">&quot;Write, S: &quot;</span>) &lt;&lt; <a class="code" href="namespacestreams.html#a91675bd61b31e7382e8655930606f62f">hex</a> &lt;&lt; <a class="code" href="namespaceflash.html">flash</a>.status().value &lt;&lt; <a class="code" href="namespacestreams.html#a25bd12279d518b57e4fb97c533c17b22">endl</a>;</div>
<div class="line">    <a class="code" href="namespaceflash.html">flash</a>.wait_until_ready(10);</div>
<div class="line">    out &lt;&lt; <a class="code" href="flash_8h.html#a16c40764aaba0de309f5ff429c8bac15">F</a>(<span class="stringliteral">&quot;Wait, S: &quot;</span>) &lt;&lt; <a class="code" href="namespacestreams.html#a91675bd61b31e7382e8655930606f62f">hex</a> &lt;&lt; <a class="code" href="namespaceflash.html">flash</a>.status().value &lt;&lt; <a class="code" href="namespacestreams.html#a25bd12279d518b57e4fb97c533c17b22">endl</a>;</div>
</div><!-- fragment --><p> There is only one API, writing at most one page (256 bytes) at once. Please note the last argument of <code>write_page()</code> which is the size of data to write. For performance reasons, size is an <code>uint8_t</code>, consequently, <code>0</code> is used to mean <code>256</code> bytes, i.e. a complete page.</p>
<p>The last part of the example reads again the data page and displays it for control. This is the same code as the reading code presented above.</p>
<h1><a class="anchor" id="i2c"></a>Advanced: I2C devices example </h1>
<p>FastArduino supports I2C (<a href="https://en.wikipedia.org/wiki/I%C2%B2C">Inter-Integrated Circuit</a>) as provided by all AVR MCU (ATmega MCU support I2C natively, ATtiny MCU support it through their USI, Universal Serial Interface). I2C is also often called <em>TWI</em> for Two-Wires Interface.</p>
<p>FastArduino also brings specific support to several I2C devices:</p><ul>
<li>DS1307 (real-time clock)</li>
<li>MPU6050 (accelerometer and gyroscope)</li>
<li>HMC5883L (compass)</li>
<li>MCP23008 (8-Bit I/O Expander)</li>
<li>MCP23017 (16-Bit I/O Expander)</li>
</ul>
<p>FastArduino core I2C API is defined in several headers (namespace <code><a class="el" href="namespacei2c.html" title="Define API to define and manage I2C devices.">i2c</a></code>) and made of a few types:</p><ul>
<li><code><a class="el" href="i2c_8h.html" title="I2C API common definitions.">i2c.h</a></code> contains a few constants and enumerations used everywhere else in the I2C API</li>
<li><code><a class="el" href="i2c__handler_8h.html" title="Common I2C Manager API.">i2c_handler.h</a></code> defines several template classes defining different kinds of "I2C Manager" which are central to the API</li>
<li><code><a class="el" href="i2c__device_8h.html" title="I2C Device API.">i2c_device.h</a></code> mainly defines <code><a class="el" href="classi2c_1_1_i2_c_device.html" title="Base class for all I2C devices.">i2c::I2CDevice</a></code> template class, which is the abstract base class of all concrete I2C devices</li>
</ul>
<p>Other more specific headers exist but shall not be directly included in programs.</p>
<p>In FastArduino, I2C communication is centralized by an I2C Manager; there are several flavors of I2C Manager defined in FastArduino, with distinct characteristics such as:</p><ul>
<li>synchronous (all MCU) or asynchronous (ATmega only)</li>
<li>I2C mode supported (fast 400kHz or standard 100kHz)</li>
<li>policy to follow in case of failure during an I2C transaction</li>
<li>...</li>
</ul>
<p>In this tutorial, we will use the simplest I2C Manager provided by FastArduino: <code><a class="el" href="classi2c_1_1_i2_c_sync_manager.html" title="Synchronous I2C Manager for ATmega architecture.">i2c::I2CSyncManager</a></code>, which handles only synchronous (blocking) I2C operations.</p>
<p>There are also asynchronous I2C Managers but they will not be explained here. If you want to learn more about there, please take a look at the API and examples using it.</p>
<p>In order to illustrate concretely I2C API usage in this tutorial, we will focus on a concrete example with the DS1307 RTC chip. If you want to develop an API for your own I2C device then please refer to <code><a class="el" href="classi2c_1_1_i2_c_device.html" title="Base class for all I2C devices.">i2c::I2CDevice</a></code> API documentation and the <a href="i2cdevices.html">dedicated tutorial</a>.</p>
<p>The following example reads the current clock time from a DS1307 chip:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="preprocessor">#include &lt;<a class="code" href="time_8h.html">fastarduino/time.h</a>&gt;</span></div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;<span class="preprocessor">#include &lt;<a class="code" href="i2c__handler_8h.html">fastarduino/i2c_handler.h</a>&gt;</span></div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;<span class="preprocessor">#include &lt;<a class="code" href="ds1307_8h.html">fastarduino/devices/ds1307.h</a>&gt;</span></div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;<span class="preprocessor">#include &lt;<a class="code" href="uart_8h.html">fastarduino/uart.h</a>&gt;</span></div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160; </div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;<span class="keyword">static</span> constexpr <span class="keyword">const</span> <a class="code" href="namespaceboard.html#a8541ca1f10a050c4356d6ccd76d9a907">board::USART</a> UART = board::USART::USART0;</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;<span class="keyword">static</span> constexpr <span class="keyword">const</span> uint8_t OUTPUT_BUFFER_SIZE = 64;</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;<span class="keyword">static</span> <span class="keywordtype">char</span> output_buffer[OUTPUT_BUFFER_SIZE];</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160; </div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;<a class="code" href="uart_8h.html#aa33c57bb6fa1e93177abb21fe8fecb10">REGISTER_UATX_ISR</a>(0)</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160; </div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;using <a class="code" href="namespacedevices.html">devices</a>::rtc::DS1307;</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;using <a class="code" href="namespacedevices.html">devices</a>::rtc::tm;</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;using namespace <a class="code" href="namespacestreams.html">streams</a>;</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160; </div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;<span class="keywordtype">int</span> main() __attribute__((OS_main));</div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;<span class="keywordtype">int</span> main()</div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;{</div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;    <a class="code" href="namespaceboard.html#a2529f85498783a75dc75c281e0b754d3">board::init</a>();</div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;    sei();</div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;    <a class="code" href="classserial_1_1hard_1_1_u_a_t_x.html">serial::hard::UATX&lt;UART&gt;</a> uart{output_buffer};</div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;    uart.<a class="code" href="classserial_1_1hard_1_1_u_a_t_x.html#a64b04d0617b28fd343a01f865dee787e">begin</a>(115200);</div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;    ostream out = uart.out();</div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;    </div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;    <span class="keyword">using</span> MANAGER = <a class="code" href="classi2c_1_1_i2_c_sync_manager.html">i2c::I2CSyncManager&lt;i2c::I2CMode::STANDARD&gt;</a>;</div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;    MANAGER manager;</div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;    manager.<a class="code" href="classi2c_1_1_abstract_i2_c_sync_manager.html#a66b6a7902f2d3e2354f344c154f4a841">begin</a>();</div>
<div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;    DS1307 rtc{manager};</div>
<div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;    </div>
<div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;    tm now;</div>
<div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;    rtc.get_datetime(now);</div>
<div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;    out &lt;&lt; <a class="code" href="namespacestreams.html#adaf650921b3a5d448f8aac51dba924d2">dec</a> &lt;&lt; <a class="code" href="flash_8h.html#a16c40764aaba0de309f5ff429c8bac15">F</a>(<span class="stringliteral">&quot;RTC: [&quot;</span>) </div>
<div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;        &lt;&lt; uint8_t(now.tm_wday) &lt;&lt; <span class="charliteral">&#39;]&#39;</span></div>
<div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;        &lt;&lt; now.tm_mday &lt;&lt; <span class="charliteral">&#39;.&#39;</span></div>
<div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;        &lt;&lt; now.tm_mon &lt;&lt; <span class="charliteral">&#39;.&#39;</span></div>
<div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;        &lt;&lt; now.tm_year &lt;&lt; <span class="charliteral">&#39; &#39;</span></div>
<div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;        &lt;&lt; now.tm_hour &lt;&lt; <span class="charliteral">&#39;:&#39;</span></div>
<div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;        &lt;&lt; now.tm_min &lt;&lt; <span class="charliteral">&#39;:&#39;</span></div>
<div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;        &lt;&lt; now.tm_sec &lt;&lt; <a class="code" href="namespacestreams.html#a25bd12279d518b57e4fb97c533c17b22">endl</a>;</div>
<div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;    </div>
<div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;    manager.end();</div>
<div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;}</div>
</div><!-- fragment --><p>This example has 3 important parts.</p>
<p>The first part is the I2C and the RTC device initialization:  </p><div class="fragment"><div class="line">    <span class="keyword">using</span> MANAGER = <a class="code" href="classi2c_1_1_i2_c_sync_manager.html">i2c::I2CSyncManager&lt;i2c::I2CMode::STANDARD&gt;</a>;</div>
<div class="line">    MANAGER manager;</div>
<div class="line">    manager.<a class="code" href="classi2c_1_1_abstract_i2_c_sync_manager.html#a66b6a7902f2d3e2354f344c154f4a841">begin</a>();</div>
<div class="line">    DS1307 rtc{manager};</div>
</div><!-- fragment --><p> <code><a class="el" href="classi2c_1_1_i2_c_sync_manager.html" title="Synchronous I2C Manager for ATmega architecture.">i2c::I2CSyncManager</a></code> is a template class with a parameter of type <code><a class="el" href="namespacei2c.html#ac2780f0139dbc26f4d83a426dad67e36" title="I2C available transmission modes.">i2c::I2CMode</a></code>, which can any of:</p><ul>
<li><code>i2c::I2CMode::STANDARD</code>: slow I2C mode (100 kHz), this the default</li>
<li><code><a class="el" href="namespacei2c.html#ac2780f0139dbc26f4d83a426dad67e36a94e94133f4bdc1794c6b647b8ea134d0" title="I2C Standard mode, less than 100KHz.">i2c::I2CMode::FAST</a></code>: fast I2C mode (400 kHz)</li>
</ul>
<p>The mode selection depends on all devices you wire on the I2C bus, if one is using standard mode, then all the bus must be set to standard mode. Since DS1307 chip does not support fast mode, its device forces standard mode, and that mode must be used for the <code>I2CSyncManager</code>.</p>
<p>For convenience reasons, we define the <code>MANAGER</code> type alias once and then reuse it where needed.</p>
<p>It is important to ensure <code>begin()</code> has been called on <code><a class="el" href="classi2c_1_1_i2_c_sync_manager.html" title="Synchronous I2C Manager for ATmega architecture.">i2c::I2CSyncManager</a></code> before any use of the I2C bus by devices.</p>
<p>Next code piece is reading current clock date and time from the RTC chip: </p><div class="fragment"><div class="line">    tm now;</div>
<div class="line">    rtc.get_datetime(now);</div>
</div><!-- fragment --><p> In that code, <code>tm</code> is a structure containing all fields related to a date/time, <code>get_datetime()</code> just fills it with every information, as can be seen in the following lines of code that display the current date and time.</p>
<p>The last line just stops the I2C circuitry of the AVR MCU. </p><div class="fragment"><div class="line">    manager.end();</div>
</div><!-- fragment --><h1><a class="anchor" id="softuart"></a>Advanced: software UART </h1>
<p>AVR ATtiny MCU do not include hardware UART. For these MCU, UART can be simulated if needed. FastArduino has support for software UART. That support can also be useful with ATmega MCU, where one would need more UART ports than available.</p>
<p>It is important to note that it is not possible, with software UART, to reach bitrates as high as with hardware UART.</p>
<p>Here a simple example using software UATX for output through USB on an Arduino UNO:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="preprocessor">#include &lt;<a class="code" href="soft__uart_8h.html">fastarduino/soft_uart.h</a>&gt;</span></div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160; </div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;constexpr <span class="keyword">const</span> <a class="code" href="namespaceboard.html#a5082846fef8fdfb8c8cbcf1163c7b404">board::DigitalPin</a> TX = board::DigitalPin::D1_PD1;</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160; </div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;<span class="keyword">static</span> constexpr <span class="keyword">const</span> uint8_t OUTPUT_BUFFER_SIZE = 64;</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;<span class="keyword">static</span> <span class="keywordtype">char</span> output_buffer[OUTPUT_BUFFER_SIZE];</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160; </div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;<span class="keyword">using namespace </span><a class="code" href="namespacestreams.html">streams</a>;</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160; </div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;<span class="keywordtype">int</span> main()</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;{</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;    <a class="code" href="namespaceboard.html#a2529f85498783a75dc75c281e0b754d3">board::init</a>();</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;    sei();</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160; </div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;    <a class="code" href="classserial_1_1soft_1_1_u_a_t_x.html">serial::soft::UATX&lt;TX&gt;</a> uart{output_buffer};</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;    uart.<a class="code" href="classserial_1_1soft_1_1_u_a_t_x.html#afd47337a77c3f1146b8c5e2ccc73ce3e">begin</a>(115200);</div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160; </div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;    <a class="code" href="classstreams_1_1ostream.html">ostream</a> out = uart.out();</div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;    uint16_t value = 0x8000;</div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;    out &lt;&lt; <a class="code" href="flash_8h.html#a16c40764aaba0de309f5ff429c8bac15">F</a>(<span class="stringliteral">&quot;value = 0x&quot;</span>) &lt;&lt; <a class="code" href="namespacestreams.html#a91675bd61b31e7382e8655930606f62f">hex</a> &lt;&lt; value </div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;        &lt;&lt; <a class="code" href="flash_8h.html#a16c40764aaba0de309f5ff429c8bac15">F</a>(<span class="stringliteral">&quot;, &quot;</span>) &lt;&lt; <a class="code" href="namespacestreams.html#adaf650921b3a5d448f8aac51dba924d2">dec</a> &lt;&lt; value </div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;        &lt;&lt; <a class="code" href="flash_8h.html#a16c40764aaba0de309f5ff429c8bac15">F</a>(<span class="stringliteral">&quot;, 0&quot;</span>) &lt;&lt; <a class="code" href="namespacestreams.html#a9c09ef93f2d071416214cbe8ed0e1710">oct</a> &lt;&lt; value </div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;        &lt;&lt; <a class="code" href="flash_8h.html#a16c40764aaba0de309f5ff429c8bac15">F</a>(<span class="stringliteral">&quot;, B&quot;</span>) &lt;&lt; <a class="code" href="namespacestreams.html#a79c81dc9afb0ca3ce0495fb7a95e85e1">bin</a> &lt;&lt; value &lt;&lt; <a class="code" href="namespacestreams.html#a25bd12279d518b57e4fb97c533c17b22">endl</a>;</div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;    <span class="keywordflow">return</span> 0;</div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;}</div>
</div><!-- fragment --><p>Except for a few lines, this is the same example as one hardware UART example above in this tutorial.</p>
<p>The main difference is in <code><a class="el" href="classserial_1_1soft_1_1_u_a_t_x.html" title="Software-emulated serial transmitter API.">serial::soft::UATX</a>&lt;TX&gt; uart{output_buffer};</code> where <code>TX</code> is the <code><a class="el" href="namespaceboard.html#a5082846fef8fdfb8c8cbcf1163c7b404" title="Defines all available digital input/output pins of the target MCU.">board::DigitalPin</a></code> where the serial output will be directed.</p>
<p>Besides, the same operations as for <code><a class="el" href="classserial_1_1hard_1_1_u_a_t_x.html" title="Hardware serial transmitter API.">serial::hard::UATX</a></code> are available, in particular output streams work the same with <code><a class="el" href="classserial_1_1soft_1_1_u_a_t_x.html" title="Software-emulated serial transmitter API.">serial::soft::UATX</a></code>.</p>
<p>There are also two classes, <code><a class="el" href="namespaceserial_1_1soft.html#a8df57c2eef46710582fd0e1bbb71aa25" title="Software-emulated serial receiver API.">serial::soft::UARX_EXT</a></code> and <code><a class="el" href="namespaceserial_1_1soft.html#a635413d48cfb8a9c87a89cfe5260f4fe" title="Software-emulated serial receiver API.">serial::soft::UARX_PCI</a></code>, that work similarly as <code><a class="el" href="classserial_1_1hard_1_1_u_a_r_x.html" title="Hardware serial receiver API.">serial::hard::UARX</a></code>:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="preprocessor">#include &lt;<a class="code" href="soft__uart_8h.html">fastarduino/soft_uart.h</a>&gt;</span></div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160; </div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;constexpr <span class="keyword">const</span> <a class="code" href="namespaceboard.html#a7abd24b042402c0691c0ad6db604e7da">board::InterruptPin</a> RX = board::InterruptPin::D0_PD0_PCI2;</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;<span class="preprocessor">#define PCI_NUM 2</span></div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160; </div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;<a class="code" href="soft__uart_8h.html#ab265bfe0b99f589a37c678b6fe187ae9">REGISTER_UARX_PCI_ISR</a>(RX, PCI_NUM)</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160; </div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;<span class="comment">// Buffers for UARX</span></div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;<span class="keyword">static</span> <span class="keyword">const</span> uint8_t INPUT_BUFFER_SIZE = 64;</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;<span class="keyword">static</span> <span class="keywordtype">char</span> input_buffer[INPUT_BUFFER_SIZE];</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160; </div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;<span class="keywordtype">int</span> main()</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;{</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;    <a class="code" href="namespaceboard.html#a2529f85498783a75dc75c281e0b754d3">board::init</a>();</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;    sei();</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;    </div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;    <span class="comment">// Start UART</span></div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;    <a class="code" href="namespaceinterrupt.html#a440f2d705bc60755a4f81a105caef15c">interrupt::PCI_SIGNAL&lt;RX&gt;</a> pci;</div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;    <a class="code" href="classserial_1_1soft_1_1_u_a_r_x_3_01board_1_1_interrupt_pin_00_01_r_x___01_4.html">serial::soft::UARX_PCI&lt;RX&gt;</a> uarx{input_buffer, pci};</div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;    pci.enable();</div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;    uarx.<a class="code" href="classserial_1_1soft_1_1_u_a_r_x_3_01board_1_1_interrupt_pin_00_01_r_x___01_4.html#a7c67306fbe04d184f0c267d3041fcbfc">begin</a>(115200);</div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160; </div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;    <a class="code" href="classstreams_1_1istream.html">streams::istream</a> in = uarx.in();</div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160; </div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;    <span class="comment">// Wait for a char</span></div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;    <span class="keywordtype">char</span> value1;</div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;    in &gt;&gt; <a class="code" href="namespacestreams.html#a76316854cb7b9c0c7688d02c660ed369">streams::skipws</a> &gt;&gt; value1;</div>
<div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160; </div>
<div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;    <span class="comment">// Wait for an uint16_t</span></div>
<div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;    uint16_t value2;</div>
<div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;    in &gt;&gt; <a class="code" href="namespacestreams.html#a76316854cb7b9c0c7688d02c660ed369">streams::skipws</a> &gt;&gt; value2;</div>
<div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160; </div>
<div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;    <span class="keywordflow">return</span> 0;</div>
<div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;}</div>
</div><!-- fragment --><p>Note the following differences with a previous example using <code><a class="el" href="classserial_1_1hard_1_1_u_a_r_x.html" title="Hardware serial receiver API.">serial::hard::UARX</a></code>:</p>
<ol type="1">
<li><code>RX</code> must be an interrupt pin (either <code><a class="el" href="namespaceboard.html#a7abd24b042402c0691c0ad6db604e7da" title="Defines all digital output pins of target MCU, usable as pin change interrupt (PCI) pins.">board::InterruptPin</a></code> or <code><a class="el" href="namespaceboard.html#adea66670db50b076b2c145657aa587f7" title="Defines all digital output pins of target MCU, usable as direct external interrupt pins.">board::ExternalInterruptPin</a></code>)</li>
<li><code><a class="el" href="soft__uart_8h.html#ab265bfe0b99f589a37c678b6fe187ae9" title="Register the necessary ISR (Interrupt Service Routine) for an serial::soft::UARX to work correctly.">REGISTER_UARX_PCI_ISR(RX, PCI_NUM)</a></code> (or <code><a class="el" href="soft__uart_8h.html#afadd51f6293440878945dba02035757e" title="Register the necessary ISR (Interrupt Service Routine) for an serial::soft::UARX to work correctly.">REGISTER_UARX_INT_ISR(RX, INT_NUM)</a></code>) is needed to register an ISR on pin <code>RX</code> changes</li>
<li>the <code>uarx</code> variable must be defined as a <code><a class="el" href="namespaceserial_1_1soft.html#a635413d48cfb8a9c87a89cfe5260f4fe" title="Software-emulated serial receiver API.">serial::soft::UARX_PCI</a></code> if it is connected to an <code><a class="el" href="namespaceboard.html#a7abd24b042402c0691c0ad6db604e7da" title="Defines all digital output pins of target MCU, usable as pin change interrupt (PCI) pins.">board::InterruptPin</a></code> or a <code><a class="el" href="namespaceserial_1_1soft.html#a8df57c2eef46710582fd0e1bbb71aa25" title="Software-emulated serial receiver API.">serial::soft::UARX_EXT</a></code> if it is connected to an <code><a class="el" href="namespaceboard.html#adea66670db50b076b2c145657aa587f7" title="Defines all digital output pins of target MCU, usable as direct external interrupt pins.">board::ExternalInterruptPin</a></code></li>
<li>an interrupt handler must be setup (either <code><a class="el" href="classinterrupt_1_1_p_c_i_signal.html" title="Handler of a Pin Change Interrupt vector.">interrupt::PCISignal</a></code> or <code><a class="el" href="classinterrupt_1_1_i_n_t_signal.html" title="Handler of an External Interrupt.">interrupt::INTSignal</a></code>), passed to the constructor then enabled</li>
</ol>
<p>Finally, there are also two classes, <code><a class="el" href="namespaceserial_1_1soft.html#aa9fec1860c9b09f2b1562a05e250c045" title="Software-emulated serial receiver/transceiver API.">serial::soft::UART_PCI</a></code> and <code><a class="el" href="namespaceserial_1_1soft.html#a6d58ad00a2b7df6d3ebfca1f7c89dba2" title="Software-emulated serial receiver/transceiver API.">serial::soft::UART_EXT</a></code>, that combine <code><a class="el" href="classserial_1_1soft_1_1_u_a_t_x.html" title="Software-emulated serial transmitter API.">serial::soft::UATX</a></code> and <code><a class="el" href="namespaceserial_1_1soft.html#a635413d48cfb8a9c87a89cfe5260f4fe" title="Software-emulated serial receiver API.">serial::soft::UARX_PCI</a></code> or <code><a class="el" href="namespaceserial_1_1soft.html#a8df57c2eef46710582fd0e1bbb71aa25" title="Software-emulated serial receiver API.">serial::soft::UARX_EXT</a></code>, and work similarly as <code><a class="el" href="classserial_1_1hard_1_1_u_a_r_t.html" title="Hardware serial receiver/transceiver API.">serial::hard::UART</a></code>. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<div class="ttc" id="anamespacewatchdog_html"><div class="ttname"><a href="namespacewatchdog.html">watchdog</a></div><div class="ttdoc">Defines the simple API for Watchdog timer management.</div><div class="ttdef"><b>Definition:</b> <a href="watchdog_8h_source.html#l00100">watchdog.h:101</a></div></div>
<div class="ttc" id="anamespaceboard_html_aa6b4a447b2fccb95185367644c3f28bb"><div class="ttname"><a href="namespaceboard.html#aa6b4a447b2fccb95185367644c3f28bb">board::Timer</a></div><div class="ttdeci">Timer</div><div class="ttdoc">Defines all timers available for target MCU.</div><div class="ttdef"><b>Definition:</b> <a href="empty_8h_source.html#l00111">empty.h:112</a></div></div>
<div class="ttc" id="aclassgpio_1_1_fast_port_html"><div class="ttname"><a href="classgpio_1_1_fast_port.html">gpio::FastPort</a></div><div class="ttdoc">API that manipulates a whole digital IO port.</div><div class="ttdef"><b>Definition:</b> <a href="gpio_8h_source.html#l00201">gpio.h:202</a></div></div>
<div class="ttc" id="awatchdog_8h_html_adb4cc81538efc2536ee6e1d06ae4b92f"><div class="ttname"><a href="watchdog_8h.html#adb4cc81538efc2536ee6e1d06ae4b92f">REGISTER_WATCHDOG_ISR_EMPTY</a></div><div class="ttdeci">#define REGISTER_WATCHDOG_ISR_EMPTY()</div><div class="ttdoc">Register an empty ISR (Interrupt Service Routine) for a watchdog::WatchdogSignal.</div><div class="ttdef"><b>Definition:</b> <a href="watchdog_8h_source.html#l00085">watchdog.h:85</a></div></div>
<div class="ttc" id="aclassstreams_1_1istream_html_ab2b480d5069588a6e9c97e89dfd7c4d8"><div class="ttname"><a href="classstreams_1_1istream.html#ab2b480d5069588a6e9c97e89dfd7c4d8">streams::istream::getline</a></div><div class="ttdeci">istream &amp; getline(char *str, size_t n, char delim='\n')</div><div class="ttdoc">Extract characters from this input stream and stores them as a C-string, until either (n - 1) charact...</div><div class="ttdef"><b>Definition:</b> <a href="streams_8h_source.html#l00442">streams.h:442</a></div></div>
<div class="ttc" id="aclasspower_1_1_power_html_a0bfb70818b6e364f8e6e0d5745ba254b"><div class="ttname"><a href="classpower_1_1_power.html#a0bfb70818b6e364f8e6e0d5745ba254b">power::Power::sleep</a></div><div class="ttdeci">static void sleep()</div><div class="ttdoc">Enter power sleep mode as defined by Power::set_default_mode().</div><div class="ttdef"><b>Definition:</b> <a href="power_8h_source.html#l00069">power.h:69</a></div></div>
<div class="ttc" id="anamespaceboard_html_adea66670db50b076b2c145657aa587f7"><div class="ttname"><a href="namespaceboard.html#adea66670db50b076b2c145657aa587f7">board::ExternalInterruptPin</a></div><div class="ttdeci">ExternalInterruptPin</div><div class="ttdoc">Defines all digital output pins of target MCU, usable as direct external interrupt pins.</div><div class="ttdef"><b>Definition:</b> <a href="empty_8h_source.html#l00090">empty.h:91</a></div></div>
<div class="ttc" id="atones_8h_html"><div class="ttname"><a href="tones_8h.html">tones.h</a></div><div class="ttdoc">API to handle tones (simple square waves) generation to a buzzer.</div></div>
<div class="ttc" id="aclassstreams_1_1ostream_html"><div class="ttname"><a href="classstreams_1_1ostream.html">streams::ostream</a></div><div class="ttdoc">Output stream wrapper to provide formatted output API, a la C++.</div><div class="ttdef"><b>Definition:</b> <a href="streams_8h_source.html#l00060">streams.h:61</a></div></div>
<div class="ttc" id="aclassserial_1_1soft_1_1_u_a_r_x_3_01board_1_1_interrupt_pin_00_01_r_x___01_4_html_a7c67306fbe04d184f0c267d3041fcbfc"><div class="ttname"><a href="classserial_1_1soft_1_1_u_a_r_x_3_01board_1_1_interrupt_pin_00_01_r_x___01_4.html#a7c67306fbe04d184f0c267d3041fcbfc">serial::soft::UARX&lt; board::InterruptPin, RX_ &gt;::begin</a></div><div class="ttdeci">void begin(uint32_t rate, Parity parity=Parity::NONE, StopBits stop_bits=StopBits::ONE)</div><div class="ttdoc">Enable the receiver.</div><div class="ttdef"><b>Definition:</b> <a href="soft__uart_8h_source.html#l00626">soft_uart.h:626</a></div></div>
<div class="ttc" id="aclasstime_1_1_r_t_t_time_html_abe9d6453890926b91e158faf562693f7"><div class="ttname"><a href="classtime_1_1_r_t_t_time.html#abe9d6453890926b91e158faf562693f7">time::RTTTime::millis</a></div><div class="ttdeci">uint32_t millis() const</div><div class="ttdoc">Number of elapsed milliseconds.</div><div class="ttdef"><b>Definition:</b> <a href="time_8h_source.html#l00125">time.h:125</a></div></div>
<div class="ttc" id="anamespacegpio_html_aaa6f9e5f023592cc0692da0bb37deccd"><div class="ttname"><a href="namespacegpio.html#aaa6f9e5f023592cc0692da0bb37deccd">gpio::FAST_INT_PIN</a></div><div class="ttdeci">typename FastPinType&lt; board::PCI_PIN&lt; IPIN_ &gt;()&gt;::TYPE FAST_INT_PIN</div><div class="ttdoc">Useful alias type to the FastPin type matching a given board::InterruptPin.</div><div class="ttdef"><b>Definition:</b> <a href="gpio_8h_source.html#l00711">gpio.h:711</a></div></div>
<div class="ttc" id="aclassserial_1_1soft_1_1_u_a_t_x_html_afd47337a77c3f1146b8c5e2ccc73ce3e"><div class="ttname"><a href="classserial_1_1soft_1_1_u_a_t_x.html#afd47337a77c3f1146b8c5e2ccc73ce3e">serial::soft::UATX::begin</a></div><div class="ttdeci">void begin(uint32_t rate, Parity parity=Parity::NONE, StopBits stop_bits=StopBits::ONE)</div><div class="ttdoc">Enable the transmitter.</div><div class="ttdef"><b>Definition:</b> <a href="soft__uart_8h_source.html#l00246">soft_uart.h:246</a></div></div>
<div class="ttc" id="anamespacedevices_1_1audio_html_ad5cef39b1f81f50bd23e0a4f4cf555aa"><div class="ttname"><a href="namespacedevices_1_1audio.html#ad5cef39b1f81f50bd23e0a4f4cf555aa">devices::audio::Tone</a></div><div class="ttdeci">Tone</div><div class="ttdoc">This enum defines all possible audio tones that can be generated.</div><div class="ttdef"><b>Definition:</b> <a href="tones_8h_source.html#l00056">tones.h:57</a></div></div>
<div class="ttc" id="awatchdog_8h_html"><div class="ttname"><a href="watchdog_8h.html">watchdog.h</a></div><div class="ttdoc">Watchdog API.</div></div>
<div class="ttc" id="anamespaceutils_html_a610e02474f969fc747fa1725b79e252c"><div class="ttname"><a href="namespaceutils.html#a610e02474f969fc747fa1725b79e252c">utils::map_raw_to_physical</a></div><div class="ttdeci">constexpr int16_t map_raw_to_physical(int16_t value, UnitPrefix prefix, int16_t range, uint8_t precision_bits)</div><div class="ttdoc">Convert the raw value, obtained from an electronics device, using precision_bit number of bits (that ...</div><div class="ttdef"><b>Definition:</b> <a href="utilities_8h_source.html#l00187">utilities.h:187</a></div></div>
<div class="ttc" id="aclasscontainers_1_1_queue_html"><div class="ttname"><a href="classcontainers_1_1_queue.html">containers::Queue&lt; EVENT &gt;</a></div></div>
<div class="ttc" id="anamespaceboard_html_a8541ca1f10a050c4356d6ccd76d9a907"><div class="ttname"><a href="namespaceboard.html#a8541ca1f10a050c4356d6ccd76d9a907">board::USART</a></div><div class="ttdeci">USART</div><div class="ttdoc">Defines all USART modules of target MCU.</div><div class="ttdef"><b>Definition:</b> <a href="empty_8h_source.html#l00104">empty.h:105</a></div></div>
<div class="ttc" id="aclasstime_1_1_r_t_t_time_html_a8a53c14cd518a7287035a9598ccabaa0"><div class="ttname"><a href="classtime_1_1_r_t_t_time.html#a8a53c14cd518a7287035a9598ccabaa0">time::RTTTime::micros</a></div><div class="ttdeci">uint16_t micros() const</div><div class="ttdoc">Number of elapsed microseconds (0..999).</div><div class="ttdef"><b>Definition:</b> <a href="time_8h_source.html#l00131">time.h:131</a></div></div>
<div class="ttc" id="ads1307_8h_html"><div class="ttname"><a href="ds1307_8h.html">ds1307.h</a></div><div class="ttdoc">API to handle Real-Time Clock DS1307 I2C chip.</div></div>
<div class="ttc" id="aeeprom_8h_html"><div class="ttname"><a href="eeprom_8h.html">eeprom.h</a></div><div class="ttdoc">API to handle EEPROM access in read and write modes.</div></div>
<div class="ttc" id="anamespacetime_html_af1e59bdf7c41bd8ff215d69a769a89bf"><div class="ttname"><a href="namespacetime.html#af1e59bdf7c41bd8ff215d69a769a89bf">time::delay</a></div><div class="ttdeci">DELAY_PTR delay</div><div class="ttdoc">Delay program execution for the given amount of milliseconds.</div><div class="ttdef"><b>Definition:</b> <a href="time_8cpp_source.html#l00019">time.cpp:19</a></div></div>
<div class="ttc" id="asoft__uart_8h_html_ab265bfe0b99f589a37c678b6fe187ae9"><div class="ttname"><a href="soft__uart_8h.html#ab265bfe0b99f589a37c678b6fe187ae9">REGISTER_UARX_PCI_ISR</a></div><div class="ttdeci">#define REGISTER_UARX_PCI_ISR(RX, PCI_NUM)</div><div class="ttdoc">Register the necessary ISR (Interrupt Service Routine) for an serial::soft::UARX to work correctly.</div><div class="ttdef"><b>Definition:</b> <a href="soft__uart_8h_source.html#l00039">soft_uart.h:39</a></div></div>
<div class="ttc" id="anamespacestreams_html_a9c09ef93f2d071416214cbe8ed0e1710"><div class="ttname"><a href="namespacestreams.html#a9c09ef93f2d071416214cbe8ed0e1710">streams::oct</a></div><div class="ttdeci">void oct(FSTREAM &amp;stream)</div><div class="ttdoc">Manipulator for an output or input stream, which will set the base, used to represent (output) or int...</div><div class="ttdef"><b>Definition:</b> <a href="ios_8h_source.html#l00756">ios.h:756</a></div></div>
<div class="ttc" id="apower_8h_html"><div class="ttname"><a href="power_8h.html">power.h</a></div><div class="ttdoc">Simple power support for AVR MCU.</div></div>
<div class="ttc" id="ai2c__handler_8h_html"><div class="ttname"><a href="i2c__handler_8h.html">i2c_handler.h</a></div><div class="ttdoc">Common I2C Manager API.</div></div>
<div class="ttc" id="anamespaceutils_html_a53f4a46843c0030ed1388d10c0ad6179"><div class="ttname"><a href="namespaceutils.html#a53f4a46843c0030ed1388d10c0ad6179">utils::swap_bytes</a></div><div class="ttdeci">void swap_bytes(uint16_t &amp;value)</div><div class="ttdoc">Swap 2 bytes of a 2-bytes integer.</div><div class="ttdef"><b>Definition:</b> <a href="utilities_8h_source.html#l00373">utilities.h:373</a></div></div>
<div class="ttc" id="anamespacedevices_html"><div class="ttname"><a href="namespacedevices.html">devices</a></div><div class="ttdoc">Defines all API for all external devices supported by FastArduino.</div><div class="ttdef"><b>Definition:</b> <a href="common__magneto_8h_source.html#l00026">common_magneto.h:27</a></div></div>
<div class="ttc" id="aclasswatchdog_1_1_watchdog_signal_html"><div class="ttname"><a href="classwatchdog_1_1_watchdog_signal.html">watchdog::WatchdogSignal</a></div><div class="ttdoc">Simple API to handle watchdog signals.</div><div class="ttdef"><b>Definition:</b> <a href="watchdog_8h_source.html#l00144">watchdog.h:145</a></div></div>
<div class="ttc" id="aclassevents_1_1_dispatcher_html_a97998440c7f6f351f57fb501df3c0dd7"><div class="ttname"><a href="classevents_1_1_dispatcher.html#a97998440c7f6f351f57fb501df3c0dd7">events::Dispatcher::dispatch</a></div><div class="ttdeci">void dispatch(const EVENT &amp;event)</div><div class="ttdoc">Dispatch the given event to the right EventHandler, based on the event type.</div><div class="ttdef"><b>Definition:</b> <a href="events_8h_source.html#l00256">events.h:256</a></div></div>
<div class="ttc" id="aclassserial_1_1hard_1_1_u_a_r_x_html"><div class="ttname"><a href="classserial_1_1hard_1_1_u_a_r_x.html">serial::hard::UARX</a></div><div class="ttdoc">Hardware serial receiver API.</div><div class="ttdef"><b>Definition:</b> <a href="uart_8h_source.html#l00355">uart.h:356</a></div></div>
<div class="ttc" id="aclassserial_1_1hard_1_1_u_a_t_x_html"><div class="ttname"><a href="classserial_1_1hard_1_1_u_a_t_x.html">serial::hard::UATX</a></div><div class="ttdoc">Hardware serial transmitter API.</div><div class="ttdef"><b>Definition:</b> <a href="uart_8h_source.html#l00240">uart.h:241</a></div></div>
<div class="ttc" id="awinbond_8h_html"><div class="ttname"><a href="winbond_8h.html">winbond.h</a></div><div class="ttdoc">API to handle WinBond flash memory chips through SPI interface.</div></div>
<div class="ttc" id="aclasstimer_1_1_r_t_t_html_a7d5c189655b98446f08ccd5cf078c912"><div class="ttname"><a href="classtimer_1_1_r_t_t.html#a7d5c189655b98446f08ccd5cf078c912">timer::RTT::delay</a></div><div class="ttdeci">void delay(uint32_t ms) const</div><div class="ttdoc">Delay program execution for the given amount of milliseconds.</div><div class="ttdef"><b>Definition:</b> <a href="realtime__timer_8h_source.html#l00288">realtime_timer.h:288</a></div></div>
<div class="ttc" id="arealtime__timer_8h_html_afc2dfeccc5d417ae872d836d4cfb5d8c"><div class="ttname"><a href="realtime__timer_8h.html#afc2dfeccc5d417ae872d836d4cfb5d8c">REGISTER_RTT_ISR</a></div><div class="ttdeci">#define REGISTER_RTT_ISR(TIMER_NUM)</div><div class="ttdoc">Register the necessary ISR (Interrupt Service Routine) for a timer::RTT to work properly.</div><div class="ttdef"><b>Definition:</b> <a href="realtime__timer_8h_source.html#l00044">realtime_timer.h:44</a></div></div>
<div class="ttc" id="anamespaceinterrupt_html_a440f2d705bc60755a4f81a105caef15c"><div class="ttname"><a href="namespaceinterrupt.html#a440f2d705bc60755a4f81a105caef15c">interrupt::PCI_SIGNAL</a></div><div class="ttdeci">typename PCIType&lt; PIN &gt;::TYPE PCI_SIGNAL</div><div class="ttdoc">Useful alias type to the PCISignal type matching a given board::InterruptPin.</div><div class="ttdef"><b>Definition:</b> <a href="pci_8h_source.html#l00567">pci.h:567</a></div></div>
<div class="ttc" id="anamespaceevents_1_1_type_html_a4c0afb748726e34daf4c20c27c0e0165"><div class="ttname"><a href="namespaceevents_1_1_type.html#a4c0afb748726e34daf4c20c27c0e0165">events::Type::USER_EVENT</a></div><div class="ttdeci">const uint8_t USER_EVENT</div><div class="ttdoc">The first ordinal event type that you may use for your own custom events.</div><div class="ttdef"><b>Definition:</b> <a href="events_8h_source.html#l00123">events.h:123</a></div></div>
<div class="ttc" id="aclassanalog_1_1_analog_input_html"><div class="ttname"><a href="classanalog_1_1_analog_input.html">analog::AnalogInput</a></div><div class="ttdoc">API that handles a given analog input pin of the target MCU.</div><div class="ttdef"><b>Definition:</b> <a href="analog__input_8h_source.html#l00051">analog_input.h:52</a></div></div>
<div class="ttc" id="anamespacetimer_html"><div class="ttname"><a href="namespacetimer.html">timer</a></div><div class="ttdoc">Defines all API to manipulate AVR Timers.</div><div class="ttdef"><b>Definition:</b> <a href="pulse__timer_8h_source.html#l00115">pulse_timer.h:116</a></div></div>
<div class="ttc" id="aclassevents_1_1_event_html"><div class="ttname"><a href="classevents_1_1_event.html">events::Event</a></div><div class="ttdoc">A standard Event as managed by FastArduino event API.</div><div class="ttdef"><b>Definition:</b> <a href="events_8h_source.html#l00143">events.h:144</a></div></div>
<div class="ttc" id="ascheduler_8h_html"><div class="ttname"><a href="scheduler_8h.html">scheduler.h</a></div><div class="ttdoc">Support for jobs scheduling.</div></div>
<div class="ttc" id="aclassi2c_1_1_i2_c_sync_manager_html"><div class="ttname"><a href="classi2c_1_1_i2_c_sync_manager.html">i2c::I2CSyncManager</a></div><div class="ttdoc">Synchronous I2C Manager for ATmega architecture.</div><div class="ttdef"><b>Definition:</b> <a href="i2c__handler__atmega_8h_source.html#l01179">i2c_handler_atmega.h:1181</a></div></div>
<div class="ttc" id="anamespacestreams_html_a25bd12279d518b57e4fb97c533c17b22"><div class="ttname"><a href="namespacestreams.html#a25bd12279d518b57e4fb97c533c17b22">streams::endl</a></div><div class="ttdeci">void endl(FSTREAM &amp;stream)</div><div class="ttdoc">Manipulator for an output stream, which will insert a new-line character and flush the stream buffer.</div><div class="ttdef"><b>Definition:</b> <a href="streams_8h_source.html#l00722">streams.h:722</a></div></div>
<div class="ttc" id="anamespacegpio_html_a3cbdad86ced6494ca615a425b433fd57"><div class="ttname"><a href="namespacegpio.html#a3cbdad86ced6494ca615a425b433fd57">gpio::FAST_PIN</a></div><div class="ttdeci">typename FastPinType&lt; DPIN_ &gt;::TYPE FAST_PIN</div><div class="ttdoc">Useful alias type to the FastPin type matching a given board::DigitalPin.</div><div class="ttdef"><b>Definition:</b> <a href="gpio_8h_source.html#l00688">gpio.h:688</a></div></div>
<div class="ttc" id="apci_8h_html"><div class="ttname"><a href="pci_8h.html">pci.h</a></div><div class="ttdoc">General API for handling Pin Change Interrupts.</div></div>
<div class="ttc" id="anamespaceboard_html_a2529f85498783a75dc75c281e0b754d3"><div class="ttname"><a href="namespaceboard.html#a2529f85498783a75dc75c281e0b754d3">board::init</a></div><div class="ttdeci">static void init()</div><div class="ttdoc">Performs special initialization for the target MCU.</div><div class="ttdef"><b>Definition:</b> <a href="empty_8h_source.html#l00043">empty.h:43</a></div></div>
<div class="ttc" id="aclassserial_1_1hard_1_1_u_a_r_t_html"><div class="ttname"><a href="classserial_1_1hard_1_1_u_a_r_t.html">serial::hard::UART</a></div><div class="ttdoc">Hardware serial receiver/transceiver API.</div><div class="ttdef"><b>Definition:</b> <a href="uart_8h_source.html#l00424">uart.h:425</a></div></div>
<div class="ttc" id="aevents_8h_html"><div class="ttname"><a href="events_8h.html">events.h</a></div><div class="ttdoc">Support for events management.</div></div>
<div class="ttc" id="aclassgpio_1_1_fast_port_html_a910c81c3668585199f4d1dbd669438a8"><div class="ttname"><a href="classgpio_1_1_fast_port.html#a910c81c3668585199f4d1dbd669438a8">gpio::FastPort::set_PORT</a></div><div class="ttdeci">void set_PORT(uint8_t port) INLINE</div><div class="ttdoc">Set the 8-bits value for port PORT register.</div><div class="ttdef"><b>Definition:</b> <a href="gpio_8h_source.html#l00287">gpio.h:287</a></div></div>
<div class="ttc" id="anamespaceboard_html_a1283eb94244413c14c80cc2f3e8bcb3f"><div class="ttname"><a href="namespaceboard.html#a1283eb94244413c14c80cc2f3e8bcb3f">board::PWMPin</a></div><div class="ttdeci">PWMPin</div><div class="ttdoc">Defines all digital output pins of target MCU, capable of PWM output.</div><div class="ttdef"><b>Definition:</b> <a href="empty_8h_source.html#l00083">empty.h:84</a></div></div>
<div class="ttc" id="aclassstreams_1_1istream_html_a99dafd2dce58830708b65dd4f4b6136f"><div class="ttname"><a href="classstreams_1_1istream.html#a99dafd2dce58830708b65dd4f4b6136f">streams::istream::ignore</a></div><div class="ttdeci">istream &amp; ignore(size_t n=1, int delim=istreambuf::EOF)</div><div class="ttdoc">Extract characters from this input stream and discards them, until either n characters have been extr...</div><div class="ttdef"><b>Definition:</b> <a href="streams_8h_source.html#l00461">streams.h:461</a></div></div>
<div class="ttc" id="anamespacestreams_html_a91675bd61b31e7382e8655930606f62f"><div class="ttname"><a href="namespacestreams.html#a91675bd61b31e7382e8655930606f62f">streams::hex</a></div><div class="ttdeci">void hex(FSTREAM &amp;stream)</div><div class="ttdoc">Manipulator for an output or input stream, which will set the base, used to represent (output) or int...</div><div class="ttdef"><b>Definition:</b> <a href="ios_8h_source.html#l00774">ios.h:774</a></div></div>
<div class="ttc" id="anamespaceflash_html_a3308e6ce737b046264e113ced6ba610f"><div class="ttname"><a href="namespaceflash.html#a3308e6ce737b046264e113ced6ba610f">flash::read_flash</a></div><div class="ttdeci">T &amp; read_flash(uint16_t address, T &amp;item)</div><div class="ttdoc">Read flash memory content at given address into item.</div><div class="ttdef"><b>Definition:</b> <a href="flash_8h_source.html#l00047">flash.h:47</a></div></div>
<div class="ttc" id="aclassevents_1_1_scheduler_html"><div class="ttname"><a href="classevents_1_1_scheduler.html">events::Scheduler</a></div><div class="ttdoc">Schedule jobs at predefined periods of time.</div><div class="ttdef"><b>Definition:</b> <a href="scheduler_8h_source.html#l00088">scheduler.h:89</a></div></div>
<div class="ttc" id="auart_8h_html"><div class="ttname"><a href="uart_8h.html">uart.h</a></div><div class="ttdoc">Hardware serial API.</div></div>
<div class="ttc" id="anamespacedevices_1_1audio_1_1_special_tone_html_a4221d7dbfd3adda995e653697bdf28a1"><div class="ttname"><a href="namespacedevices_1_1audio_1_1_special_tone.html#a4221d7dbfd3adda995e653697bdf28a1">devices::audio::SpecialTone::END</a></div><div class="ttdeci">static constexpr const Tone END</div><div class="ttdoc">This special tone marks the end of a melody (as a sequence of Tones).</div><div class="ttdef"><b>Definition:</b> <a href="tone__player_8h_source.html#l00044">tone_player.h:44</a></div></div>
<div class="ttc" id="anamespaceutils_html_a76076365828136f5178f279fb3c129de"><div class="ttname"><a href="namespaceutils.html#a76076365828136f5178f279fb3c129de">utils::binary_to_bcd</a></div><div class="ttdeci">uint8_t binary_to_bcd(uint8_t binary)</div><div class="ttdoc">Convert a natural integers to a BCD byte (2 digits).</div><div class="ttdef"><b>Definition:</b> <a href="utilities_8h_source.html#l00357">utilities.h:357</a></div></div>
<div class="ttc" id="anamespaceboard_html"><div class="ttname"><a href="namespaceboard.html">board</a></div><div class="ttdoc">Defines all types and constants specific to support a specific MCU target.</div><div class="ttdef"><b>Definition:</b> <a href="empty_8h_source.html#l00037">empty.h:38</a></div></div>
<div class="ttc" id="aclassserial_1_1hard_1_1_u_a_r_t_html_ae89048a3748401f4e1c6defa02bca8f6"><div class="ttname"><a href="classserial_1_1hard_1_1_u_a_r_t.html#ae89048a3748401f4e1c6defa02bca8f6">serial::hard::UART::begin</a></div><div class="ttdeci">void begin(uint32_t rate, Parity parity=Parity::NONE, StopBits stop_bits=StopBits::ONE)</div><div class="ttdoc">Enable the receiver/transceiver.</div><div class="ttdef"><b>Definition:</b> <a href="uart_8h_source.html#l00466">uart.h:466</a></div></div>
<div class="ttc" id="aclasscontainers_1_1_linked_list_html_ac44c93a96f2aaffe0411565798c6cd67"><div class="ttname"><a href="classcontainers_1_1_linked_list.html#ac44c93a96f2aaffe0411565798c6cd67">containers::LinkedList&lt; EventHandler&lt; EVENT &gt; &gt;::insert</a></div><div class="ttdeci">void insert(T &amp;item) INLINE</div><div class="ttdoc">Insert item at the beginning of this list.</div><div class="ttdef"><b>Definition:</b> <a href="linked__list_8h_source.html#l00106">linked_list.h:106</a></div></div>
<div class="ttc" id="anamespacetime_html_a258d2da0bcb268278406d4c8cb0dda1c"><div class="ttname"><a href="namespacetime.html#a258d2da0bcb268278406d4c8cb0dda1c">time::delay_us</a></div><div class="ttdeci">void delay_us(uint16_t us) INLINE</div><div class="ttdoc">Delay program execution for the given amount of microseconds.</div><div class="ttdef"><b>Definition:</b> <a href="time_8h_source.html#l00334">time.h:334</a></div></div>
<div class="ttc" id="aclassdevices_1_1audio_1_1_tone_generator_html"><div class="ttname"><a href="classdevices_1_1audio_1_1_tone_generator.html">devices::audio::ToneGenerator</a></div><div class="ttdoc">API class for tone generation to a buzzer (or better an amplifier) connected to pin OUTPUT.</div><div class="ttdef"><b>Definition:</b> <a href="tones_8h_source.html#l00182">tones.h:183</a></div></div>
<div class="ttc" id="anamespacetime_html_a173df6ce2b6d3d6ed1418807e1b70a70"><div class="ttname"><a href="namespacetime.html#a173df6ce2b6d3d6ed1418807e1b70a70">time::millis</a></div><div class="ttdeci">MILLIS_PTR millis</div><div class="ttdoc">Count number of milliseconds elapsed since some time base reference (generally since MCU startup).</div><div class="ttdef"><b>Definition:</b> <a href="time_8cpp_source.html#l00020">time.cpp:20</a></div></div>
<div class="ttc" id="asoft__uart_8h_html"><div class="ttname"><a href="soft__uart_8h.html">soft_uart.h</a></div><div class="ttdoc">Software-emulated serial API.</div></div>
<div class="ttc" id="aclassinterrupt_1_1_i_n_t_signal_html"><div class="ttname"><a href="classinterrupt_1_1_i_n_t_signal.html">interrupt::INTSignal</a></div><div class="ttdoc">Handler of an External Interrupt.</div><div class="ttdef"><b>Definition:</b> <a href="int_8h_source.html#l00131">int.h:132</a></div></div>
<div class="ttc" id="atimer_8h_html"><div class="ttname"><a href="timer_8h.html">timer.h</a></div><div class="ttdoc">Timer API.</div></div>
<div class="ttc" id="anamespaceevents_html"><div class="ttname"><a href="namespaceevents.html">events</a></div><div class="ttdoc">Defines all API to handle events within FastArduino programs.</div><div class="ttdef"><b>Definition:</b> <a href="events_8h_source.html#l00081">events.h:82</a></div></div>
<div class="ttc" id="anamespacestreams_html_a76316854cb7b9c0c7688d02c660ed369"><div class="ttname"><a href="namespacestreams.html#a76316854cb7b9c0c7688d02c660ed369">streams::skipws</a></div><div class="ttdeci">void skipws(FSTREAM &amp;stream)</div><div class="ttdoc">Manipulator for an input stream, which will activate whitespace discarding before formatted input ope...</div><div class="ttdef"><b>Definition:</b> <a href="ios_8h_source.html#l00729">ios.h:729</a></div></div>
<div class="ttc" id="atime_8h_html"><div class="ttname"><a href="time_8h.html">time.h</a></div><div class="ttdoc">Simple time utilities.</div></div>
<div class="ttc" id="anamespaceboard_html_a7abd24b042402c0691c0ad6db604e7da"><div class="ttname"><a href="namespaceboard.html#a7abd24b042402c0691c0ad6db604e7da">board::InterruptPin</a></div><div class="ttdeci">InterruptPin</div><div class="ttdoc">Defines all digital output pins of target MCU, usable as pin change interrupt (PCI) pins.</div><div class="ttdef"><b>Definition:</b> <a href="empty_8h_source.html#l00097">empty.h:98</a></div></div>
<div class="ttc" id="aclassserial_1_1hard_1_1_u_a_r_x_html_ab990e6d4b45a811a451f1eeaa96faf1b"><div class="ttname"><a href="classserial_1_1hard_1_1_u_a_r_x.html#ab990e6d4b45a811a451f1eeaa96faf1b">serial::hard::UARX::begin</a></div><div class="ttdeci">void begin(uint32_t rate, Parity parity=Parity::NONE, StopBits stop_bits=StopBits::ONE)</div><div class="ttdoc">Enable the receiver.</div><div class="ttdef"><b>Definition:</b> <a href="uart_8h_source.html#l00389">uart.h:389</a></div></div>
<div class="ttc" id="aclassstreams_1_1istream_html_a32740ec0eb870f855232b32d56fa0ef5"><div class="ttname"><a href="classstreams_1_1istream.html#a32740ec0eb870f855232b32d56fa0ef5">streams::istream::get</a></div><div class="ttdeci">int get()</div><div class="ttdoc">Extract a single character from this input stream.</div><div class="ttdef"><b>Definition:</b> <a href="streams_8h_source.html#l00394">streams.h:394</a></div></div>
<div class="ttc" id="aclasstimer_1_1_timer_html"><div class="ttname"><a href="classtimer_1_1_timer.html">timer::Timer&lt; NTIMER &gt;</a></div></div>
<div class="ttc" id="aclassstreams_1_1istream_html"><div class="ttname"><a href="classstreams_1_1istream.html">streams::istream</a></div><div class="ttdoc">Input stream wrapper to provide formatted input API, a la C++.</div><div class="ttdef"><b>Definition:</b> <a href="streams_8h_source.html#l00356">streams.h:357</a></div></div>
<div class="ttc" id="anamespaceboard_html_a151323e5de5adf93f6bcdfdd64fa1eb1"><div class="ttname"><a href="namespaceboard.html#a151323e5de5adf93f6bcdfdd64fa1eb1">board::Port</a></div><div class="ttdeci">Port</div><div class="ttdoc">Defines all available ports of the target MCU.</div><div class="ttdef"><b>Definition:</b> <a href="empty_8h_source.html#l00048">empty.h:49</a></div></div>
<div class="ttc" id="auart_8h_html_aa33c57bb6fa1e93177abb21fe8fecb10"><div class="ttname"><a href="uart_8h.html#aa33c57bb6fa1e93177abb21fe8fecb10">REGISTER_UATX_ISR</a></div><div class="ttdeci">#define REGISTER_UATX_ISR(UART_NUM)</div><div class="ttdoc">Register the necessary ISR (Interrupt Service Routine) for an serial::hard::UATX to work correctly.</div><div class="ttdef"><b>Definition:</b> <a href="uart_8h_source.html#l00037">uart.h:37</a></div></div>
<div class="ttc" id="adefines_8h_html_addf5ec070e9499d36b7f2009ce736076"><div class="ttname"><a href="defines_8h.html#addf5ec070e9499d36b7f2009ce736076">UNUSED</a></div><div class="ttdeci">#define UNUSED</div><div class="ttdoc">Specific GCC attribute to declare an argument or variable unused, so that the compiler does not emit ...</div><div class="ttdef"><b>Definition:</b> <a href="defines_8h_source.html#l00045">defines.h:45</a></div></div>
<div class="ttc" id="anamespacecontainers_html_ad31e49a84cd01e80e5c66859820ca8c9"><div class="ttname"><a href="namespacecontainers.html#ad31e49a84cd01e80e5c66859820ca8c9">containers::pull</a></div><div class="ttdeci">T pull(Queue&lt; T, TREF &gt; &amp;queue)</div><div class="ttdoc">Pull an item from the beginning of queue.</div><div class="ttdef"><b>Definition:</b> <a href="queue_8h_source.html#l00556">queue.h:556</a></div></div>
<div class="ttc" id="aclassserial_1_1hard_1_1_u_a_t_x_html_a64b04d0617b28fd343a01f865dee787e"><div class="ttname"><a href="classserial_1_1hard_1_1_u_a_t_x.html#a64b04d0617b28fd343a01f865dee787e">serial::hard::UATX::begin</a></div><div class="ttdeci">void begin(uint32_t rate, Parity parity=Parity::NONE, StopBits stop_bits=StopBits::ONE)</div><div class="ttdoc">Enable the transmitter.</div><div class="ttdef"><b>Definition:</b> <a href="uart_8h_source.html#l00275">uart.h:275</a></div></div>
<div class="ttc" id="aclasstime_1_1_r_t_t_time_html"><div class="ttname"><a href="classtime_1_1_r_t_t_time.html">time::RTTTime</a></div><div class="ttdoc">Structure used to hold a time value with microsecond precision.</div><div class="ttdef"><b>Definition:</b> <a href="time_8h_source.html#l00049">time.h:50</a></div></div>
<div class="ttc" id="aclassserial_1_1soft_1_1_u_a_r_x_3_01board_1_1_interrupt_pin_00_01_r_x___01_4_html"><div class="ttname"><a href="classserial_1_1soft_1_1_u_a_r_x_3_01board_1_1_interrupt_pin_00_01_r_x___01_4.html">serial::soft::UARX&lt; board::InterruptPin, RX_ &gt;</a></div><div class="ttdef"><b>Definition:</b> <a href="soft__uart_8h_source.html#l00581">soft_uart.h:582</a></div></div>
<div class="ttc" id="aclasscontainers_1_1_queue_html_ae506aa92e594cbac6f338c2b65d1e3b6"><div class="ttname"><a href="classcontainers_1_1_queue.html#ae506aa92e594cbac6f338c2b65d1e3b6">containers::Queue::push_</a></div><div class="ttdeci">bool push_(TREF item)</div><div class="ttdoc">Push item to the end of this queue, provided there is still available space in its ring buffer.</div></div>
<div class="ttc" id="anamespacestreams_html_adaf650921b3a5d448f8aac51dba924d2"><div class="ttname"><a href="namespacestreams.html#adaf650921b3a5d448f8aac51dba924d2">streams::dec</a></div><div class="ttdeci">void dec(FSTREAM &amp;stream)</div><div class="ttdoc">Manipulator for an output or input stream, which will set the base, used to represent (output) or int...</div><div class="ttdef"><b>Definition:</b> <a href="ios_8h_source.html#l00765">ios.h:765</a></div></div>
<div class="ttc" id="aclasstimer_1_1_r_t_t_html_ac5c7807d1cb3f77fc54685f85b193e32"><div class="ttname"><a href="classtimer_1_1_r_t_t.html#ac5c7807d1cb3f77fc54685f85b193e32">timer::RTT::time</a></div><div class="ttdeci">time::RTTTime time() const</div><div class="ttdoc">Elapsed time, in milliseconds and microseconds, since this timer has started.</div><div class="ttdef"><b>Definition:</b> <a href="realtime__timer_8h_source.html#l00354">realtime_timer.h:354</a></div></div>
<div class="ttc" id="anamespacestreams_html_a69896b602e1678789bbad7b9fa98e3a3"><div class="ttname"><a href="namespacestreams.html#a69896b602e1678789bbad7b9fa98e3a3">streams::noskipws</a></div><div class="ttdeci">void noskipws(FSTREAM &amp;stream)</div><div class="ttdoc">Manipulator for an input stream, which will deactivate whitespace discarding before formatted input o...</div><div class="ttdef"><b>Definition:</b> <a href="ios_8h_source.html#l00738">ios.h:738</a></div></div>
<div class="ttc" id="aclasswatchdog_1_1_watchdog_html"><div class="ttname"><a href="classwatchdog_1_1_watchdog.html">watchdog::Watchdog</a></div><div class="ttdoc">Simple API to use watchdog timer as a clock for events generation.</div><div class="ttdef"><b>Definition:</b> <a href="watchdog_8h_source.html#l00304">watchdog.h:305</a></div></div>
<div class="ttc" id="aclasstimer_1_1_r_t_t_event_callback_html"><div class="ttname"><a href="classtimer_1_1_r_t_t_event_callback.html">timer::RTTEventCallback</a></div><div class="ttdoc">Utility to generate events from an RTT instance at a given period.</div><div class="ttdef"><b>Definition:</b> <a href="realtime__timer_8h_source.html#l00535">realtime_timer.h:536</a></div></div>
<div class="ttc" id="aclasstimer_1_1_r_t_t_html"><div class="ttname"><a href="classtimer_1_1_r_t_t.html">timer::RTT</a></div><div class="ttdoc">API to handle a real-time timer.</div><div class="ttdef"><b>Definition:</b> <a href="realtime__timer_8h_source.html#l00203">realtime_timer.h:204</a></div></div>
<div class="ttc" id="aclassanalog_1_1_analog_input_html_a56e3701a8e1594347b99b3e0d300e598"><div class="ttname"><a href="classanalog_1_1_analog_input.html#a56e3701a8e1594347b99b3e0d300e598">analog::AnalogInput::sample</a></div><div class="ttdeci">SAMPLE_TYPE sample()</div><div class="ttdoc">Start an analog-digital conversion for this analog input pin and return sample value.</div><div class="ttdef"><b>Definition:</b> <a href="analog__input_8h_source.html#l00105">analog_input.h:105</a></div></div>
<div class="ttc" id="aclassinterrupt_1_1_p_c_i_signal_html"><div class="ttname"><a href="classinterrupt_1_1_p_c_i_signal.html">interrupt::PCISignal</a></div><div class="ttdoc">Handler of a Pin Change Interrupt vector.</div><div class="ttdef"><b>Definition:</b> <a href="pci_8h_source.html#l00175">pci.h:176</a></div></div>
<div class="ttc" id="anamespacestreams_html"><div class="ttname"><a href="namespacestreams.html">streams</a></div><div class="ttdoc">Defines C++-like streams API, based on circular buffers for input or output.</div><div class="ttdef"><b>Definition:</b> <a href="empty__streams_8h_source.html#l00033">empty_streams.h:34</a></div></div>
<div class="ttc" id="aclassstreams_1_1ostream_html_a00f6c7bdce1520b119c31cd7dde80ac2"><div class="ttname"><a href="classstreams_1_1ostream.html#a00f6c7bdce1520b119c31cd7dde80ac2">streams::ostream::flush</a></div><div class="ttdeci">void flush()</div><div class="ttdoc">Flush this ostream and blocks until all its buffer has been written to the underlying device.</div><div class="ttdef"><b>Definition:</b> <a href="streams_8h_source.html#l00086">streams.h:86</a></div></div>
<div class="ttc" id="anamespacegpio_html_ae18fafd08668ee17aa5dd415ee3b6041aa84cc046d48610b05c21fd3670d0c829"><div class="ttname"><a href="namespacegpio.html#ae18fafd08668ee17aa5dd415ee3b6041aa84cc046d48610b05c21fd3670d0c829">gpio::PinMode::INPUT</a></div><div class="ttdeci">@ INPUT</div><div class="ttdoc">Digital pin is configured as high-impedance (open drain) input.</div></div>
<div class="ttc" id="aclassevents_1_1_dispatcher_html"><div class="ttname"><a href="classevents_1_1_dispatcher.html">events::Dispatcher</a></div><div class="ttdoc">Utility to dispatch an event to a list of EventHandlers that are registered for its type.</div><div class="ttdef"><b>Definition:</b> <a href="events_8h_source.html#l00239">events.h:240</a></div></div>
<div class="ttc" id="aclassstreams_1_1ostream_html_a001a2dd6c215d77e06492376bf791870"><div class="ttname"><a href="classstreams_1_1ostream.html#a001a2dd6c215d77e06492376bf791870">streams::ostream::write</a></div><div class="ttdeci">void write(const char *content, size_t size)</div><div class="ttdoc">Write a block of data to this stream.</div><div class="ttdef"><b>Definition:</b> <a href="streams_8h_source.html#l00113">streams.h:113</a></div></div>
<div class="ttc" id="anamespaceflash_html"><div class="ttname"><a href="namespaceflash.html">flash</a></div><div class="ttdoc">Defines API to handle flash memory storage.</div><div class="ttdef"><b>Definition:</b> <a href="flash_8h_source.html#l00030">flash.h:31</a></div></div>
<div class="ttc" id="anamespacespi_html_a7829182c423612511a05fa0434d7673e"><div class="ttname"><a href="namespacespi.html#a7829182c423612511a05fa0434d7673e">spi::init</a></div><div class="ttdeci">void init()</div><div class="ttdoc">This function must be called once in your program, before any use of an SPI device.</div><div class="ttdef"><b>Definition:</b> <a href="spi_8cpp_source.html#l00020">spi.cpp:20</a></div></div>
<div class="ttc" id="aclassanalog_1_1_p_w_m_output_html"><div class="ttname"><a href="classanalog_1_1_p_w_m_output.html">analog::PWMOutput</a></div><div class="ttdoc">Construct a new handler for a PWM output pin.</div><div class="ttdef"><b>Definition:</b> <a href="pwm_8h_source.html#l00053">pwm.h:54</a></div></div>
<div class="ttc" id="arealtime__timer_8h_html"><div class="ttname"><a href="realtime__timer_8h.html">realtime_timer.h</a></div><div class="ttdoc">Real-time Timer API.</div></div>
<div class="ttc" id="anamespacestreams_html_a79c81dc9afb0ca3ce0495fb7a95e85e1"><div class="ttname"><a href="namespacestreams.html#a79c81dc9afb0ca3ce0495fb7a95e85e1">streams::bin</a></div><div class="ttdeci">void bin(FSTREAM &amp;stream)</div><div class="ttdoc">Manipulator for an output or input stream, which will set the base, used to represent (output) or int...</div><div class="ttdef"><b>Definition:</b> <a href="ios_8h_source.html#l00747">ios.h:747</a></div></div>
<div class="ttc" id="anamespaceevents_1_1_type_html_a89956491c3bf31c616baf63fcd335405"><div class="ttname"><a href="namespaceevents_1_1_type.html#a89956491c3bf31c616baf63fcd335405">events::Type::WDT_TIMER</a></div><div class="ttdeci">const uint8_t WDT_TIMER</div><div class="ttdoc">Type of events generated by watchdog::Watchdog for each watchdog timeout interrupt.</div><div class="ttdef"><b>Definition:</b> <a href="events_8h_source.html#l00105">events.h:105</a></div></div>
<div class="ttc" id="agpio_8h_html"><div class="ttname"><a href="gpio_8h.html">gpio.h</a></div><div class="ttdoc">General Purpose (digital) Input Output API.</div></div>
<div class="ttc" id="anamespaceeeprom_html"><div class="ttname"><a href="namespaceeeprom.html">eeprom</a></div><div class="ttdoc">Defines the API for accessing the EEPROM embedded in each AVR MCU.</div><div class="ttdef"><b>Definition:</b> <a href="eeprom_8h_source.html#l00089">eeprom.h:90</a></div></div>
<div class="ttc" id="astructtimer_1_1_calculator_html"><div class="ttname"><a href="structtimer_1_1_calculator.html">timer::Calculator</a></div><div class="ttdoc">Defines a set of calculation methods for the given NTIMER_ The behavior of these methods is specific ...</div><div class="ttdef"><b>Definition:</b> <a href="timer_8h_source.html#l00301">timer.h:302</a></div></div>
<div class="ttc" id="aclassinterrupt_1_1_p_c_i_signal_html_a7a116409c3029a4d5b869bf68e1fde14"><div class="ttname"><a href="classinterrupt_1_1_p_c_i_signal.html#a7a116409c3029a4d5b869bf68e1fde14">interrupt::PCISignal::enable_pins_</a></div><div class="ttdeci">void enable_pins_(uint8_t mask)</div><div class="ttdoc">Enable pin change interrupts for several pins of this PCINT.</div><div class="ttdef"><b>Definition:</b> <a href="pci_8h_source.html#l00440">pci.h:440</a></div></div>
<div class="ttc" id="anamespaceutils_html_a78e8ff3db7671b59028ba873086cfa32"><div class="ttname"><a href="namespaceutils.html#a78e8ff3db7671b59028ba873086cfa32">utils::map_physical_to_raw</a></div><div class="ttdeci">constexpr int16_t map_physical_to_raw(int16_t value, UnitPrefix prefix, int16_t range, uint8_t precision_bits)</div><div class="ttdoc">Convert an absolute physical value, expressed in some given measurement unit, scaled with prefix,...</div><div class="ttdef"><b>Definition:</b> <a href="utilities_8h_source.html#l00260">utilities.h:260</a></div></div>
<div class="ttc" id="aclassinterrupt_1_1_p_c_i_signal_html_a91c747b1d70bcf54889698401b90f21b"><div class="ttname"><a href="classinterrupt_1_1_p_c_i_signal.html#a91c747b1d70bcf54889698401b90f21b">interrupt::PCISignal::enable_</a></div><div class="ttdeci">void enable_()</div><div class="ttdoc">Enable pin change interrupts for this PCISignal.</div><div class="ttdef"><b>Definition:</b> <a href="pci_8h_source.html#l00365">pci.h:365</a></div></div>
<div class="ttc" id="aclasstimer_1_1_r_t_t_html_a9f2975201cfb390d7fb15e930d0c5489"><div class="ttname"><a href="classtimer_1_1_r_t_t.html#a9f2975201cfb390d7fb15e930d0c5489">timer::RTT::begin</a></div><div class="ttdeci">void begin()</div><div class="ttdoc">Start this real-time timer, hence elapsed time starts getting counted from then.</div><div class="ttdef"><b>Definition:</b> <a href="realtime__timer_8h_source.html#l00445">realtime_timer.h:445</a></div></div>
<div class="ttc" id="aanalog__input_8h_html"><div class="ttname"><a href="analog__input_8h.html">analog_input.h</a></div><div class="ttdoc">Analog Input API.</div></div>
<div class="ttc" id="anamespaceinterrupt_html_abfd5857208f49006bde8c472497273de"><div class="ttname"><a href="namespaceinterrupt.html#abfd5857208f49006bde8c472497273de">interrupt::register_handler</a></div><div class="ttdeci">void register_handler(Handler &amp;handler)</div><div class="ttdoc">Register a class instance containing methods that shall be called back by an ISR.</div><div class="ttdef"><b>Definition:</b> <a href="interrupts_8h_source.html#l00157">interrupts.h:157</a></div></div>
<div class="ttc" id="auart_8h_html_a4fed67375824a0fc63e21ecdb7ce0db0"><div class="ttname"><a href="uart_8h.html#a4fed67375824a0fc63e21ecdb7ce0db0">REGISTER_UARX_ISR</a></div><div class="ttdeci">#define REGISTER_UARX_ISR(UART_NUM)</div><div class="ttdoc">Register the necessary ISR (Interrupt Service Routine) for an serial::hard::UARX to work correctly.</div><div class="ttdef"><b>Definition:</b> <a href="uart_8h_source.html#l00048">uart.h:48</a></div></div>
<div class="ttc" id="aclasseeprom_1_1_e_e_p_r_o_m_html_a046768eae9f26564b1039a13b88bb8c1"><div class="ttname"><a href="classeeprom_1_1_e_e_p_r_o_m.html#a046768eae9f26564b1039a13b88bb8c1">eeprom::EEPROM::read</a></div><div class="ttdeci">static bool read(const T *address, T &amp;value)</div><div class="ttdoc">Read value of type T stored in EEPROM at address.</div><div class="ttdef"><b>Definition:</b> <a href="eeprom_8h_source.html#l00149">eeprom.h:149</a></div></div>
<div class="ttc" id="aclassinterrupt_1_1_i_n_t_signal_html_aba283975bf5d335fccc927f217305e85"><div class="ttname"><a href="classinterrupt_1_1_i_n_t_signal.html#aba283975bf5d335fccc927f217305e85">interrupt::INTSignal::enable</a></div><div class="ttdeci">void enable()</div><div class="ttdoc">Enable interrupts for this external interrupt pin.</div><div class="ttdef"><b>Definition:</b> <a href="int_8h_source.html#l00183">int.h:183</a></div></div>
<div class="ttc" id="anamespacetime_html_af13fd17ddf6b751b8161691e608892b2"><div class="ttname"><a href="namespacetime.html#af13fd17ddf6b751b8161691e608892b2">time::delay_ms</a></div><div class="ttdeci">void delay_ms(uint16_t ms) INLINE</div><div class="ttdoc">Delay program execution for the given amount of milliseconds.</div><div class="ttdef"><b>Definition:</b> <a href="time_8h_source.html#l00346">time.h:346</a></div></div>
<div class="ttc" id="apwm_8h_html"><div class="ttname"><a href="pwm_8h.html">pwm.h</a></div><div class="ttdoc">PWM API.</div></div>
<div class="ttc" id="aclassi2c_1_1_abstract_i2_c_sync_manager_html_a66b6a7902f2d3e2354f344c154f4a841"><div class="ttname"><a href="classi2c_1_1_abstract_i2_c_sync_manager.html#a66b6a7902f2d3e2354f344c154f4a841">i2c::AbstractI2CSyncManager::begin</a></div><div class="ttdeci">void begin()</div><div class="ttdoc">Prepare and enable the MCU for I2C transmission.</div><div class="ttdef"><b>Definition:</b> <a href="i2c__handler__common_8h_source.html#l00433">i2c_handler_common.h:433</a></div></div>
<div class="ttc" id="aclassevents_1_1_job_html"><div class="ttname"><a href="classevents_1_1_job.html">events::Job</a></div><div class="ttdoc">Abstract class holding some action to be executed at given periods of time.</div><div class="ttdef"><b>Definition:</b> <a href="scheduler_8h_source.html#l00160">scheduler.h:161</a></div></div>
<div class="ttc" id="anamespacegpio_html_a78705a6beb0840892d7f8f52d0f32bec"><div class="ttname"><a href="namespacegpio.html#a78705a6beb0840892d7f8f52d0f32bec">gpio::FAST_EXT_PIN</a></div><div class="ttdeci">typename FastPinType&lt; board::EXT_PIN&lt; EPIN_ &gt;()&gt;::TYPE FAST_EXT_PIN</div><div class="ttdoc">Useful alias type to the FastPin type matching a given board::ExternalInterruptPin.</div><div class="ttdef"><b>Definition:</b> <a href="gpio_8h_source.html#l00734">gpio.h:734</a></div></div>
<div class="ttc" id="apci_8h_html_a64be10f04dd31643ee243b564a0d910c"><div class="ttname"><a href="pci_8h.html#a64be10f04dd31643ee243b564a0d910c">REGISTER_PCI_ISR_METHOD</a></div><div class="ttdeci">#define REGISTER_PCI_ISR_METHOD(PCI_NUM, HANDLER, CALLBACK, PIN,...)</div><div class="ttdoc">Register the necessary ISR (Interrupt Service Routine) for a Pin Change Interrupt vector.</div><div class="ttdef"><b>Definition:</b> <a href="pci_8h_source.html#l00044">pci.h:44</a></div></div>
<div class="ttc" id="aflash_8h_html_a16c40764aaba0de309f5ff429c8bac15"><div class="ttname"><a href="flash_8h.html#a16c40764aaba0de309f5ff429c8bac15">F</a></div><div class="ttdeci">#define F(ptr)</div><div class="ttdoc">Force string constant to be stored as flash storage.</div><div class="ttdef"><b>Definition:</b> <a href="flash_8h_source.html#l00098">flash.h:98</a></div></div>
<div class="ttc" id="anamespacegpio_html_ae18fafd08668ee17aa5dd415ee3b6041a50a87f0d71f7221582dad4bf507a0f34"><div class="ttname"><a href="namespacegpio.html#ae18fafd08668ee17aa5dd415ee3b6041a50a87f0d71f7221582dad4bf507a0f34">gpio::PinMode::OUTPUT</a></div><div class="ttdeci">@ OUTPUT</div><div class="ttdoc">Digital pin is configured as output.</div></div>
<div class="ttc" id="awatchdog_8h_html_a6998639a03718afa44f5626c17ce8994"><div class="ttname"><a href="watchdog_8h.html#a6998639a03718afa44f5626c17ce8994">REGISTER_WATCHDOG_CLOCK_ISR</a></div><div class="ttdeci">#define REGISTER_WATCHDOG_CLOCK_ISR(EVENT)</div><div class="ttdoc">Register the necessary ISR (Interrupt Service Routine) for a watchdog::Watchdog to work properly.</div><div class="ttdef"><b>Definition:</b> <a href="watchdog_8h_source.html#l00036">watchdog.h:36</a></div></div>
<div class="ttc" id="aclassserial_1_1soft_1_1_u_a_t_x_html"><div class="ttname"><a href="classserial_1_1soft_1_1_u_a_t_x.html">serial::soft::UATX</a></div><div class="ttdoc">Software-emulated serial transmitter API.</div><div class="ttdef"><b>Definition:</b> <a href="soft__uart_8h_source.html#l00218">soft_uart.h:219</a></div></div>
<div class="ttc" id="anamespaceevents_1_1_type_html_a2c33d039e5fdd277900219bd3cd74eb0"><div class="ttname"><a href="namespaceevents_1_1_type.html#a2c33d039e5fdd277900219bd3cd74eb0">events::Type::NO_EVENT</a></div><div class="ttdeci">const uint8_t NO_EVENT</div><div class="ttdoc">Special event type attached to no event at all.</div><div class="ttdef"><b>Definition:</b> <a href="events_8h_source.html#l00098">events.h:98</a></div></div>
<div class="ttc" id="aclassdevices_1_1_win_bond_html"><div class="ttname"><a href="classdevices_1_1_win_bond.html">devices::WinBond</a></div><div class="ttdoc">SPI device driver for WinBond flash memory chips, like W25Q80BV (8 Mbit flash).</div><div class="ttdef"><b>Definition:</b> <a href="winbond_8h_source.html#l00054">winbond.h:55</a></div></div>
<div class="ttc" id="aclasstimer_1_1_r_t_t_html_a7a6aaedc91de46926931990538c8ae26"><div class="ttname"><a href="classtimer_1_1_r_t_t.html#a7a6aaedc91de46926931990538c8ae26">timer::RTT::millis</a></div><div class="ttdeci">uint32_t millis() const</div><div class="ttdoc">Elapsed time, in milliseconds, since this timer has started.</div><div class="ttdef"><b>Definition:</b> <a href="realtime__timer_8h_source.html#l00252">realtime_timer.h:252</a></div></div>
<div class="ttc" id="atimer_8h_html_acfce0d4d6115510756da8d720409ed26"><div class="ttname"><a href="timer_8h.html#acfce0d4d6115510756da8d720409ed26">REGISTER_TIMER_COMPARE_ISR_METHOD</a></div><div class="ttdeci">#define REGISTER_TIMER_COMPARE_ISR_METHOD(TIMER_NUM, HANDLER, CALLBACK)</div><div class="ttdoc">Register the necessary ISR (Interrupt Service Routine) for a timer::Timer with a callback method in C...</div><div class="ttdef"><b>Definition:</b> <a href="timer_8h_source.html#l00040">timer.h:40</a></div></div>
<div class="ttc" id="aint_8h_html_a3e2a8c98468d29717612f7c694a17d59"><div class="ttname"><a href="int_8h.html#a3e2a8c98468d29717612f7c694a17d59">REGISTER_INT_ISR_METHOD</a></div><div class="ttdeci">#define REGISTER_INT_ISR_METHOD(INT_NUM, PIN, HANDLER, CALLBACK)</div><div class="ttdoc">Register the necessary ISR (Interrupt Service Routine) for an External Interrupt pin.</div><div class="ttdef"><b>Definition:</b> <a href="int_8h_source.html#l00039">int.h:39</a></div></div>
<div class="ttc" id="anamespaceevents_1_1_type_html_af865c398a73776e70e023c82d0af6b8d"><div class="ttname"><a href="namespaceevents_1_1_type.html#af865c398a73776e70e023c82d0af6b8d">events::Type::RTT_TIMER</a></div><div class="ttdeci">const uint8_t RTT_TIMER</div><div class="ttdoc">Type of events generated by timer::RTTEventCallback whenever elapsed RTT::millis() reaches a multiple...</div><div class="ttdef"><b>Definition:</b> <a href="events_8h_source.html#l00112">events.h:112</a></div></div>
<div class="ttc" id="auart_8h_html_a8bd735d1a3a5a0a8e3253fd3f1720b29"><div class="ttname"><a href="uart_8h.html#a8bd735d1a3a5a0a8e3253fd3f1720b29">REGISTER_UART_ISR</a></div><div class="ttdeci">#define REGISTER_UART_ISR(UART_NUM)</div><div class="ttdoc">Register the necessary ISR (Interrupt Service Routine) for an serial::hard::UART to work correctly.</div><div class="ttdef"><b>Definition:</b> <a href="uart_8h_source.html#l00059">uart.h:59</a></div></div>
<div class="ttc" id="aint_8h_html"><div class="ttname"><a href="int_8h.html">int.h</a></div><div class="ttdoc">General API for handling External Interrupt pins.</div></div>
<div class="ttc" id="anamespaceboard_html_a5082846fef8fdfb8c8cbcf1163c7b404"><div class="ttname"><a href="namespaceboard.html#a5082846fef8fdfb8c8cbcf1163c7b404">board::DigitalPin</a></div><div class="ttdeci">DigitalPin</div><div class="ttdoc">Defines all available digital input/output pins of the target MCU.</div><div class="ttdef"><b>Definition:</b> <a href="empty_8h_source.html#l00055">empty.h:56</a></div></div>
<div class="ttc" id="arealtime__timer_8h_html_a2fa7e6297d6f853dea35cc5a9f213c46"><div class="ttname"><a href="realtime__timer_8h.html#a2fa7e6297d6f853dea35cc5a9f213c46">REGISTER_RTT_EVENT_ISR</a></div><div class="ttdeci">#define REGISTER_RTT_EVENT_ISR(TIMER_NUM, EVENT, PERIOD)</div><div class="ttdoc">Register the necessary ISR (Interrupt Service Routine) for a timer::RTT to work properly,...</div><div class="ttdef"><b>Definition:</b> <a href="realtime__timer_8h_source.html#l00102">realtime_timer.h:102</a></div></div>
<div class="ttc" id="anamespacestreams_html_a155684415ba442e665f551819429b3a0"><div class="ttname"><a href="namespacestreams.html#a155684415ba442e665f551819429b3a0">streams::flush</a></div><div class="ttdeci">void flush(FSTREAM &amp;stream)</div><div class="ttdoc">Manipulator for an output stream, which will flush the stream buffer.</div><div class="ttdef"><b>Definition:</b> <a href="streams_8h_source.html#l00713">streams.h:713</a></div></div>
<div class="ttc" id="aflash_8h_html"><div class="ttname"><a href="flash_8h.html">flash.h</a></div><div class="ttdoc">Flash memory utilities.</div></div>
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20 </li>
  </ul>
</div>
</body>
</html>
