<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>FastArduino: Adding support for an I2C device</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">FastArduino
   &#160;<span id="projectnumber">v1.9</span>
   </div>
   <div id="projectbrief">C++ library to build fast but small Arduino/AVR projects</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('i2cdevices.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Adding support for an I2C device </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md__home_jfpoilpret_electronics_fast_arduino_lib_dox_i2c_devices"></a></p>
<p>There are plenty of devices of all kinds, based on I2C interface, that you may want to connect to your Arduino or a board you created with an AVR ATmega or ATtiny MCU.</p>
<p>If you want to learn more about I2C concepts and vocabulary, you can find further information on <a href="https://en.wikipedia.org/wiki/I%C2%B2C">Wikipedia</a>.</p>
<p>Unfortunately, FastArduino obviously cannot provide specific support for all existing I2C devices.</p>
<p>However, based on a given device datasheet, it can be quite easy to add a FastArduino driver for any I2C device.</p>
<p>FastArduino provides all the necessary classes and methods for you to implement such a specific driver.</p>
<p>The following sections describe the FastArduino API for I2C device driver implementation, and list the steps to successfully implement such a driver.</p>
<h1>FastArduino I2C driver API </h1>
<p>The generic support for I2C device driver in FastArduino looks quite simple, it is entirely embedded in one class, <code><a class="el" href="classi2c_1_1_i2_c_device.html" title="Base class for all I2C devices.">i2c::I2CDevice</a></code>; this is a template class which all actual I2C device drivers shall derive from.</p>
<p>This template class has only one <code>MANAGER</code> parameter, which must be kept as is in all subclasses; this represents the type of I2C Manager used to handle the I2C bus and operations.</p>
<p>The <code><a class="el" href="classi2c_1_1_i2_c_device.html" title="Base class for all I2C devices.">i2c::I2CDevice</a></code> class mainly contains <code>protected</code> types aliases and methods to create and launch read and write commands to a device on the I2C bus.</p>
<p>Any FastArduino I2C device must be able to work in both asynchronous and synchronous modes The <code><a class="el" href="classi2c_1_1_i2_c_device.html" title="Base class for all I2C devices.">i2c::I2CDevice</a></code> API is made for asynchronous operations; synchronous flavours of a specific device API are based on asynchronous implementations of that API (just awaiting for the operation to finish).</p>
<p>As you can see in the following diagrams, the drivers for I2C devices currently supported by FastArduino directly derive from <code><a class="el" href="classi2c_1_1_i2_c_device.html" title="Base class for all I2C devices.">i2c::I2CDevice</a></code>:</p>
<ol type="1">
<li>DS1307 Real Time Clock chip <div class="image">
<img src="classdevices_1_1rtc_1_1_d_s1307__inherit__graph.png" alt=""/>
</div>
 </li>
<li>MCP23008 8-Bit I/O Expander chip <div class="image">
<img src="classdevices_1_1mcp230xx_1_1_m_c_p23008__inherit__graph.png" alt=""/>
</div>
 </li>
<li>MCP23017 16-Bit I/O Expander chip <div class="image">
<img src="classdevices_1_1mcp230xx_1_1_m_c_p23017__inherit__graph.png" alt=""/>
</div>
 </li>
<li>MPU6050 3D Accelerometer-Gyroscope chip <div class="image">
<img src="classdevices_1_1magneto_1_1_m_p_u6050__inherit__graph.png" alt=""/>
</div>
 </li>
<li>HMC5883L 3D Compass chip <div class="image">
<img src="classdevices_1_1magneto_1_1_h_m_c5883_l__inherit__graph.png" alt=""/>
</div>
 </li>
</ol>
<p>Creating a new driver for an I2C device must follow these steps:</p><ol type="1">
<li>Create a <code><a class="el" href="classi2c_1_1_i2_c_device.html" title="Base class for all I2C devices.">i2c::I2CDevice</a></code> template subclass; let's call it <code>MyI2CDevice</code> in the rest of this page.</li>
<li>Redefine (as <code>private</code>) the following type aliases inherited from <code><a class="el" href="classi2c_1_1_i2_c_device.html" title="Base class for all I2C devices.">i2c::I2CDevice</a></code>: <code>PARENT</code>, <code>PROXY</code>, <code>FUTURE</code></li>
<li>Add a <code>public</code> constructor with one argument: <code>MyI2CDevice::MyI2CDevice(MANAGER&amp; manager)</code> where <code>MANAGER</code> is a class template argument of both <code>MyI2CDevice</code> and <code><a class="el" href="classi2c_1_1_i2_c_device.html" title="Base class for all I2C devices.">i2c::I2CDevice</a></code>; this constructor must call the inherited constructor and pass it 3 arguments: <code>manager</code>, the default I2C address for your device, and finally, one of <code><a class="el" href="namespacei2c.html#ab75faf1b696d9d3d0383268167116746" title="Constant determining that best supported I2C mode for an I2CDevice is STANDARD (100kHz).">i2c::I2C_STANDARD</a></code> or <code><a class="el" href="namespacei2c.html#ace3a5e20376d4212091d6db37a6767e6" title="Constant determining that best supported I2C mode for an I2CDevice is FAST (400kHz).">i2c::I2C_FAST</a></code> constants, to indicate the best mode (highest I2C frequency) that your device can support.</li>
<li>List the API you need to provide to the end user of your device (based on the device datasheet)</li>
<li>For each <code>public</code> API you need to provide, define a specific <em>Future</em> to hold values written to the device, as well as values later read from the device. Each defined Future shall derive from <code>FUTURE</code> (type alias defined above). This future will allow asynchronous execution of the API. FastArduino guidelines for I2C devices suggest to name the future class according to the API name itself e.g. <code>SetDatetimeFuture</code> for the <code>set_datetime()</code> API.</li>
<li>For each <code>public</code> API, define a method that takes a <code>PROXY</code> to the future defined above and return an <code>int</code>. The implementation of this method is based on mainly 3 inherited <code>protected</code> methods: <code><a class="el" href="classi2c_1_1_i2_c_device.html#a75fe1fe6a563488eb06f86266e15c923" title="Build a read I2CLightCommand that can be later pushed to the I2C Manager for proper handling.">i2c::I2CDevice.read()</a></code>, <code><a class="el" href="classi2c_1_1_i2_c_device.html#a161423972dd35fbd4b32cd1e8048b5ad" title="Build a write I2CLightCommand that can be later pushed to the I2C Manager for proper handling.">i2c::I2CDevice.write()</a></code> and <code><a class="el" href="classi2c_1_1_i2_c_device.html#af937a51b38ea97dee521319c1fc09f46" title="Launch execution (asynchronously or synchronously, depending on MANAGER) of a chain of I2CLightComman...">i2c::I2CDevice.launch_commands()</a></code></li>
<li>For each <code>public</code> API, also define a similar method (same name) with a synchronous flavour. That method will directly take "natural" arguments (no futures) as input or output (reference), and return a <code>bool</code> to indicate if API was performed without any error.</li>
</ol>
<h2>I2CDevice API</h2>
<p>Before describing FastArduino I2C Device API, it is important to mention that this API is heavily based on FastArduino <a href="namespacefuture.html"><code>future</code></a> API, which concepts shall be first understood before starting to build your own support for an I2C device.</p>
<p>Subclassing <code><a class="el" href="classi2c_1_1_i2_c_device.html" title="Base class for all I2C devices.">i2c::I2CDevice</a></code> gives <code>MyI2CDevice</code> access to all low-level <code>protected</code> aliases:</p><ul>
<li><code>PARENT</code>: this is simply defined as <code><a class="el" href="classi2c_1_1_i2_c_device.html" title="Base class for all I2C devices.">i2c::I2CDevice</a>&lt;MANAGER&gt;</code> and is useful for accessing next aliases</li>
<li><code><a class="el" href="classi2c_1_1_i2_c_device.html#aaa72ad76688bfbf7057b4fdfa426a95c" title="The actual type used for all proxies; may be lifecycle::LightProxy or lifecycle::DirectProxy.">i2c::I2CDevice::PROXY</a></code>: this is the type of lifecycle proxy used by <code>MANAGER</code>; it must be used for all asynchronous API of <code>MyI2CDevice</code> to embed actual Future types</li>
<li><code><a class="el" href="classi2c_1_1_i2_c_device.html#ad029f30f422ebd435b20e1d2138ff908" title="The template base class of all futures to be defined for a device.">i2c::I2CDevice::FUTURE</a></code>: this is the type of Future used by <code>MANAGER</code>; it must be used for defining your own Future types for all asynchronous API of <code>MyI2CDevice</code></li>
</ul>
<p>Note that to be accessible from <code>MyI2CDevice</code> class, these types must be redefined as follows: </p><div class="fragment"><div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keyword">using</span> PARENT = <a class="code" href="classi2c_1_1_i2_c_device.html">i2c::I2CDevice&lt;MANAGER&gt;</a>;</div>
<div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">using</span> PROXY = <span class="keyword">typename</span> PARENT::template PROXY&lt;T&gt;;</div>
<div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> OUT, <span class="keyword">typename</span> IN&gt; <span class="keyword">using</span> FUTURE = <span class="keyword">typename</span> PARENT::template FUTURE&lt;OUT, IN&gt;;</div>
<div class="ttc" id="aclassi2c_1_1_i2_c_device_html"><div class="ttname"><a href="classi2c_1_1_i2_c_device.html">i2c::I2CDevice&lt; MANAGER &gt;</a></div></div>
</div><!-- fragment --><p><code><a class="el" href="classi2c_1_1_i2_c_device.html" title="Base class for all I2C devices.">i2c::I2CDevice</a></code> constructor takes 4 arguments:</p><ol type="1">
<li><code>MANAGER&amp; manager</code>: this should be passed as is from <code>MyI2CDevice</code> constructor</li>
<li><code>uint8_t device</code>: this is the default I2C address of this device (this 7-bits address must be already left-shifted one bit to leave the LSB available for I2C direction read or write)</li>
<li><code>Mode&lt;MODE&gt; mode</code> (<code>MODE</code> is a template argument of the constructor, <code><a class="el" href="namespacei2c.html#ac2780f0139dbc26f4d83a426dad67e36" title="I2C available transmission modes.">i2c::I2CMode</a> MODE</code>): this should be passed one of 2 constants <code><a class="el" href="namespacei2c.html#ace3a5e20376d4212091d6db37a6767e6" title="Constant determining that best supported I2C mode for an I2CDevice is FAST (400kHz).">i2c::I2C_FAST</a></code> or <code><a class="el" href="namespacei2c.html#ab75faf1b696d9d3d0383268167116746" title="Constant determining that best supported I2C mode for an I2CDevice is STANDARD (100kHz).">i2c::I2C_STANDARD</a></code>) to indicate the best I2C mode (highest frequency) supported by <code>MyI2CDevice</code>: this will impact what <code>MANAGER</code> type can be used when instantiating <code>MyI2CDevice</code> template</li>
<li><code>bool auto_stop</code>: this defines whether all chains of commands of <code>MyI2CDevice</code> shall automatically be ended with a STOP condition on the I2C bus or not. In most cases, the default (<code>false</code>) should work, but some devices (e.g. DS1307) do not work properly in 2 chains of commands are not separated by a STOP condition.</li>
</ol>
<p>Note that <code>device</code> address must be provided at construction time but can optionally be changed later. Regarding its I2C address, typically an I2C device falls in one of the following categories:</p><ol type="1">
<li>it has a fixed I2C address that cannot be changed (e.g. DS1307 RTC chip)</li>
<li>it has an I2C address that can be changed by hardware (e.g. jumpers) among a limited range of possible addresses (e.g. MCP23017 I/O expander chip, MPU 6050 acceleromete/gyroscope chip)</li>
<li>it has a fixed I2C address that can be changed by software (e.g. VL53L0X "micro lidar" chip); this is generally harder to support.</li>
</ol>
<p>For devices in category 1, you would typically define the address as a constant in <code>MyI2CDevice</code> and pass it directly to <code><a class="el" href="classi2c_1_1_i2_c_device.html" title="Base class for all I2C devices.">i2c::I2CDevice</a></code> constructor.</p>
<p>Here is a snippet from DS1307 device: </p><div class="fragment"><div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">explicit</span> DS1307(MANAGER&amp; manager) : PARENT{manager, DEVICE_ADDRESS, <a class="code" href="namespacei2c.html">i2c</a>::<a class="code" href="namespacei2c.html#ab75faf1b696d9d3d0383268167116746">I2C_STANDARD</a>} {}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keyword">static</span> constexpr <span class="keyword">const</span> uint8_t DEVICE_ADDRESS = 0x68 &lt;&lt; 1;</div>
<div class="ttc" id="anamespacei2c_html"><div class="ttname"><a href="namespacei2c.html">i2c</a></div><div class="ttdoc">Define API to define and manage I2C devices.</div><div class="ttdef"><b>Definition:</b> <a href="i2c_8cpp_source.html#l00017">i2c.cpp:18</a></div></div>
<div class="ttc" id="anamespacei2c_html_ab75faf1b696d9d3d0383268167116746"><div class="ttname"><a href="namespacei2c.html#ab75faf1b696d9d3d0383268167116746">i2c::I2C_STANDARD</a></div><div class="ttdeci">static constexpr Mode I2C_STANDARD</div><div class="ttdoc">Constant determining that best supported I2C mode for an I2CDevice is STANDARD (100kHz).</div><div class="ttdef"><b>Definition:</b> <a href="i2c__device_8h_source.html#l00046">i2c_device.h:46</a></div></div>
</div><!-- fragment --><p>For devices in category 2, you would rather define an <code>enum class</code> limiting the possible addresses configurable by hardware, or pass the address (as <code>uint8_t</code>) to the driver class constructor.</p>
<p>For devices in category 3, you would first define the fixed address as a constant, then define an API to change it (as a data member of <code>MyI2CDevice</code>).</p>
<p>Subclassing <code><a class="el" href="classi2c_1_1_i2_c_device.html" title="Base class for all I2C devices.">i2c::I2CDevice</a></code> gives <code>MyI2CDevice</code> access to all low-level <code>protected</code> methods:</p><ul>
<li><code><a class="el" href="classi2c_1_1_i2_c_device.html#a75fe1fe6a563488eb06f86266e15c923" title="Build a read I2CLightCommand that can be later pushed to the I2C Manager for proper handling.">i2c::I2CDevice.read(uint8_t read_count, bool finish_future, bool stop)</a></code>: create a command to read bytes from the I2C device; read bytes will be added to the related Future (passed to <code>launch_commands()</code>)</li>
<li><code><a class="el" href="classi2c_1_1_i2_c_device.html#a161423972dd35fbd4b32cd1e8048b5ad" title="Build a write I2CLightCommand that can be later pushed to the I2C Manager for proper handling.">i2c::I2CDevice.write(uint8_t write_count, bool finish_future, bool stop)</a></code>:create a command to write bytes to the I2C device; written bytes are taken from the related Future (passed to <code>launch_commands()</code>)</li>
<li><code><a class="el" href="classi2c_1_1_i2_c_device.html#af937a51b38ea97dee521319c1fc09f46" title="Launch execution (asynchronously or synchronously, depending on MANAGER) of a chain of I2CLightComman...">i2c::I2CDevice.launch_commands</a>(PROXY&lt;&gt; proxy, initializer_list&lt;&gt; commands)</code>: prepare passed read/write <code>commands</code> and send them to <code>MANAGER</code> for later asynchronous execution (commands are queued); the <code>Future</code> referenced by <code>proxy</code> is used to provide data to write to, and store data to read from, the I2C device.</li>
<li><code><a class="el" href="classi2c_1_1_i2_c_device.html#a1325f82f4aaf8290a2d4cc4c70dfe83b" title="Change the I2C address of this device.">i2c::I2CDevice.set_device(uint8_t device)</a></code>: change the I2C address of this device. This is useful for devices that allow changing their I2C address by software.</li>
<li><code><a class="el" href="classi2c_1_1_i2_c_device.html#aaf6df66445e2f4c39501b5621191f51e" title="Resolve proxy to an actual T (typically a Future).">i2c::I2CDevice.resolve</a>(PROXY&lt;T&gt; proxy)</code>: this method must be used when you need to resolve a <code>PROXY</code> passed to one of your API, in order to access some parts of its proxied Future. This method is seldom used.</li>
<li><code><a class="el" href="classi2c_1_1_i2_c_device.html#a358f5bdfc2a7f4cfbcca0e253f42d676" title="Create a PROXY from target.">i2c::I2CDevice.make_proxy(const T&amp; target)</a></code>: this method must be used in your synchronous API, in order to "proxify" a local Future before calling the related asynchronous API.</li>
</ul>
<p>Note that <code>read()</code> and <code>write()</code> methods do not actually perform any I2C operation! They only prepare an I2C read or write command (<code><a class="el" href="classi2c_1_1_i2_c_light_command.html" title="Light atomic I2C command as prepared by an I2C device.">i2c::I2CLightCommand</a></code> type embedding necessary information) based on their arguments:</p><ul>
<li><code>read_count</code>/<code>write_count</code> specify the number of bytes to read or write. When <code>0</code> (the default), this means that all bytes (as defined in the specific Future) will be read or written.</li>
<li><code>finish_future</code>: specify that, after this command execution, the Future assigned to the current transaction will be marked as finished</li>
<li><code>stop</code>: specify that, after this command execution, an I2C STOP condition will be generated on the I2C bus; this will automatically trigger a "START" condition on the next command (whether it is part of the current chain of commands or not)</li>
</ul>
<p>The <code>launch_commands()</code> method does the actual work:</p><ul>
<li>with a synchronous I2C Manager, it blocks until all commands get executed or an error occurs; the assigned Future is directly <code>READY</code> (or in <code>ERROR</code>) when the method returns</li>
<li>with an asynchronous I2C Manager, it enqueues all commands for asynchronous execution and returns immediately; the assigned Future will be later updated (it status will become either <code>READY</code> or <code>ERROR</code>) once all commands are complete.</li>
</ul>
<h2>I2C device registers common operations</h2>
<p>Most I2C devices API consists in reading and writing device registers at a specific address (referenced by a byte); registers may be one byte long or more depending on what each register represents.</p>
<p>In order to simplify support of new I2C devices, FastArduino comes with a few extra utilities that can greatly speed up device support implementation.</p>
<p>These utilities are in header <code><a class="el" href="i2c__device__utilities_8h.html" title="Various utilities to use for I2C Device support developers.">i2c_device_utilities.h</a></code> in the same <code><a class="el" href="namespacei2c.html" title="Define API to define and manage I2C devices.">i2c</a></code> namespace as <code>I2CDevice</code> abstract base class.</p>
<p>The following template classes are defined in there:</p><ul>
<li><code>ReadRegisterFuture</code> and <code>TReadRegisterFuture</code>: future classes to read one register of any type of value; type conversion is possible by providing a <code>FUNCTOR</code> class or function.</li>
<li><code>WriteRegisterFuture</code> and <code>TWriteRegisterFuture</code>: future classes to write one register of any type; type conversion is possible by providing a <code>FUNCTOR</code> class or function.</li>
<li><code>I2CFuturesGroup</code>: abstract future allowing its derived classes to aggregate several futures used in the same I2C transaction; this is useful when dealing with particularly complex I2C devices.</li>
<li><code>I2CSameFutureGroup</code>: instances of this class will generate one-byte register writing I2C transactions from content (register id and register value) stored in Flash; this is useful when dealing with some I2C devices that need long initialization process from hard-coded values.</li>
</ul>
<p>The <code>DS1307</code> RTC device is a good example of <code>TReadRegisterFuture</code> and <code>TWriteRegisterFuture</code> simple usage, along with conversion functors: </p><div class="fragment"><div class="line"><span class="keyword">using</span> GetDatetimeFuture = TReadRegisterFuture&lt;TIME_ADDRESS, tm, DatetimeConverterFromDevice&gt;;</div>
<div class="line"><span class="keyword">using</span> SetDatetimeFuture = TWriteRegisterFuture&lt;TIME_ADDRESS, tm, DatetimeConverterToDevice&gt;;</div>
</div><!-- fragment --><p>The <code>VL53L0X</code> Time-of-Flight laser device is much complex and makes heavy use of advanced utilities like <code>I2CFuturesGroup</code>: </p><div class="fragment"><div class="line"><span class="keyword">class </span>SetGPIOSettingsFuture : <span class="keyword">public</span> I2CFuturesGroup</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">explicit</span> SetGPIOSettingsFuture(<span class="keyword">const</span> vl53l0x::GPIOSettings&amp; settings)</div>
<div class="line">        :   I2CFuturesGroup{futures_, NUM_FUTURES},</div>
<div class="line">            write_config_{settings.function()},</div>
<div class="line">            write_GPIO_active_high_{uint8_t(settings.high_polarity() ? GPIO_LEVEL_HIGH : GPIO_LEVEL_LOW)},</div>
<div class="line">            write_low_threshold_{settings.low_threshold() / 2},</div>
<div class="line">            write_high_threshold_{settings.high_threshold() / 2}</div>
<div class="line">    {</div>
<div class="line">        <a class="code" href="namespaceboard.html#a2529f85498783a75dc75c281e0b754d3">I2CFuturesGroup::init</a>(futures_);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keyword">static</span> constexpr uint8_t GPIO_LEVEL_HIGH = 0x11;</div>
<div class="line">    <span class="keyword">static</span> constexpr uint8_t GPIO_LEVEL_LOW = 0x01;</div>
<div class="line">    TWriteRegisterFuture&lt;Register::SYSTEM_INTERRUPT_CONFIG_GPIO, vl53l0x::GPIOFunction&gt; write_config_;</div>
<div class="line">    TWriteRegisterFuture&lt;Register::GPIO_HV_MUX_ACTIVE_HIGH&gt; write_GPIO_active_high_;</div>
<div class="line">    TWriteRegisterFuture&lt;Register::SYSTEM_THRESH_LOW, uint16_t&gt; write_low_threshold_;</div>
<div class="line">    TWriteRegisterFuture&lt;Register::SYSTEM_THRESH_HIGH, uint16_t&gt; write_high_threshold_;</div>
<div class="line">    TWriteRegisterFuture&lt;Register::SYSTEM_INTERRUPT_CLEAR&gt; clear_interrupt_{0};</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static</span> constexpr uint8_t NUM_FUTURES = 5;</div>
<div class="line">    ABSTRACT_FUTURE* futures_[NUM_FUTURES] =</div>
<div class="line">    {</div>
<div class="line">        &amp;write_config_,</div>
<div class="line">        &amp;write_GPIO_active_high_,</div>
<div class="line">        &amp;write_low_threshold_,</div>
<div class="line">        &amp;write_high_threshold_,</div>
<div class="line">        &amp;clear_interrupt_</div>
<div class="line">    };</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> set_GPIO_settings(SetGPIOSettingsFuture&amp; <a class="code" href="namespacefuture.html">future</a>)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> (<a class="code" href="namespacefuture.html">future</a>.start(*<span class="keyword">this</span>) ? 0 : <a class="code" href="namespacefuture.html">future</a>.error());</div>
<div class="line">}</div>
<div class="ttc" id="anamespaceboard_html_a2529f85498783a75dc75c281e0b754d3"><div class="ttname"><a href="namespaceboard.html#a2529f85498783a75dc75c281e0b754d3">board::init</a></div><div class="ttdeci">static void init()</div><div class="ttdoc">Performs special initialization for the target MCU.</div><div class="ttdef"><b>Definition:</b> <a href="empty_8h_source.html#l00043">empty.h:43</a></div></div>
<div class="ttc" id="anamespacefuture_html"><div class="ttname"><a href="namespacefuture.html">future</a></div><div class="ttdoc">Contains the API around Future implementation.</div><div class="ttdef"><b>Definition:</b> <a href="future_8cpp_source.html#l00017">future.cpp:18</a></div></div>
</div><!-- fragment --><p>We see in the above example the future <code>SetGPIOSettingsFuture</code> that aggregates 5 futures to write values to distinct registers. Device method <code>set_GPIO_settings()</code> shows the peculiar way to start I2C commands directly through the <code>future.start()</code> method.</p>
<h2>I2C Bus handling</h2>
<p>Handling of the I2C bus by the I2C Manager and the <code>I2CDevice</code> follows standard I2C protocol, with some level of "intelligence".</p>
<p>In usual conditions: <code>launch_commands()</code> can execute long chains of commands on one device:</p><ol type="1">
<li>The first command in the chain will generate a "START" condition on the I2C bus as required by the I2C protocol</li>
<li>By default, all following commands will be preceded by a "REPEAT START" condition on the I2C bus</li>
<li>By default, the last command in the chain will <b>not</b> end with a "STOP" condition on the bus; FastArduino I2C Manager will keep the I2C bus for itself, unless required otherwise by I2C devices implementation.</li>
</ol>
<p>This default behaviour allows your I2C device API implementation to perform a sequence of calls to the I2C device, where the first call will acquire the bus, and all following calls in between will not need to acquire the bus.</p>
<p>You can change the default for each command or for a whole device:</p><ul>
<li>at command level, by setting <code>stop</code> argument to <code>true</code>, which will produce a "STOP" condition at the end of that command and a "START" condition on the next command in the chain.</li>
<li>at device level, by setting <code>auto_stop</code> constructor argument to <code>true</code>; then all chains of commands for the device will always end with a STOP condition.</li>
</ul>
<p><b>IMPORTANT:</b> Actually, asynchronous flavours of I2C Managers will release the I2C bus at the end of an I2C transaction, in case there is no more pending command (from another I2C transaction) in the commands queue.</p>
<h2>API Typical Example</h2>
<p>For many I2C devices, communication is based on writing and reading "registers", each device having its own list of specific registers. Hence most I2C device drivers API will consist in reading or writing one register.</p>
<p>In FastArduino, drivers like <code><a class="el" href="classdevices_1_1mcp230xx_1_1_m_c_p23008.html" title="I2C device driver for Microchip MCP23008 support.">devices::mcp230xx::MCP23008</a></code> first define <code>private</code> generic Future classes, later used by specific API to read registers:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>ReadRegisterFuture : <span class="keyword">public</span> FUTURE&lt;uint8_t, uint8_t&gt;</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">using</span> PARENT = FUTURE&lt;uint8_t, uint8_t&gt;;</div>
<div class="line"><span class="keyword">protected</span>:</div>
<div class="line">    ReadRegisterFuture(uint8_t address) : PARENT{address} {}</div>
<div class="line">    ReadRegisterFuture(ReadRegisterFuture&amp;&amp;) = <span class="keywordflow">default</span>;</div>
<div class="line">    ReadRegisterFuture&amp; operator=(ReadRegisterFuture&amp;&amp;) = <span class="keywordflow">default</span>;</div>
<div class="line">};</div>
</div><!-- fragment --><p>In this snippet, a base Future, <code>ReadRegisterFuture</code>, is defined. It will serve as a base class for all specific Futures needed by all API reading registers, like in the following excerpt from MCP23008 device: </p><div class="fragment"><div class="line"><span class="comment">// Address of GPIO register (to read digital input pins from MCP23008)</span></div>
<div class="line"><span class="keyword">static</span> constexpr <span class="keyword">const</span> uint8_t GPIO = 0x09;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>GetValuesFuture : <span class="keyword">public</span> ReadRegisterFuture</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    GetValuesFuture() : ReadRegisterFuture{GPIO} {}</div>
<div class="line">    GetValuesFuture(GetValuesFuture&amp;&amp;) = <span class="keywordflow">default</span>;</div>
<div class="line">    GetValuesFuture&amp; operator=(GetValuesFuture&amp;&amp;) = <span class="keywordflow">default</span>;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> values(PROXY&lt;GetValuesFuture&gt; <a class="code" href="namespacefuture.html">future</a>)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> this-&gt;launch_commands(<a class="code" href="namespacefuture.html">future</a>, {this-&gt;write(), this-&gt;read()});</div>
<div class="line">}</div>
</div><!-- fragment --><p>In the above code, the only added value of <code>GetValuesFuture</code> class is to embed the <code>GPIO</code> register address; this allows callers of the <code>values()</code> API to directly instantiate this Future without further input.</p>
<p>The implementation of <code>values()</code> is a one-liner that requires a few explanations:</p><ul>
<li><code>launch_commands()</code> has only 2 arguments: <code>future</code> that is directly passed from the API argument, and a list of commands (embedded within braces)</li>
<li>in this example, there are only 2 commands; the first, returned by <code>write()</code>, writes all input content of <code>future</code>, i.e. the <code>GPIO</code> register address (single) byte); the second command, created by <code>read()</code>, reads enough bytes (only one here) from the decice to fill the output of <code>future</code>.</li>
<li>both commands are created with default calls to <code>read()</code> and <code>write()</code> i.e. <code>0</code> for bytes count (special meaning: use full content size of <code>future</code>), <code>false</code> for <code>finish_future</code> and <code>stop</code>, leading to generation of "START" condition at the beginning, and no STOP forced at the end.</li>
</ul>
<p>A similar approach is used for writing a value to a device register and will not be detailed here.</p>
<h1>Debugging support for a new device (low-level) </h1>
<p>In general, before developing a full-fledged driver for an I2C device, you need to learn how to use that device.</p>
<p>Based on the device datasheet, you first learn how to manipulate the device through the I2C bus.</p>
<p>For better understanding, you generally use a debugging example that helps demonstrate how the device works.</p>
<p>One easy way to develop such a debugging sample is to create a program with just one source code file containing:</p><ul>
<li>proper <code>#include</code> directives</li>
<li>a <code>PublicDevice</code> class that derives from <code><a class="el" href="classi2c_1_1_i2_c_device.html" title="Base class for all I2C devices.">i2c::I2CDevice</a></code> but declares <code>main()</code> as a <code>friend</code>, which allows direct calls, from <code>main()</code>, to <code>protected</code> API of <code><a class="el" href="classi2c_1_1_i2_c_device.html" title="Base class for all I2C devices.">i2c::I2CDevice</a></code>, for easy testing</li>
<li>directly call SPI API on a <code>PublicDevice</code> instance, from <code>main()</code> and trace results to a console, through UART</li>
<li>use, as I2C Manager, <code>I2CSyncDebugManager</code> or <code>I2CSyncDebugStatusManager</code>, which allow tracing (live or later) all steps of I2C transactions</li>
</ul>
<p>FastArduino includes such a debugging sample in <code>examples/i2c/I2CDeviceProto</code> example, copied hereafter:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="comment">//   Copyright 2016-2022 Jean-Francois Poilpret</span></div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;<span class="comment">//   Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span></div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;<span class="comment">//   you may not use this file except in compliance with the License.</span></div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;<span class="comment">//   You may obtain a copy of the License at</span></div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;<span class="comment">//       http://www.apache.org/licenses/LICENSE-2.0</span></div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;<span class="comment">//</span></div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;<span class="comment">//   Unless required by applicable law or agreed to in writing, software</span></div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;<span class="comment">//   distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span></div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;<span class="comment">//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;<span class="comment">//   See the License for the specific language governing permissions and</span></div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;<span class="comment">//   limitations under the License.</span></div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160; </div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;<span class="comment">/*</span></div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;<span class="comment"> * This is a skeleton program to help connect, debug and understand how a given</span></div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;<span class="comment"> * I2C device (not already supported by FastArduino) works.</span></div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;<span class="comment"> * That helps creating a new specific support API for that device for reuse in </span></div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;<span class="comment"> * other programs and potential integration to FastArduino project.</span></div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;<span class="comment"> * To ease wiring and debugging, I suggest using a real Arduino board (I typically </span></div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;<span class="comment"> * use UNO) and a small breadboard for connecting the I2C device.</span></div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;<span class="comment"> * </span></div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;<span class="comment"> * Wiring:</span></div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;<span class="comment"> * NB: you should add pullup resistors (10K-22K typically) on both SDA and SCL lines.</span></div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;<span class="comment"> * - on Arduino UNO:</span></div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;<span class="comment"> *   - A4 (PC4, SDA): connected to I2C SDA pin</span></div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;<span class="comment"> *   - A5 (PC5, SCL): connected to I2C SCL pin</span></div>
<div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;<span class="comment"> *   - direct USB access (traces output)</span></div>
<div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;<span class="comment"> */</span></div>
<div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160; </div>
<div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;<span class="preprocessor">#include &lt;<a class="code" href="time_8h.html">fastarduino/time.h</a>&gt;</span></div>
<div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;<span class="preprocessor">#include &lt;<a class="code" href="i2c__device_8h.html">fastarduino/i2c_device.h</a>&gt;</span></div>
<div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;<span class="preprocessor">#include &lt;<a class="code" href="utilities_8h.html">fastarduino/utilities.h</a>&gt;</span></div>
<div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;<span class="preprocessor">#include &lt;<a class="code" href="uart_8h.html">fastarduino/uart.h</a>&gt;</span></div>
<div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;<span class="preprocessor">#include &lt;<a class="code" href="i2c__debug_8h.html">fastarduino/i2c_debug.h</a>&gt;</span></div>
<div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160; </div>
<div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;<span class="comment">// I2C Device specific constants go here</span></div>
<div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;<span class="comment">//======================================</span></div>
<div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;<span class="keyword">static</span> constexpr <span class="keyword">const</span> <a class="code" href="namespacei2c.html#ac2780f0139dbc26f4d83a426dad67e36">i2c::I2CMode</a> MODE = <a class="code" href="namespacei2c.html#ac2780f0139dbc26f4d83a426dad67e36adca6e617f6fb54033deb311e7e7c93cc">i2c::I2CMode::FAST</a>;</div>
<div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;<span class="keyword">static</span> constexpr <span class="keyword">const</span> uint8_t DEVICE_ADDRESS = 0x68 &lt;&lt; 1;</div>
<div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160; </div>
<div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;<span class="keyword">static</span> constexpr <span class="keyword">const</span> uint8_t DEBUG_SIZE = 32;</div>
<div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;<span class="keyword">using</span> DEBUGGER = <a class="code" href="classi2c_1_1debug_1_1_i2_c_debug_status_recorder.html">i2c::debug::I2CDebugStatusRecorder&lt;DEBUG_SIZE, DEBUG_SIZE&gt;</a>;</div>
<div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;<span class="keyword">using</span> MANAGER = <a class="code" href="classi2c_1_1_i2_c_sync_status_debug_manager.html">i2c::I2CSyncStatusDebugManager&lt;MODE, DEBUGGER&amp;, DEBUGGER&amp;&gt;</a>;</div>
<div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;<span class="preprocessor">#define DEBUG(OUT) debugger.trace(OUT)</span></div>
<div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160; </div>
<div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;<span class="comment">// The following type aliases will be useful for declaring proper Futures and calling I2CDevice API</span></div>
<div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;<span class="keyword">using</span> PARENT = <a class="code" href="classi2c_1_1_i2_c_device.html">i2c::I2CDevice&lt;MANAGER&gt;</a>;</div>
<div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;<span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">using</span> PROXY = <span class="keyword">typename</span> PARENT::template PROXY&lt;T&gt;;</div>
<div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;<span class="keyword">template</span>&lt;<span class="keyword">typename</span> OUT, <span class="keyword">typename</span> IN&gt; <span class="keyword">using</span> FUTURE = <span class="keyword">typename</span> PARENT::template FUTURE&lt;OUT, IN&gt;;</div>
<div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160; </div>
<div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;<span class="comment">// Define vectors we need in the example</span></div>
<div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;<a class="code" href="uart_8h.html#aa33c57bb6fa1e93177abb21fe8fecb10">REGISTER_UATX_ISR</a>(0)</div>
<div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;<a class="code" href="streambuf_8h.html#a94aa054887c53435c9f96e6f5e096982">REGISTER_OSTREAMBUF_LISTENERS</a>(<a class="code" href="namespaceserial.html">serial</a>::hard::UATX&lt;<a class="code" href="namespaceboard.html">board</a>::<a class="code" href="namespaceboard.html#a8541ca1f10a050c4356d6ccd76d9a907">USART</a>::USART0&gt;)</div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160; </div>
<div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;<span class="comment">// UART for traces</span></div>
<div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;static constexpr const uint8_t OUTPUT_BUFFER_SIZE = 64;</div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;static <span class="keywordtype">char</span> output_buffer[OUTPUT_BUFFER_SIZE];</div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;static <a class="code" href="namespaceserial.html">serial</a>::hard::UATX&lt;<a class="code" href="namespaceboard.html">board</a>::<a class="code" href="namespaceboard.html#a8541ca1f10a050c4356d6ccd76d9a907">USART</a>::USART0&gt; uart{output_buffer};</div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;<span class="keyword">static</span> <a class="code" href="classstreams_1_1ostream.html">streams::ostream</a> out = uart.out();</div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160; </div>
<div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;<span class="comment">// Subclass I2CDevice to make protected methods available</span></div>
<div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;<span class="keyword">class </span>PublicDevice: <span class="keyword">public</span> PARENT</div>
<div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;{</div>
<div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;<span class="keyword">public</span>:</div>
<div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;    PublicDevice(MANAGER&amp; manager): PARENT{manager, DEVICE_ADDRESS, <a class="code" href="namespacei2c.html">i2c</a>::<a class="code" href="namespacespi.html#afad82e7a839263bc0851445fdcced0bb">Mode</a>&lt;MODE&gt;{}, <span class="keyword">true</span>} {}</div>
<div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;    <span class="keyword">friend</span> <span class="keywordtype">int</span> main();</div>
<div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;};</div>
<div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160; </div>
<div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;<span class="keyword">using</span> <a class="code" href="namespacestreams.html#a25bd12279d518b57e4fb97c533c17b22">streams::endl</a>;</div>
<div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;<span class="keyword">using</span> <a class="code" href="namespacestreams.html#adaf650921b3a5d448f8aac51dba924d2">streams::dec</a>;</div>
<div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;<span class="keyword">using</span> <a class="code" href="namespacestreams.html#a91675bd61b31e7382e8655930606f62f">streams::hex</a>;</div>
<div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160; </div>
<div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;<span class="keywordtype">int</span> main()</div>
<div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;{</div>
<div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;    <a class="code" href="namespaceboard.html#a2529f85498783a75dc75c281e0b754d3">board::init</a>();</div>
<div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;    sei();</div>
<div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;    </div>
<div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;    uart.begin(115200);</div>
<div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;    out.<a class="code" href="classstreams_1_1ios__base.html#a46cf9813c05c34ff93d8ff19eff1ea9f">width</a>(2);</div>
<div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;    </div>
<div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;    <span class="comment">// Start TWI interface</span></div>
<div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;    <span class="comment">//====================</span></div>
<div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;    DEBUGGER debugger;</div>
<div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;    MANAGER manager{debugger, debugger};</div>
<div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;    manager.begin();</div>
<div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;    out &lt;&lt; <a class="code" href="flash_8h.html#a16c40764aaba0de309f5ff429c8bac15">F</a>(<span class="stringliteral">&quot;I2C interface started&quot;</span>) &lt;&lt; <a class="code" href="namespacestreams.html#a25bd12279d518b57e4fb97c533c17b22">endl</a>;</div>
<div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;    </div>
<div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;    PublicDevice device{manager};</div>
<div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;    </div>
<div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;    <span class="comment">// Init I2C device if needed</span></div>
<div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160; </div>
<div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;    <span class="comment">// Output all debug traces</span></div>
<div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;    <a class="code" href="namespacei2c_1_1debug.html#aa73d62f49bbf5a9cd8ced80e467cefcc">DEBUG</a>(out);</div>
<div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;    </div>
<div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;    <span class="comment">// Loop to show measures</span></div>
<div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;    <span class="keywordflow">while</span> (<span class="keyword">true</span>)</div>
<div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;    {</div>
<div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;        <span class="comment">// Read measures and display them to UART</span></div>
<div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160; </div>
<div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;        <span class="comment">// Output all debug traces</span></div>
<div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;        <a class="code" href="namespacei2c_1_1debug.html#aa73d62f49bbf5a9cd8ced80e467cefcc">DEBUG</a>(out);</div>
<div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160; </div>
<div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;        <a class="code" href="namespacetime.html#af13fd17ddf6b751b8161691e608892b2">time::delay_ms</a>(1000);</div>
<div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;    }</div>
<div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;    </div>
<div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;    <span class="comment">// Stop TWI interface</span></div>
<div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;    <span class="comment">//===================</span></div>
<div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;    manager.end();</div>
<div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;    out &lt;&lt; <a class="code" href="flash_8h.html#a16c40764aaba0de309f5ff429c8bac15">F</a>(<span class="stringliteral">&quot;End&quot;</span>) &lt;&lt; <a class="code" href="namespacestreams.html#a25bd12279d518b57e4fb97c533c17b22">endl</a>;</div>
<div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;}</div>
<div class="ttc" id="aclassi2c_1_1_i2_c_sync_status_debug_manager_html"><div class="ttname"><a href="classi2c_1_1_i2_c_sync_status_debug_manager.html">i2c::I2CSyncStatusDebugManager</a></div><div class="ttdoc">Synchronous I2C Manager for ATmega architecture with status notification and debug facility.</div><div class="ttdef"><b>Definition:</b> <a href="i2c__handler__atmega_8h_source.html#l01247">i2c_handler_atmega.h:1249</a></div></div>
<div class="ttc" id="aclassi2c_1_1debug_1_1_i2_c_debug_status_recorder_html"><div class="ttname"><a href="classi2c_1_1debug_1_1_i2_c_debug_status_recorder.html">i2c::debug::I2CDebugStatusRecorder</a></div><div class="ttdoc">Class recording I2C debug and status notifications for later output.</div><div class="ttdef"><b>Definition:</b> <a href="i2c__debug_8h_source.html#l00309">i2c_debug.h:311</a></div></div>
<div class="ttc" id="aclassstreams_1_1ios__base_html_a46cf9813c05c34ff93d8ff19eff1ea9f"><div class="ttname"><a href="classstreams_1_1ios__base.html#a46cf9813c05c34ff93d8ff19eff1ea9f">streams::ios_base::width</a></div><div class="ttdeci">void width(uint8_t width)</div><div class="ttdoc">Set minimum width used for displaying values.</div><div class="ttdef"><b>Definition:</b> <a href="ios_8h_source.html#l00390">ios.h:390</a></div></div>
<div class="ttc" id="aclassstreams_1_1ostream_html"><div class="ttname"><a href="classstreams_1_1ostream.html">streams::ostream</a></div><div class="ttdoc">Output stream wrapper to provide formatted output API, a la C++.</div><div class="ttdef"><b>Definition:</b> <a href="streams_8h_source.html#l00060">streams.h:61</a></div></div>
<div class="ttc" id="aflash_8h_html_a16c40764aaba0de309f5ff429c8bac15"><div class="ttname"><a href="flash_8h.html#a16c40764aaba0de309f5ff429c8bac15">F</a></div><div class="ttdeci">#define F(ptr)</div><div class="ttdoc">Force string constant to be stored as flash storage.</div><div class="ttdef"><b>Definition:</b> <a href="flash_8h_source.html#l00118">flash.h:118</a></div></div>
<div class="ttc" id="ai2c__debug_8h_html"><div class="ttname"><a href="i2c__debug_8h.html">i2c_debug.h</a></div><div class="ttdoc">I2C debugging utilities (useful when implementing support for new devices).</div></div>
<div class="ttc" id="ai2c__device_8h_html"><div class="ttname"><a href="i2c__device_8h.html">i2c_device.h</a></div><div class="ttdoc">I2C Device API.</div></div>
<div class="ttc" id="anamespaceboard_html"><div class="ttname"><a href="namespaceboard.html">board</a></div><div class="ttdoc">Defines all types and constants specific to support Arduino MEGA board (ATmega644 MCU target).</div><div class="ttdef"><b>Definition:</b> <a href="atmega__xx4_8h_source.html#l00038">atmega_xx4.h:39</a></div></div>
<div class="ttc" id="anamespaceboard_html_a8541ca1f10a050c4356d6ccd76d9a907"><div class="ttname"><a href="namespaceboard.html#a8541ca1f10a050c4356d6ccd76d9a907">board::USART</a></div><div class="ttdeci">USART</div><div class="ttdoc">Defines all USART modules of target MCU.</div><div class="ttdef"><b>Definition:</b> <a href="empty_8h_source.html#l00104">empty.h:105</a></div></div>
<div class="ttc" id="anamespacei2c_1_1debug_html_aa73d62f49bbf5a9cd8ced80e467cefcc"><div class="ttname"><a href="namespacei2c_1_1debug.html#aa73d62f49bbf5a9cd8ced80e467cefcc">i2c::debug::DEBUG</a></div><div class="ttdeci">DEBUG</div><div class="ttdoc">Indicate what in I2C protocol shall be debugged.</div><div class="ttdef"><b>Definition:</b> <a href="i2c__debug_8h_source.html#l00054">i2c_debug.h:55</a></div></div>
<div class="ttc" id="anamespacei2c_html_ac2780f0139dbc26f4d83a426dad67e36"><div class="ttname"><a href="namespacei2c.html#ac2780f0139dbc26f4d83a426dad67e36">i2c::I2CMode</a></div><div class="ttdeci">I2CMode</div><div class="ttdoc">I2C available transmission modes.</div><div class="ttdef"><b>Definition:</b> <a href="i2c_8h_source.html#l00107">i2c.h:108</a></div></div>
<div class="ttc" id="anamespacei2c_html_ac2780f0139dbc26f4d83a426dad67e36adca6e617f6fb54033deb311e7e7c93cc"><div class="ttname"><a href="namespacei2c.html#ac2780f0139dbc26f4d83a426dad67e36adca6e617f6fb54033deb311e7e7c93cc">i2c::I2CMode::FAST</a></div><div class="ttdeci">@ FAST</div><div class="ttdoc">I2C Fast mode, less than 400KHz.</div></div>
<div class="ttc" id="anamespaceserial_html"><div class="ttname"><a href="namespaceserial.html">serial</a></div><div class="ttdoc">Defines all API for UART features.</div><div class="ttdef"><b>Definition:</b> <a href="soft__uart_8h_source.html#l00083">soft_uart.h:84</a></div></div>
<div class="ttc" id="anamespacespi_html_afad82e7a839263bc0851445fdcced0bb"><div class="ttname"><a href="namespacespi.html#afad82e7a839263bc0851445fdcced0bb">spi::Mode</a></div><div class="ttdeci">Mode</div><div class="ttdoc">SPI transmission mode.</div><div class="ttdef"><b>Definition:</b> <a href="spi_8h_source.html#l00109">spi.h:110</a></div></div>
<div class="ttc" id="anamespacestreams_html_a25bd12279d518b57e4fb97c533c17b22"><div class="ttname"><a href="namespacestreams.html#a25bd12279d518b57e4fb97c533c17b22">streams::endl</a></div><div class="ttdeci">void endl(FSTREAM &amp;stream)</div><div class="ttdoc">Manipulator for an output stream, which will insert a new-line character and flush the stream buffer.</div><div class="ttdef"><b>Definition:</b> <a href="streams_8h_source.html#l00722">streams.h:722</a></div></div>
<div class="ttc" id="anamespacestreams_html_a91675bd61b31e7382e8655930606f62f"><div class="ttname"><a href="namespacestreams.html#a91675bd61b31e7382e8655930606f62f">streams::hex</a></div><div class="ttdeci">void hex(FSTREAM &amp;stream)</div><div class="ttdoc">Manipulator for an output or input stream, which will set the base, used to represent (output) or int...</div><div class="ttdef"><b>Definition:</b> <a href="ios_8h_source.html#l00774">ios.h:774</a></div></div>
<div class="ttc" id="anamespacestreams_html_adaf650921b3a5d448f8aac51dba924d2"><div class="ttname"><a href="namespacestreams.html#adaf650921b3a5d448f8aac51dba924d2">streams::dec</a></div><div class="ttdeci">void dec(FSTREAM &amp;stream)</div><div class="ttdoc">Manipulator for an output or input stream, which will set the base, used to represent (output) or int...</div><div class="ttdef"><b>Definition:</b> <a href="ios_8h_source.html#l00765">ios.h:765</a></div></div>
<div class="ttc" id="anamespacetime_html_af13fd17ddf6b751b8161691e608892b2"><div class="ttname"><a href="namespacetime.html#af13fd17ddf6b751b8161691e608892b2">time::delay_ms</a></div><div class="ttdeci">void delay_ms(uint16_t ms) INLINE</div><div class="ttdoc">Delay program execution for the given amount of milliseconds.</div><div class="ttdef"><b>Definition:</b> <a href="time_8h_source.html#l00346">time.h:346</a></div></div>
<div class="ttc" id="astreambuf_8h_html_a94aa054887c53435c9f96e6f5e096982"><div class="ttname"><a href="streambuf_8h.html#a94aa054887c53435c9f96e6f5e096982">REGISTER_OSTREAMBUF_LISTENERS</a></div><div class="ttdeci">#define REGISTER_OSTREAMBUF_LISTENERS(HANDLER1,...)</div><div class="ttdoc">Register the necessary callbacks that will be notified when a streams::ostreambuf is put new content ...</div><div class="ttdef"><b>Definition:</b> <a href="streambuf_8h_source.html#l00049">streambuf.h:49</a></div></div>
<div class="ttc" id="atime_8h_html"><div class="ttname"><a href="time_8h.html">time.h</a></div><div class="ttdoc">Simple time utilities.</div></div>
<div class="ttc" id="auart_8h_html"><div class="ttname"><a href="uart_8h.html">uart.h</a></div><div class="ttdoc">Hardware serial API.</div></div>
<div class="ttc" id="auart_8h_html_aa33c57bb6fa1e93177abb21fe8fecb10"><div class="ttname"><a href="uart_8h.html#aa33c57bb6fa1e93177abb21fe8fecb10">REGISTER_UATX_ISR</a></div><div class="ttdeci">#define REGISTER_UATX_ISR(UART_NUM)</div><div class="ttdoc">Register the necessary ISR (Interrupt Service Routine) for an serial::hard::UATX to work correctly.</div><div class="ttdef"><b>Definition:</b> <a href="uart_8h_source.html#l00037">uart.h:37</a></div></div>
<div class="ttc" id="autilities_8h_html"><div class="ttname"><a href="utilities_8h.html">utilities.h</a></div><div class="ttdoc">General utilities API that have broad application in programs.</div></div>
</div><!-- fragment --><p>This example is just an empty skeleton for your own tests. It is made of several parts:</p>
 <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="time_8h.html">fastarduino/time.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="i2c__device_8h.html">fastarduino/i2c_device.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="utilities_8h.html">fastarduino/utilities.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="uart_8h.html">fastarduino/uart.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="i2c__debug_8h.html">fastarduino/i2c_debug.h</a>&gt;</span></div>
</div><!-- fragment --><p>Those lines include a few headers necessary (or just useful) to debug an I2C device.</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> constexpr <span class="keyword">const</span> <a class="code" href="namespacei2c.html#ac2780f0139dbc26f4d83a426dad67e36">i2c::I2CMode</a> MODE = <a class="code" href="namespacei2c.html#ac2780f0139dbc26f4d83a426dad67e36adca6e617f6fb54033deb311e7e7c93cc">i2c::I2CMode::FAST</a>;</div>
<div class="line"><span class="keyword">static</span> constexpr <span class="keyword">const</span> uint8_t DEVICE_ADDRESS = 0x68 &lt;&lt; 1;</div>
</div><!-- fragment --><p>Any specificity of the tested I2C device is defined as a constant in the next code section. Note the definition of <code>DEVICE_ADDRESS</code> constant: this 7-bit I2C device address is shifted one bit left as an 8th bit will be added (I2C communication protocol) to define data direction for each transmission.</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> constexpr <span class="keyword">const</span> uint8_t DEBUG_SIZE = 32;</div>
<div class="line"><span class="keyword">using</span> DEBUGGER = <a class="code" href="classi2c_1_1debug_1_1_i2_c_debug_status_recorder.html">i2c::debug::I2CDebugStatusRecorder&lt;DEBUG_SIZE, DEBUG_SIZE&gt;</a>;</div>
<div class="line"><span class="keyword">using</span> MANAGER = <a class="code" href="classi2c_1_1_i2_c_sync_status_debug_manager.html">i2c::I2CSyncStatusDebugManager&lt;MODE, DEBUGGER&amp;, DEBUGGER&amp;&gt;</a>;</div>
<div class="line"><span class="preprocessor">#define DEBUG(OUT) debugger.trace(OUT)</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// The following type aliases will be useful for declaring proper Futures and calling I2CDevice API</span></div>
<div class="line"><span class="keyword">using</span> PARENT = <a class="code" href="classi2c_1_1_i2_c_device.html">i2c::I2CDevice&lt;MANAGER&gt;</a>;</div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">using</span> PROXY = <span class="keyword">typename</span> PARENT::template PROXY&lt;T&gt;;</div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> OUT, <span class="keyword">typename</span> IN&gt; <span class="keyword">using</span> FUTURE = <span class="keyword">typename</span> PARENT::template FUTURE&lt;OUT, IN&gt;;</div>
</div><!-- fragment --><p>This section defines various types aliases, for I2C Manager, I2C debugger, and types used as part of device API definition. In addition, a <code>DEBUG</code> macro to debug all I2C steps after API execution is defined.</p>
<div class="fragment"><div class="line"><a class="code" href="uart_8h.html#aa33c57bb6fa1e93177abb21fe8fecb10">REGISTER_UATX_ISR</a>(0)</div>
<div class="line"><a class="code" href="streambuf_8h.html#a94aa054887c53435c9f96e6f5e096982">REGISTER_OSTREAMBUF_LISTENERS</a>(<a class="code" href="namespaceserial.html">serial</a>::hard::UATX&lt;<a class="code" href="namespaceboard.html">board</a>::<a class="code" href="namespaceboard.html#a8541ca1f10a050c4356d6ccd76d9a907">USART</a>::USART0&gt;)</div>
<div class="line"> </div>
<div class="line"><span class="comment">// UART for traces</span></div>
<div class="line">static constexpr const uint8_t OUTPUT_BUFFER_SIZE = 64;</div>
<div class="line">static <span class="keywordtype">char</span> output_buffer[OUTPUT_BUFFER_SIZE];</div>
<div class="line">static <a class="code" href="namespaceserial.html">serial</a>::hard::UATX&lt;<a class="code" href="namespaceboard.html">board</a>::<a class="code" href="namespaceboard.html#a8541ca1f10a050c4356d6ccd76d9a907">USART</a>::USART0&gt; uart{output_buffer};</div>
<div class="line"><span class="keyword">static</span> <a class="code" href="classstreams_1_1ostream.html">streams::ostream</a> out = uart.out();</div>
</div><!-- fragment --><p>Then an output stream is created for tracing through UART, and the necessary UART ISR is registered.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>PublicDevice: <span class="keyword">public</span> PARENT</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    PublicDevice(MANAGER&amp; manager): PARENT{manager, DEVICE_ADDRESS, <a class="code" href="namespacei2c.html">i2c</a>::<a class="code" href="namespacespi.html#afad82e7a839263bc0851445fdcced0bb">Mode</a>&lt;MODE&gt;{}, <span class="keyword">true</span>} {}</div>
<div class="line">    <span class="keyword">friend</span> <span class="keywordtype">int</span> main();</div>
<div class="line">};</div>
</div><!-- fragment --><p>This is where we define a utility class to debug our I2C interface to the tested device. <code>PublicDevice</code> class does <b>nothing</b> but making all protected methods callable from <code>main()</code>, so that we can directly perform our code tests in <code>main()</code>, without thinking much about proper API design now.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="namespaceboard.html#a2529f85498783a75dc75c281e0b754d3">board::init</a>();</div>
<div class="line">    sei();</div>
<div class="line">    </div>
<div class="line">    uart.begin(115200);</div>
<div class="line">    out.<a class="code" href="classstreams_1_1ios__base.html#a46cf9813c05c34ff93d8ff19eff1ea9f">width</a>(2);</div>
</div><!-- fragment --><p>This is the <code>main()</code> function where it all happens. First we initialize the MCU and the UART for tracing.</p>
<div class="fragment"><div class="line">    MANAGER manager{debugger, debugger};</div>
<div class="line">    manager.begin();</div>
</div><!-- fragment --><p>Here we simply initialize I2C function on the UNO.</p>
<div class="fragment"><div class="line">    PublicDevice device{manager};</div>
</div><!-- fragment --><p>We then declare the <code>device</code> variable that we will use for testing our I2C device.</p>
<p>Finally the rest of the code is placeholder for any initialization API, followed by an infinite loop where you can call lauinch_commands/read/write methods on <code>device</code> in order to test the way to handle the target device.</p>
<h1>Defining the driver API based on device features </h1>
<p>At this level, you have already been able to debug how the device works and you have a good overview of what features you want to provide to developers (and to yourself as the first of all) who will want to use this device.</p>
<p>An easy way is to provide an API that maps every feature found in the datasheet to its dedicated method. This is what we would call a low-level API; that is the minimum your driver should provide.</p>
<p>Additionally <code>MyI2CDevice</code> might implement a higher level API, based on the low-level one, but this is not mandatory; actually, this is not even advised generally, as this high-level API might be implemented in a distinct class. Using a separate class for high-level API allows other developers to develop their own high-level API without having to use yours if it does not fit their needs.</p>
<p>It is often advised to add <code>begin()</code> and <code>end()</code> methods to <code>MyI2CDevice</code> when it makes sense. <code>begin()</code> would initialize the device before usage (most devices will require special setup before use).</p>
<h1>Implementing the driver API </h1>
<p>This step consists in implementing the API defined in the step before.</p>
<p>Typically every API will be made of:</p><ul>
<li>a specific Future class taht encapsulates input arguments (in its constructor) and holds place for output; this Future shall embed any necessary conversion of input arguments if needed, as well as conversion of output, through override of <code>get()</code> method</li>
<li>one asynchronous method taking as only argument <code>PROXY</code> to the Future defined above, calling <code>launch_commands()</code> withe <code>write()</code> and <code>read()</code> calls to prepare I2C commands, as described above in the description of <code><a class="el" href="classi2c_1_1_i2_c_device.html" title="Base class for all I2C devices.">i2c::I2CDevice</a></code> API</li>
<li>one synchronous method taking same arguments as Future constructor defined above, plus a reference argument for any output; this method instantiates the above Future, calls the asynchronous method defined before, and awaits the Future to be ready and get its output</li>
</ul>
<p>Here is a concrete example from <code><a class="el" href="classdevices_1_1rtc_1_1_d_s1307.html" title="I2C device driver for the DS1307 RTC chip.">devices::rtc::DS1307</a></code>, another I2C device driver in FastArduino.</p>
<p>The first snippet below defines a specific Future for getting current datetime from the device: </p><div class="fragment"><div class="line"><span class="keyword">static</span> constexpr <span class="keyword">const</span> uint8_t TIME_ADDRESS = 0x00;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>GetDatetimeFuture : <span class="keyword">public</span> FUTURE&lt;tm, uint8_t&gt;</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    GetDatetimeFuture() : FUTURE&lt;tm, uint8_t&gt;{TIME_ADDRESS} {}</div>
<div class="line">    GetDatetimeFuture(GetDatetimeFuture&amp;&amp;) = <span class="keywordflow">default</span>;</div>
<div class="line">    GetDatetimeFuture&amp; operator=(GetDatetimeFuture&amp;&amp;) = <span class="keywordflow">default</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">bool</span> get(tm&amp; datetime)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">if</span> (!FUTURE&lt;tm, uint8_t&gt;::get(datetime)) <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">        <span class="comment">// convert DS1307 output (BCD) to integer type</span></div>
<div class="line">        datetime.tm_sec = <a class="code" href="namespaceutils.html#af5b3426ba48caf5ee96ed71fa8b7bb5e">utils::bcd_to_binary</a>(datetime.tm_sec);</div>
<div class="line">        datetime.tm_min = <a class="code" href="namespaceutils.html#af5b3426ba48caf5ee96ed71fa8b7bb5e">utils::bcd_to_binary</a>(datetime.tm_min);</div>
<div class="line">        datetime.tm_hour = <a class="code" href="namespaceutils.html#af5b3426ba48caf5ee96ed71fa8b7bb5e">utils::bcd_to_binary</a>(datetime.tm_hour);</div>
<div class="line">        datetime.tm_mday = <a class="code" href="namespaceutils.html#af5b3426ba48caf5ee96ed71fa8b7bb5e">utils::bcd_to_binary</a>(datetime.tm_mday);</div>
<div class="line">        datetime.tm_mon = <a class="code" href="namespaceutils.html#af5b3426ba48caf5ee96ed71fa8b7bb5e">utils::bcd_to_binary</a>(datetime.tm_mon);</div>
<div class="line">        datetime.tm_year = <a class="code" href="namespaceutils.html#af5b3426ba48caf5ee96ed71fa8b7bb5e">utils::bcd_to_binary</a>(datetime.tm_year);</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="ttc" id="anamespaceutils_html_af5b3426ba48caf5ee96ed71fa8b7bb5e"><div class="ttname"><a href="namespaceutils.html#af5b3426ba48caf5ee96ed71fa8b7bb5e">utils::bcd_to_binary</a></div><div class="ttdeci">uint8_t bcd_to_binary(uint8_t bcd)</div><div class="ttdoc">Convert Binary-coded decimal byte (each nibble is a digit from 0 to 9) into a natural byte.</div><div class="ttdef"><b>Definition:</b> <a href="utilities_8h_source.html#l00343">utilities.h:343</a></div></div>
</div><!-- fragment --><p> In this code, <code>tm</code> is a strcuture to hold all parts of a datetime.</p>
<p>The constructor takes no argument: it just passes <code>TIME_ADDRESS</code> constant to the superclass.</p>
<p>Note the overridden <code>get()</code> method, necessary to convert raw datetime data read from the device, to properly formatted data, usable by the caller program.</p>
<p>The second snippet shows the asynchronous API method: </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> get_datetime(PROXY&lt;GetDatetimeFuture&gt; <a class="code" href="namespacefuture.html">future</a>)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> this-&gt;launch_commands(<a class="code" href="namespacefuture.html">future</a>, {this-&gt;write(), this-&gt;read()});</div>
<div class="line">}</div>
</div><!-- fragment --><p> In this code, one read and one write commands are generated and sent to the I2C Manager for execution (immediate or deferred, depending on the I2C Manager associated to the device); the write command writes all bytes from <code>GetDatetimeFuture</code>, i.e. one byte; the read command reads as many bytes as expected by <code>GetDatetimeFuture</code>, i.e. one byte. Although not directly visible in this snippet, at the end of the I2C transaction (end of read command), a "STOP" condition is generated, releasing the I2C bus. This seems required by DS1307 device (from experiment) to release the bus between two consecutive transactions. This is why <code>DS1307</code> device constructor sets <code>auto_stop</code> to <code>true</code>.</p>
<p>The last snippet demonstrates implementation of the synchronous API method: </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> get_datetime(tm&amp; datetime)</div>
<div class="line">{</div>
<div class="line">    GetDatetimeFuture <a class="code" href="namespacefuture.html">future</a>;</div>
<div class="line">    <span class="keywordflow">if</span> (get_datetime(<a class="code" href="namespacelifecycle.html#adfb75b7b635e51bfeac0c7cb8b1138fe">PARENT::make_proxy</a>(<a class="code" href="namespacefuture.html">future</a>)) != 0) <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code" href="namespacefuture.html">future</a>.get(datetime);</div>
<div class="line">}</div>
<div class="ttc" id="anamespacelifecycle_html_adfb75b7b635e51bfeac0c7cb8b1138fe"><div class="ttname"><a href="namespacelifecycle.html#adfb75b7b635e51bfeac0c7cb8b1138fe">lifecycle::make_proxy</a></div><div class="ttdeci">Proxy&lt; T &gt; make_proxy(const T &amp;dest)</div><div class="ttdoc">Utility template function to create a Proxy&lt;T&gt; from dest without the need to speicify T.</div><div class="ttdef"><b>Definition:</b> <a href="lifecycle_8h_source.html#l00593">lifecycle.h:593</a></div></div>
</div><!-- fragment --><p> The implementation is totally based on the asynchronous method: it instantiates a <code>GetDatetimeFuture</code> future, passes it as a <code>PROXY</code>, through <code>PARENT::make_proxy(future)</code> to the asynchronous method. If the asynchronous method fails (return <code>!= 0</code>), then we return <code>false</code> immediately; otherwise, we await on <code>future</code>, through the call of <code>future.get(datetime)</code> which is blocked until <code>future</code> is <code>READY</code> or in <code>ERROR</code>.</p>
<h1>The last mile: add driver to FastArduino project! </h1>
<p>Bravo! You successfully added FastArduino support, in your own project, for a specific I2C device!</p>
<p>The last mile would now consist in adding your valuable work to FastArduino library! You do not <em>have to</em>, of course, but this would be a good way to:</p><ul>
<li>thank other people who provided FastArduino open source library to you</li>
<li>feel part of the community</li>
<li>get feedback on your work, potentially allowing it to be further improved</li>
<li>share your work with the rest of the world</li>
</ul>
<p>However, like for a marathon, the last mile can be difficult! In order to run this last mile, you will have to:</p><ul>
<li>first accept FastArduino Apache License 2.0 for your contribution, or discuss with FastArduino owner for another one, if compatible</li>
<li>follow FastArduino coding guidelines: this might impose some code rewrite or reformatting</li>
<li>add API documentation with doxygen: this is mandatory for all <code>public</code> methods, and advised for <code>protected</code> ones.</li>
<li>add one (or more) usage example and integrate it in the <code>examples/i2c</code> directory; examples must be kept simple but still demonstrate the API usage; example circuits (connection pins) shall be described. These examples can be further used as "tests" before new releases of FastArduino.</li>
<li>optionally develop a tutorial for this device</li>
<li>prepare and propose a PR to FastArduino project</li>
</ul>
<p><b>Important condition</b>: in order to accept merging a PR to FastArduino, I must be able to check it by myself, hence I need to first have the new supported device available on my workbench; I will gladly buy one (or a few) if it is affordable and easy to find. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
