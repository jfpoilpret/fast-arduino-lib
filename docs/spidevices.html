<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>FastArduino: Adding support for an SPI device</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">FastArduino
   </div>
   <div id="projectbrief">C++ library to build fast but small Arduino/AVR projects</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('spidevices.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Adding support for an SPI device </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>There are plenty of devices of all kinds, based on SPI interface, that you may want to connect to your Arduino or a board you created with an AVR ATmega or ATtiny MCU.</p>
<p>If you want to learn more about SPI concepts and vocabulary, you can find further information on <a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface">Wikipedia</a>.</p>
<p>Unfortunately, FastArduino obviously cannot provide specific support for all existing SPI devices.</p>
<p>However, based on a given device datasheet, it can be quite easy to add a FastArduino driver for any SPI device.</p>
<p>FastArduino provides all the necessary classes and methods for you to implement such a specific driver.</p>
<p>The following sections describe the FastArduino API for SPI device driver implementation, and list the steps to successfully implement such a driver.</p>
<h2>FastArduino SPI driver API </h2>
<p>The generic support for SPI device driver in FastArduino is quite simple, it is entirely embedded in 2 classes: </p><div class="image">
<img src="classspi_1_1_s_p_i_device__inherit__graph.png" alt="classspi_1_1_s_p_i_device__inherit__graph.png"/>
</div>
 <p>The important class here is <code><a class="el" href="classspi_1_1_s_p_i_device.html" title="Base class for any SPI slave device.">spi::SPIDevice</a></code>, this is a template class (with many parameters discussed later) which all actual SPI device drivers shall derive from.</p>
<p>The abstract base class <code>AbstractSPIDevice</code> contains most methods used in transferring (both ways) content to/from a device on the SPI bus. It exists solely for the sake of code size: it factors all methods that do not depend on any <code><a class="el" href="classspi_1_1_s_p_i_device.html" title="Base class for any SPI slave device.">spi::SPIDevice</a></code> template parameter, into a non-template class so that generated code is not repeated for each device driver. All its important methods are available directly from <code><a class="el" href="classspi_1_1_s_p_i_device.html" title="Base class for any SPI slave device.">spi::SPIDevice</a></code> and its children, as <code>protected</code> methods.</p>
<p>As you can see in the following diagrams, the drivers for SPI devices currently supported by FastArduino directly derive from <code><a class="el" href="classspi_1_1_s_p_i_device.html" title="Base class for any SPI slave device.">spi::SPIDevice</a></code>, sometimes enforcing template parameter values:</p>
<ol type="1">
<li>Winbond SPI memory chip <div class="image">
<img src="classdevices_1_1_win_bond__inherit__graph.png" alt="classdevices_1_1_win_bond__inherit__graph.png"/>
</div>
 </li>
<li>NRF24L01 SPI Radio-Frequency transmitter/receiver <div class="image">
<img src="classdevices_1_1rf_1_1_n_r_f24_l01__inherit__graph.png" alt="classdevices_1_1rf_1_1_n_r_f24_l01__inherit__graph.png"/>
</div>
 </li>
</ol>
<p>Hence, creating a new driver for an SPI device is as simple as:</p><ol type="1">
<li>Creating a <code><a class="el" href="classspi_1_1_s_p_i_device.html" title="Base class for any SPI slave device.">spi::SPIDevice</a></code> subclass; let's call it <code>MySPIDevice</code> in the rest of this page.</li>
<li>Add proper <code>public</code> API on this <code>MySPIDevice</code> class, based on actual device features we want to use</li>
<li>Implement this API through the basic <code>protected</code> API methods inherited from <code><a class="el" href="classspi_1_1_s_p_i_device.html" title="Base class for any SPI slave device.">spi::SPIDevice</a></code></li>
</ol>
<h3>SPIDevice template parameters</h3>
<p>The <code><a class="el" href="classspi_1_1_s_p_i_device.html" title="Base class for any SPI slave device.">spi::SPIDevice</a></code> template class is instantiated through the following template parameters:</p><ul>
<li>CS: this <code><a class="el" href="namespaceboard.html#a5082846fef8fdfb8c8cbcf1163c7b404" title="Defines all available digital input/output pins of the target MCU.">board::DigitalPin</a></code> is the most important parameter of the template; it defines on which digital pin of the MCU the targeted device "chip select" pin shall be connected; in <code>MySPIDevice</code>, this shall remain a template parameter because you never know in advance how the device will be connected to the MCU across different projects.</li>
<li>CS_MODE: this parameter defines if the CS pin is active HIGH or LOW (the default); this is specific to every SPI device and shall be forced to the proper value in <code>MySPIDevice</code> class definition.</li>
<li>RATE: this parameter fixes the SPI clock frequency to the maximum value supported by the actual device. This is actually a divider of the MCU clock, used to provide the actual SPI frequency. Note that the proper selection for this template parameter depends on the maximum transfer rate supported by the target device and the MCU frequency used in your project.</li>
<li>MODE: one of the 4 SPI modes (as explained <a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface#Clock_polarity_and_phase">here</a> and <a href="https://en.wikipedia.org/wiki/Serial_Peripheral_Interface#Mode_numbers">there</a>); typically a given device supports exactly one mode, you should thus enforce the proper mode for your target device.</li>
<li>ORDER: this parameter defines the order in which bits of a byte are transferred: MSB (most significant bit) first, or LSB (least significant bit) first; typically a given device supports exactly one bit transfer order, you should thus enforce the proper order for your target device.</li>
</ul>
<h3>SPIDevice API</h3>
<p>Subclassing <code><a class="el" href="classspi_1_1_s_p_i_device.html" title="Base class for any SPI slave device.">spi::SPIDevice</a></code> gives <code>MySPIDevice</code> access to all low-level <code>protected</code> methods:</p><ul>
<li><code><a class="el" href="classspi_1_1_s_p_i_device.html#a4a6860cb1a7a09cc75a3b98abcb3dd0e" title="Start an SPI transfer to this device.">spi::SPIDevice.start_transfer()</a></code>: any SPI transfer to the slave SPI device must start with this call. Such a transfer must end by calling <code><a class="el" href="classspi_1_1_s_p_i_device.html#a7966a43f4b18fa308a637e28a5633722" title="End the current SPI ransfer tot hsi device.">spi::SPIDevice.end_transfer()</a></code>.</li>
<li><code><a class="el" href="classspi_1_1_abstract_s_p_i_device.html#a5439aabb817119e079f29a8eddfd3edc" title="Transfer one byte to the currently selected SPI slave device through MOSI pin, and get the byte retur...">spi::SPIDevice.transfer(uint8_t)</a></code>: send one byte to the slave SPI device and return the byte that was received during transmission (SPI is a full-duplex protocol where master and slave can send data at the same time).</li>
<li><code><a class="el" href="classspi_1_1_abstract_s_p_i_device.html#a63111d80e27d147a46e9654346a0b0b7" title="Transfer an array of payload data to the currently selected SPI slave device through MOSI pin,...">spi::SPIDevice.transfer(uint8_t*, uint16_t)</a></code>: send a packet of bytes to the slave SPI device, and receive all bytes simultaneously transmitted by that device.</li>
<li><code><a class="el" href="classspi_1_1_abstract_s_p_i_device.html#a19de463c2ae3e8e627012f42f9e54401" title="Transfer an array of payload data to the currently selected SPI slave device through MOSI pin; any da...">spi::SPIDevice.transfer(const uint8_t*, uint16_t)</a></code>: send a packet of bytes to the slave SPI device, but trash any bytes simultaneously transmitted by that device.</li>
<li><code><a class="el" href="classspi_1_1_s_p_i_device.html#a7966a43f4b18fa308a637e28a5633722" title="End the current SPI ransfer tot hsi device.">spi::SPIDevice.end_transfer()</a></code>: finish the current transfer to the slave SPI device, that was initiated with <code><a class="el" href="classspi_1_1_s_p_i_device.html#a4a6860cb1a7a09cc75a3b98abcb3dd0e" title="Start an SPI transfer to this device.">spi::SPIDevice.start_transfer()</a></code>.</li>
</ul>
<p>Any feature implementation in <code>MySPIDevice</code> will always consist in a sequence of calls to the methods above, like: </p><div class="fragment"><div class="line">this-&gt;start_transfer();</div><div class="line">this-&gt;transfer(0x01);</div><div class="line">uint8_t result1 = this-&gt;transfer(0x80);</div><div class="line">uint8_t result2 = this-&gt;transfer(0x00);</div><div class="line">this-&gt;end_transfer();</div></div><!-- fragment --><p>Most SPI devices use codes to perform various features, either write-only (sending values to the device) or read-only (asking the device for some values).</p>
<p>In the sections below, we will sometimes refer to a simple SPI device, the <a href="http://ww1.microchip.com/downloads/en/DeviceDoc/21295C.pdf">MCP3008</a>, an 8-channel Analog-Digital Converter, which communication protocol is super simple (because the number of features for such a chip is quite limited).</p>
<h2>Debugging support for a new device (low-level) </h2>
<p>In general, before developing a full-fledged driver for an SPI device, you need to learn how to use that device.</p>
<p>Based on the device datasheet, you first learn how to manipulate the device through the SPI bus.</p>
<p>For better understanding, you generally use a debugging example that helps demonstrate how the device works.</p>
<p>One easy way to develop such a debugging sample is to create a program with just one source code file containing:</p><ul>
<li>proper <code>#include</code> directives</li>
<li>a <code>PublicDevice</code> class that derives from <code><a class="el" href="classspi_1_1_s_p_i_device.html" title="Base class for any SPI slave device.">spi::SPIDevice</a></code> but declares <code>main()</code> as a <code>friend</code>, which allows direct calls, from <code>main()</code>, to <code>protected</code> API of <code><a class="el" href="classspi_1_1_s_p_i_device.html" title="Base class for any SPI slave device.">spi::SPIDevice</a></code>, for easy testing</li>
<li>directly call SPI API on a <code>PublicDevice</code> instance, from <code>main()</code> and trace results to a console, through UART</li>
</ul>
<p>FastArduino includes such a debugging sample in <code>examples/spi/SPIDeviceProto</code> example, copied hereafter:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="comment">//   Copyright 2016-2019 Jean-Francois Poilpret</span></div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;<span class="comment">//</span></div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;<span class="comment">//   Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span></div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;<span class="comment">//   you may not use this file except in compliance with the License.</span></div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;<span class="comment">//   You may obtain a copy of the License at</span></div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;<span class="comment">//</span></div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;<span class="comment">//       http://www.apache.org/licenses/LICENSE-2.0</span></div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;<span class="comment">//</span></div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;<span class="comment">//   Unless required by applicable law or agreed to in writing, software</span></div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;<span class="comment">//   distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span></div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;<span class="comment">//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;<span class="comment">//   See the License for the specific language governing permissions and</span></div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;<span class="comment">//   limitations under the License.</span></div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;<span class="comment">/*</span></div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;<span class="comment"> * This is a skeleton program to help connect, debug and understand how a given</span></div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;<span class="comment"> * SPI device (not already supported by FastArduino) works.</span></div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;<span class="comment"> * That helps creating a new specific support API for that device for reuse in </span></div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;<span class="comment"> * other programs and potential integration to FastArduino project.</span></div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;<span class="comment"> * To ease wiring and debugging, I suggest using a real Arduino UNO board</span></div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;<span class="comment"> * and a small breadboard for connecting the SPI device.</span></div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;<span class="comment"> * </span></div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;<span class="comment"> * This example shows how to start debugging support for MCP3008 chip, an </span></div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;<span class="comment"> * 8-channel Analog-Digital Converter, which communication protocol is super </span></div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;<span class="comment"> * simple (because the number of features for such a chip is quite limited).</span></div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;<span class="comment"> * In source code below, there are references to </span></div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;<span class="comment"> * [MCP3008 datasheet](http://ww1.microchip.com/downloads/en/DeviceDoc/21295C.pdf).</span></div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;<span class="comment"> * </span></div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;<span class="comment"> * Wiring:</span></div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;<span class="comment"> * - on ATmega328P based boards (including Arduino UNO):</span></div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;<span class="comment"> *   - D13 (SCK): connected to SPI device SCK pin</span></div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;<span class="comment"> *   - D12 (MISO): connected to SPI device MISO pin (sometimes called Dout)</span></div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;<span class="comment"> *   - D11 (MOSI): connected to SPI device MOSI pin (sometimes called Din)</span></div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;<span class="comment"> *   - D10 (SS): connected to SPI device CS pin</span></div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;<span class="comment"> *   - direct USB access (traces output)</span></div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;<span class="comment"> */</span></div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;</div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;<span class="preprocessor">#include &lt;<a class="code" href="spi_8h.html">fastarduino/spi.h</a>&gt;</span></div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;<span class="preprocessor">#include &lt;<a class="code" href="time_8h.html">fastarduino/time.h</a>&gt;</span></div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;<span class="preprocessor">#include &lt;<a class="code" href="uart_8h.html">fastarduino/uart.h</a>&gt;</span></div><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;<span class="preprocessor">#include &lt;<a class="code" href="utilities_8h.html">fastarduino/utilities.h</a>&gt;</span></div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;</div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;<span class="comment">// Define vectors we need in the example</span></div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;<a class="code" href="uart_8h.html#aa33c57bb6fa1e93177abb21fe8fecb10">REGISTER_UATX_ISR</a>(0)</div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;</div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;<span class="comment">// UART for traces</span></div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;static constexpr const uint8_t OUTPUT_BUFFER_SIZE = 64;</div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;static <span class="keywordtype">char</span> output_buffer[OUTPUT_BUFFER_SIZE];</div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;</div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;<span class="comment">// SPI Device specific stuff goes here</span></div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;<span class="comment">//=====================================</span></div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;</div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;<span class="comment">// Spec §1.0 (Clock frequency max 3.6MHz for Vdd=5V)</span></div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;static constexpr const uint32_t SPI_CLOCK = 3&#39;600&#39;000UL;</div><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;static constexpr const <a class="code" href="namespacespi.html">spi</a>::<a class="code" href="namespacespi.html#a4ef7145a7687905b0095d6a09b2bb12b">ChipSelect</a> CHIP_SELECT = <a class="code" href="namespacespi.html">spi</a>::<a class="code" href="namespacespi.html#a4ef7145a7687905b0095d6a09b2bb12b">ChipSelect</a>::ACTIVE_LOW;</div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;static constexpr const <a class="code" href="namespacespi.html">spi</a>::<a class="code" href="namespacespi.html#a671a4e4a182c39c4e72e9ff821d8bec7">DataOrder</a> DATA_ORDER = <a class="code" href="namespacespi.html">spi</a>::<a class="code" href="namespacespi.html#a671a4e4a182c39c4e72e9ff821d8bec7">DataOrder</a>::MSB_FIRST;</div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;static constexpr const <a class="code" href="namespacespi.html">spi</a>::<a class="code" href="namespacespi.html#afad82e7a839263bc0851445fdcced0bb">Mode</a> MODE = <a class="code" href="namespacespi.html">spi</a>::<a class="code" href="namespacespi.html#afad82e7a839263bc0851445fdcced0bb">Mode</a>::MODE_0;</div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;</div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;<span class="comment">// For testing we use default SS pin as CS</span></div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;static constexpr const <a class="code" href="namespaceboard.html">board</a>::<a class="code" href="namespaceboard.html#a5082846fef8fdfb8c8cbcf1163c7b404">DigitalPin</a> CS = <a class="code" href="namespaceboard.html">board</a>::<a class="code" href="namespaceboard.html#a5082846fef8fdfb8c8cbcf1163c7b404">DigitalPin</a>::D10_PB2;</div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;</div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;static constexpr const <a class="code" href="namespacespi.html">spi</a>::<a class="code" href="namespacespi.html#a030761907666e27c3a2236d68792a30b">ClockRate</a> CLOCK_RATE = <a class="code" href="namespacespi.html">spi</a>::<a class="code" href="namespacespi.html#a52df46fb17ceb1ad77644d145d3d3b59">compute_clockrate</a>(SPI_CLOCK);</div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;</div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;<span class="comment">// Subclass SPIDevice to make protected methods available from main()</span></div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;class PublicDevice: public <a class="code" href="namespacespi.html">spi</a>::SPIDevice&lt;CS, CHIP_SELECT, CLOCK_RATE, MODE, DATA_ORDER&gt;</div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;{</div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;<span class="keyword">public</span>:</div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;    PublicDevice(): SPIDevice() {}</div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;    <span class="keyword">friend</span> <span class="keywordtype">int</span> main();</div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;};</div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;</div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;<span class="keyword">using</span> <a class="code" href="namespacestreams.html#a25bd12279d518b57e4fb97c533c17b22">streams::endl</a>;</div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;<span class="keyword">using</span> <a class="code" href="namespacestreams.html#adaf650921b3a5d448f8aac51dba924d2">streams::dec</a>;</div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;<span class="keyword">using</span> <a class="code" href="namespacestreams.html#a91675bd61b31e7382e8655930606f62f">streams::hex</a>;</div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;</div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;<span class="keywordtype">int</span> main()</div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;{</div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;    <a class="code" href="namespaceboard.html#a2529f85498783a75dc75c281e0b754d3">board::init</a>();</div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;    sei();</div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;</div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;    <span class="comment">// Init UART output for traces</span></div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;    <a class="code" href="classserial_1_1hard_1_1_u_a_t_x.html">serial::hard::UATX&lt;board::USART::USART0&gt;</a> uart{output_buffer};</div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;    uart.<a class="code" href="classserial_1_1hard_1_1_u_a_t_x.html#a64b04d0617b28fd343a01f865dee787e">begin</a>(115200);</div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;    <a class="code" href="classstreams_1_1ostream.html">streams::ostream</a> out = uart.out();</div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;    out.<a class="code" href="classstreams_1_1ios__base.html#a46cf9813c05c34ff93d8ff19eff1ea9f">width</a>(2);</div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;    </div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;    <span class="comment">// Start SPI interface</span></div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;    <a class="code" href="namespacespi.html#a7829182c423612511a05fa0434d7673e">spi::init</a>();</div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;    out &lt;&lt; <a class="code" href="flash_8h.html#a16c40764aaba0de309f5ff429c8bac15">F</a>(<span class="stringliteral">&quot;SPI initialized&quot;</span>) &lt;&lt; <a class="code" href="namespacestreams.html#a25bd12279d518b57e4fb97c533c17b22">endl</a>;</div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;    </div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;    PublicDevice device;</div><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;    </div><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;    <span class="comment">// Start or init SPI device if needed</span></div><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;    </div><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;    <span class="comment">// Loop to read and show measures</span></div><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;    <span class="keywordflow">while</span> (<span class="keyword">true</span>)</div><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;    {</div><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;        <span class="comment">// Read measures and display them to UART</span></div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;</div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;        <span class="comment">// On MCP3008 we will perform single-ended analog-digital conversion on channel CH0</span></div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;        out &lt;&lt; <a class="code" href="flash_8h.html#a16c40764aaba0de309f5ff429c8bac15">F</a>(<span class="stringliteral">&quot;Reading channel 0&quot;</span>) &lt;&lt; <a class="code" href="namespacestreams.html#a25bd12279d518b57e4fb97c533c17b22">endl</a>;</div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;        <span class="comment">// Spec §5.0</span></div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;        device.start_transfer();</div><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;        <span class="comment">// Spec §6.1, figure 6.1: send a start bit as a byte (left filled with 0s)</span></div><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;        device.transfer(0x01);</div><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;        <span class="comment">// Spec §6.1, figure 6.1: send 4 command bits as a byte (right filled with 0s), and capture result (2 MSB)</span></div><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;        <span class="comment">// Command bits are 1000 (single-ended input mode, channel CH0)</span></div><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;        uint8_t result1 = device.transfer(0x80);</div><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;        <span class="comment">// Spec §6.1, figure 6.1: send an empty byte to capture returned result (8 LSB)</span></div><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;        uint8_t result2 = device.transfer(0x00);</div><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;        device.end_transfer();</div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;</div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;        <span class="comment">// Trace intermediate results (for debugging)</span></div><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;        out &lt;&lt; <a class="code" href="flash_8h.html#a16c40764aaba0de309f5ff429c8bac15">F</a>(<span class="stringliteral">&quot;Intermediate results:&quot;</span>) &lt;&lt; <a class="code" href="namespacestreams.html#a91675bd61b31e7382e8655930606f62f">hex</a> &lt;&lt; result1 &lt;&lt; <span class="charliteral">&#39; &#39;</span> &lt;&lt; result2 &lt;&lt; <a class="code" href="namespacestreams.html#a25bd12279d518b57e4fb97c533c17b22">endl</a>;</div><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;        <span class="comment">// Combine result</span></div><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;        uint16_t value =  <a class="code" href="namespaceutils.html#a9d48a47fd601d3b960ce55b26a4d5194">utils::as_uint16_t</a>(result1 &amp; 0x03, result2);</div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;        out &lt;&lt; <a class="code" href="flash_8h.html#a16c40764aaba0de309f5ff429c8bac15">F</a>(<span class="stringliteral">&quot;Calculated value: &quot;</span>) &lt;&lt; <a class="code" href="namespacestreams.html#adaf650921b3a5d448f8aac51dba924d2">dec</a> &lt;&lt; value &lt;&lt; <a class="code" href="namespacestreams.html#a25bd12279d518b57e4fb97c533c17b22">endl</a>;</div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;</div><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;        <a class="code" href="namespacetime.html#af13fd17ddf6b751b8161691e608892b2">time::delay_ms</a>(1000);</div><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;    }</div><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;    </div><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;    <span class="comment">// Stop SPI device if needed</span></div><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;    out &lt;&lt; <a class="code" href="flash_8h.html#a16c40764aaba0de309f5ff429c8bac15">F</a>(<span class="stringliteral">&quot;End&quot;</span>) &lt;&lt; <a class="code" href="namespacestreams.html#a25bd12279d518b57e4fb97c533c17b22">endl</a>;</div><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;}</div><div class="ttc" id="namespacetime_html_af13fd17ddf6b751b8161691e608892b2"><div class="ttname"><a href="namespacetime.html#af13fd17ddf6b751b8161691e608892b2">time::delay_ms</a></div><div class="ttdeci">void delay_ms(uint16_t ms) INLINE</div><div class="ttdoc">Delay program execution for the given amount of milliseconds.</div><div class="ttdef"><b>Definition:</b> <a href="time_8h_source.html#l00346">time.h:346</a></div></div>
<div class="ttc" id="uart_8h_html"><div class="ttname"><a href="uart_8h.html">uart.h</a></div><div class="ttdoc">Hardware serial API.</div></div>
<div class="ttc" id="classstreams_1_1ostream_html"><div class="ttname"><a href="classstreams_1_1ostream.html">streams::ostream</a></div><div class="ttdoc">Output stream wrapper to provide formatted output API, a la C++.</div><div class="ttdef"><b>Definition:</b> <a href="streams_8h_source.html#l00060">streams.h:60</a></div></div>
<div class="ttc" id="classstreams_1_1ios__base_html_a46cf9813c05c34ff93d8ff19eff1ea9f"><div class="ttname"><a href="classstreams_1_1ios__base.html#a46cf9813c05c34ff93d8ff19eff1ea9f">streams::ios_base::width</a></div><div class="ttdeci">void width(uint8_t width)</div><div class="ttdoc">Set minimum width used for displaying values.</div><div class="ttdef"><b>Definition:</b> <a href="ios_8h_source.html#l00390">ios.h:390</a></div></div>
<div class="ttc" id="utilities_8h_html"><div class="ttname"><a href="utilities_8h.html">utilities.h</a></div><div class="ttdoc">General utilities API that have broad application in programs.</div></div>
<div class="ttc" id="time_8h_html"><div class="ttname"><a href="time_8h.html">time.h</a></div><div class="ttdoc">Simple time utilities.</div></div>
<div class="ttc" id="namespaceboard_html_a2529f85498783a75dc75c281e0b754d3"><div class="ttname"><a href="namespaceboard.html#a2529f85498783a75dc75c281e0b754d3">board::init</a></div><div class="ttdeci">static void init()</div><div class="ttdoc">Performs special initialization for the target MCU.</div><div class="ttdef"><b>Definition:</b> <a href="empty_8h_source.html#l00043">empty.h:43</a></div></div>
<div class="ttc" id="namespaceboard_html_a5082846fef8fdfb8c8cbcf1163c7b404"><div class="ttname"><a href="namespaceboard.html#a5082846fef8fdfb8c8cbcf1163c7b404">board::DigitalPin</a></div><div class="ttdeci">DigitalPin</div><div class="ttdoc">Defines all available digital input/output pins of the target MCU.</div><div class="ttdef"><b>Definition:</b> <a href="empty_8h_source.html#l00055">empty.h:55</a></div></div>
<div class="ttc" id="namespacestreams_html_a91675bd61b31e7382e8655930606f62f"><div class="ttname"><a href="namespacestreams.html#a91675bd61b31e7382e8655930606f62f">streams::hex</a></div><div class="ttdeci">void hex(FSTREAM &amp;stream)</div><div class="ttdoc">Manipulator for an output or input stream, which will set the base, used to represent (output) or int...</div><div class="ttdef"><b>Definition:</b> <a href="ios_8h_source.html#l00774">ios.h:774</a></div></div>
<div class="ttc" id="namespacespi_html"><div class="ttname"><a href="namespacespi.html">spi</a></div><div class="ttdoc">Define API to define and manage SPI devices.</div><div class="ttdef"><b>Definition:</b> <a href="spi_8h_source.html#l00035">spi.h:35</a></div></div>
<div class="ttc" id="spi_8h_html"><div class="ttname"><a href="spi_8h.html">spi.h</a></div><div class="ttdoc">SPI support for AVR MCU.</div></div>
<div class="ttc" id="namespacespi_html_a671a4e4a182c39c4e72e9ff821d8bec7"><div class="ttname"><a href="namespacespi.html#a671a4e4a182c39c4e72e9ff821d8bec7">spi::DataOrder</a></div><div class="ttdeci">DataOrder</div><div class="ttdoc">Bit ordering per byte.</div><div class="ttdef"><b>Definition:</b> <a href="spi_8h_source.html#l00088">spi.h:88</a></div></div>
<div class="ttc" id="namespacestreams_html_adaf650921b3a5d448f8aac51dba924d2"><div class="ttname"><a href="namespacestreams.html#adaf650921b3a5d448f8aac51dba924d2">streams::dec</a></div><div class="ttdeci">void dec(FSTREAM &amp;stream)</div><div class="ttdoc">Manipulator for an output or input stream, which will set the base, used to represent (output) or int...</div><div class="ttdef"><b>Definition:</b> <a href="ios_8h_source.html#l00765">ios.h:765</a></div></div>
<div class="ttc" id="namespaceutils_html_a9d48a47fd601d3b960ce55b26a4d5194"><div class="ttname"><a href="namespaceutils.html#a9d48a47fd601d3b960ce55b26a4d5194">utils::as_uint16_t</a></div><div class="ttdeci">constexpr uint16_t as_uint16_t(uint8_t high, uint8_t low)</div><div class="ttdoc">Convert 2 bytes into an unsigned int.</div><div class="ttdef"><b>Definition:</b> <a href="utilities_8h_source.html#l00304">utilities.h:304</a></div></div>
<div class="ttc" id="namespacestreams_html_a25bd12279d518b57e4fb97c533c17b22"><div class="ttname"><a href="namespacestreams.html#a25bd12279d518b57e4fb97c533c17b22">streams::endl</a></div><div class="ttdeci">void endl(FSTREAM &amp;stream)</div><div class="ttdoc">Manipulator for an output stream, which will insert a new-line character and flush the stream buffer.</div><div class="ttdef"><b>Definition:</b> <a href="streams_8h_source.html#l00722">streams.h:722</a></div></div>
<div class="ttc" id="namespaceboard_html"><div class="ttname"><a href="namespaceboard.html">board</a></div><div class="ttdoc">Defines all types and constants specific to support a specific MCU target.</div><div class="ttdef"><b>Definition:</b> <a href="empty_8h_source.html#l00037">empty.h:37</a></div></div>
<div class="ttc" id="classserial_1_1hard_1_1_u_a_t_x_html_a64b04d0617b28fd343a01f865dee787e"><div class="ttname"><a href="classserial_1_1hard_1_1_u_a_t_x.html#a64b04d0617b28fd343a01f865dee787e">serial::hard::UATX::begin</a></div><div class="ttdeci">void begin(uint32_t rate, Parity parity=Parity::NONE, StopBits stop_bits=StopBits::ONE)</div><div class="ttdoc">Enable the transmitter.</div><div class="ttdef"><b>Definition:</b> <a href="uart_8h_source.html#l00267">uart.h:267</a></div></div>
<div class="ttc" id="namespacespi_html_afad82e7a839263bc0851445fdcced0bb"><div class="ttname"><a href="namespacespi.html#afad82e7a839263bc0851445fdcced0bb">spi::Mode</a></div><div class="ttdeci">Mode</div><div class="ttdoc">SPI transmission mode.</div><div class="ttdef"><b>Definition:</b> <a href="spi_8h_source.html#l00110">spi.h:110</a></div></div>
<div class="ttc" id="flash_8h_html_a16c40764aaba0de309f5ff429c8bac15"><div class="ttname"><a href="flash_8h.html#a16c40764aaba0de309f5ff429c8bac15">F</a></div><div class="ttdeci">#define F(ptr)</div><div class="ttdoc">Force string constant to be stored as flash storage.</div><div class="ttdef"><b>Definition:</b> <a href="flash_8h_source.html#l00098">flash.h:98</a></div></div>
<div class="ttc" id="namespacespi_html_a7829182c423612511a05fa0434d7673e"><div class="ttname"><a href="namespacespi.html#a7829182c423612511a05fa0434d7673e">spi::init</a></div><div class="ttdeci">void init()</div><div class="ttdoc">This function must be called once in your program, before any use of an SPI device.</div><div class="ttdef"><b>Definition:</b> <a href="spi_8cpp_source.html#l00020">spi.cpp:20</a></div></div>
<div class="ttc" id="namespacespi_html_a4ef7145a7687905b0095d6a09b2bb12b"><div class="ttname"><a href="namespacespi.html#a4ef7145a7687905b0095d6a09b2bb12b">spi::ChipSelect</a></div><div class="ttdeci">ChipSelect</div><div class="ttdoc">Active polarity of slave selection pin.</div><div class="ttdef"><b>Definition:</b> <a href="spi_8h_source.html#l00138">spi.h:138</a></div></div>
<div class="ttc" id="classserial_1_1hard_1_1_u_a_t_x_html"><div class="ttname"><a href="classserial_1_1hard_1_1_u_a_t_x.html">serial::hard::UATX</a></div><div class="ttdoc">Hardware serial transmitter API.</div><div class="ttdef"><b>Definition:</b> <a href="uart_8h_source.html#l00232">uart.h:232</a></div></div>
<div class="ttc" id="uart_8h_html_aa33c57bb6fa1e93177abb21fe8fecb10"><div class="ttname"><a href="uart_8h.html#aa33c57bb6fa1e93177abb21fe8fecb10">REGISTER_UATX_ISR</a></div><div class="ttdeci">#define REGISTER_UATX_ISR(UART_NUM)</div><div class="ttdoc">Register the necessary ISR (Interrupt Service Routine) for an serial::hard::UATX to work correctly.</div><div class="ttdef"><b>Definition:</b> <a href="uart_8h_source.html#l00037">uart.h:37</a></div></div>
<div class="ttc" id="namespacespi_html_a52df46fb17ceb1ad77644d145d3d3b59"><div class="ttname"><a href="namespacespi.html#a52df46fb17ceb1ad77644d145d3d3b59">spi::compute_clockrate</a></div><div class="ttdeci">constexpr ClockRate compute_clockrate(uint32_t frequency)</div><div class="ttdoc">Calculate ClockRate for the given frequency.</div><div class="ttdef"><b>Definition:</b> <a href="spi_8h_source.html#l00066">spi.h:66</a></div></div>
<div class="ttc" id="namespacespi_html_a030761907666e27c3a2236d68792a30b"><div class="ttname"><a href="namespacespi.html#a030761907666e27c3a2236d68792a30b">spi::ClockRate</a></div><div class="ttdeci">ClockRate</div><div class="ttdoc">Define SPI clock rate as a divider of MCU clock frequency.</div><div class="ttdef"><b>Definition:</b> <a href="spi_8h_source.html#l00048">spi.h:48</a></div></div>
</div><!-- fragment --><p>This example demonstrates how to simply test the MCP3008 ADC chip. It is made of several parts:</p>
 </p><div class="fragment"><div class="line">#include &lt;fastarduino/spi.h&gt;</div><div class="line">#include &lt;fastarduino/time.h&gt;</div><div class="line">#include &lt;fastarduino/uart.h&gt;</div><div class="line">#include &lt;fastarduino/utilities.h&gt;</div></div><!-- fragment --><p> Those lines include a few headers necessary (or just useful) to debug an SPI device.</p>
<div class="fragment"><div class="line">REGISTER_UATX_ISR(0)</div><div class="line"></div><div class="line">// UART for traces</div><div class="line">static constexpr const uint8_t OUTPUT_BUFFER_SIZE = 64;</div><div class="line">static char output_buffer[OUTPUT_BUFFER_SIZE];</div></div><!-- fragment --><p> Then a buffer is defined for tracing through UART and the necessary UART ISR is registered.</p>
<div class="fragment"><div class="line">// Spec §1.0 (Clock frequency max 3.6MHz for Vdd=5V)</div><div class="line">static constexpr const uint32_t SPI_CLOCK = 3&#39;600&#39;000UL;</div><div class="line">static constexpr const spi::ChipSelect CHIP_SELECT = spi::ChipSelect::ACTIVE_LOW;</div><div class="line">static constexpr const spi::DataOrder DATA_ORDER = spi::DataOrder::MSB_FIRST;</div><div class="line">static constexpr const spi::Mode MODE = spi::Mode::MODE_0;</div></div><!-- fragment --><p> Any specificity of the tested SPI device is defined as a constant in the next code section. These constants will be used for template parameters later on.</p>
<div class="fragment"><div class="line">static constexpr const board::DigitalPin CS = board::DigitalPin::D10_PB2;</div><div class="line"></div><div class="line">static constexpr const spi::ClockRate CLOCK_RATE = spi::compute_clockrate(SPI_CLOCK);</div></div><!-- fragment --><p> Here we set the UNO pin to be connected to the CS pin of the tested SPI device, then we define the proper SPI clock rate for this device, based on CPU frequency and device maximum SPI frequency.</p>
<div class="fragment"><div class="line">class PublicDevice: public spi::SPIDevice&lt;CS, CHIP_SELECT, CLOCK_RATE, MODE, DATA_ORDER&gt;</div><div class="line">{</div><div class="line">public:</div><div class="line">    PublicDevice(): SPIDevice() {}</div><div class="line">    friend int main();</div><div class="line">};</div></div><!-- fragment --><p> This is where we define a utility class to debug our SPI interface to the tested device. <code>PublicDevice</code> class does <b>nothing</b> but making all protected methods callable from <code>main()</code>, so that we can directly perform our code tests in <code>main()</code>, without thinking much about proper API design now.</p>
<div class="fragment"><div class="line">int main()</div><div class="line">{</div><div class="line">    board::init();</div><div class="line">    sei();</div><div class="line"></div><div class="line">    // Init UART output for traces</div><div class="line">    serial::hard::UATX&lt;board::USART::USART0&gt; uart{output_buffer};</div><div class="line">    uart.begin(115200);</div><div class="line">    streams::ostream out = uart.out();</div><div class="line">    out.width(2);</div></div><!-- fragment --><p> This is the <code>main()</code> function where it all happens. First we initialize the MCU and the UART for tracing.</p>
<div class="fragment"><div class="line">    spi::init();</div></div><!-- fragment --><p> Here we simply initialize SPI function on the UNO.</p>
<div class="fragment"><div class="line">    PublicDevice device;</div></div><!-- fragment --><p> We then declare the <code>device</code> variable that we will use for testing our SPI device.</p>
<p>Then we start an infinite loop that will read data from the SPI device and trace it: </p><div class="fragment"><div class="line">        // On MCP3008 we will perform single-ended analog-digital conversion on channel CH0</div><div class="line">        out &lt;&lt; F(&quot;Reading channel 0&quot;) &lt;&lt; endl;</div><div class="line">        // Spec §5.0</div><div class="line">        device.start_transfer();</div><div class="line">        // Spec §6.1, figure 6.1: send a start bit as a byte (left filled with 0s)</div><div class="line">        device.transfer(0x01);</div><div class="line">        // Spec §6.1, figure 6.1: send 4 command bits as a byte (right filled with 0s), and capture result (2 MSB)</div><div class="line">        // Command bits are 1000 (single-ended input mode, channel CH0)</div><div class="line">        uint8_t result1 = device.transfer(0x80);</div><div class="line">        // Spec §6.1, figure 6.1: send an empty byte to capture returned result (8 LSB)</div><div class="line">        uint8_t result2 = device.transfer(0x00);</div><div class="line">        device.end_transfer();</div><div class="line"></div><div class="line">        // Trace intermediate results (for debugging)</div><div class="line">        out &lt;&lt; F(&quot;Intermediate results:&quot;) &lt;&lt; hex &lt;&lt; result1 &lt;&lt; &#39; &#39; &lt;&lt; result2 &lt;&lt; endl;</div></div><!-- fragment --><p> In this code snippet, <code>result1</code> and <code>result2</code> each contain a part of the expected result (analog channel read on MCP3008), these must be used to calculate the actual value (based on the datasheet): </p><div class="fragment"><div class="line">        uint16_t value =  utils::as_uint16_t(result1 &amp; 0x03, result2);</div><div class="line">        out &lt;&lt; F(&quot;Calculated value: &quot;) &lt;&lt; dec &lt;&lt; value &lt;&lt; endl;</div></div><!-- fragment --><h2>Defining the driver API based on device features </h2>
<p>At this level, you have already been able to debug how the device works and you have a good overview of what features you want to provide to developers (and to yourself as the first of all) who will want to use this device.</p>
<p>An easy way is to provide an API that maps every feature found in the datasheet to its dedicated method. This is what we would call a low-level API; that is the minimum your driver should provide.</p>
<p>Additionally <code>MySPIDevice</code> might implement a higher level API, based on the low-level one, but this is not mandatory; actually, this is not even advised generally, as this high-level API might be implemented in a distinct class. Using a separate class for high-level API allows other developers to develop their own high-level API without having to use yours if it does not fit their needs.</p>
<p>It is often advised to add <code>begin()</code> and <code>end()</code> methods to <code>MySPIDevice</code> when it makes sense. <code>begin()</code> would initialize the device before usage (most devices will require special setup before use).</p>
<p>In the MCP3008 example, the API could be rather simple; for instance, we could:</p><ul>
<li>define an <code>enum</code> for the selection of channel to read (including single-ended Vs. differential input modes)</li>
<li>define a template class <code>MCP3008Device</code> as device driver keeping only <code>CS</code> as template parameter</li>
<li>add only one API method <code>uint16_t read_channel()</code></li>
</ul>
<h2>Implementing the driver API </h2>
<p>We proceed with the MCP3008 example. When implementing the API, you must scrupulously follow the device datasheet for every method!</p>
<p>Here is a simple implementation attempt for MCP3008 driver:</p>
<div class="fragment"><div class="line"><span class="keyword">enum class</span> <a class="code" href="mcp3008_8h.html#a9ac959352f715c81ecc2a4d2c991b99c">MCP3008Channel</a> : uint8_t</div><div class="line">{</div><div class="line">    <span class="comment">// singled-ended input</span></div><div class="line">    CH0 = 0x80,</div><div class="line">    CH1 = 0x90,</div><div class="line">    CH2 = 0xA0,</div><div class="line">    CH3 = 0xB0,</div><div class="line">    CH4 = 0xC0,</div><div class="line">    CH5 = 0xD0,</div><div class="line">    CH6 = 0xE0,</div><div class="line">    CH7 = 0xF0,</div><div class="line">    <span class="comment">// differential input</span></div><div class="line">    CH0_CH1 = 0x00,</div><div class="line">    CH1_CH0 = 0x10,</div><div class="line">    CH2_CH3 = 0x20,</div><div class="line">    CH3_CH2 = 0x30,</div><div class="line">    CH4_CH5 = 0x40,</div><div class="line">    CH5_CH4 = 0x50,</div><div class="line">    CH6_CH7 = 0x60,</div><div class="line">    CH7_CH6 = 0x70</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacespi.html">spi</a>;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;board::DigitalPin CS&gt;</div><div class="line"><span class="keyword">class </span>MCP3008Device : <span class="keyword">public</span> <a class="code" href="classspi_1_1_s_p_i_device.html">SPIDevice</a>&lt;CS, ChipSelect::ACTIVE_LOW, compute_clockrate(3600000UL), Mode::MODE_0, DataOrder::MSB_FIRST&gt;</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    MCP3008Device() = <span class="keywordflow">default</span>;</div><div class="line"></div><div class="line">    uint16_t read_channel(MCP3008Channel channel)</div><div class="line">    {</div><div class="line">        this-&gt;start_transfer();</div><div class="line">        this-&gt;transfer(0x01);</div><div class="line">        uint8_t result1 = this-&gt;transfer(uint8_t(channel));</div><div class="line">        uint8_t result2 = this-&gt;transfer(0x00);</div><div class="line">        this-&gt;end_transfer();</div><div class="line">        <span class="keywordflow">return</span> <a class="code" href="namespaceutils.html#a9d48a47fd601d3b960ce55b26a4d5194">utils::as_uint16_t</a>(result1 &amp; 0x03, result2);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>Note the implementation of <code>read_channel()</code> which is mainly the same as in the debugging example described earlier.</p>
<p>Of course, the MCP3008 is a very simple device which is easy to interact with through SPI, but there are many SPI devices with more complex capabilities (cameras, B&amp;W and color display controllers, RF transmitters...) For those devices, the number of features can be large and this would result in dozens or even hundreds of API methods!</p>
<h2>Support for ATtiny MCU </h2>
<p>ATtiny MCU provides some support (through its USI feature) for SPI but it is quite limited in comparison to ATmega devices; hence FastArduino SPI support for ATtiny chips has similar limitations:</p>
<ol type="1">
<li>The only <code><a class="el" href="namespacespi.html#a671a4e4a182c39c4e72e9ff821d8bec7" title="Bit ordering per byte.">spi::DataOrder</a></code> supported is <code><a class="el" href="namespacespi.html#a671a4e4a182c39c4e72e9ff821d8bec7a89488e0251a0b2be79602890ef16ddb3" title="Most significant bit transferred first.">spi::DataOrder::MSB_FIRST</a></code></li>
<li>The only <code><a class="el" href="namespacespi.html#afad82e7a839263bc0851445fdcced0bb" title="SPI transmission mode.">spi::Mode</a></code>s supported are <code><a class="el" href="namespacespi.html#afad82e7a839263bc0851445fdcced0bba3a769a916836dccf98801212615595d3" title="SPI mode 0: CPOL = 0 and CPHA = 0.">spi::Mode::MODE_0</a></code> and <code><a class="el" href="namespacespi.html#afad82e7a839263bc0851445fdcced0bbaf7ede748a6b41c7c91c18ed2d155b33e" title="SPI mode 1: CPOL = 0 and CPHA = 1.">spi::Mode::MODE_1</a></code></li>
<li><code><a class="el" href="namespacespi.html#a030761907666e27c3a2236d68792a30b" title="Define SPI clock rate as a divider of MCU clock frequency.">spi::ClockRate</a></code> parameter is not used in <code><a class="el" href="classspi_1_1_s_p_i_device.html" title="Base class for any SPI slave device.">spi::SPIDevice</a></code> implementation, hence the maximum clock rate is always used, and is roughly equal to <code>CPU frequency / 7</code>, hence typically a bit more than 1MHz with common clock frequency used in ATtiny boards (internal 8MHz RC clock); this might be a problem for devices supporting only 1MHz SPI.</li>
</ol>
<p>These limitations might prevent proper support, on ATtiny MCU, of some SPI devices.</p>
<p>If your device is in this situation, then you should add compile error checks (through <code>static_assert()</code>, or <code>#if</code> and <code>#error</code>) in your SPI device driver header file, so that it cannot compile for these unsupported ATtiny targets.</p>
<h2>The last mile: add driver to FastArduino project! </h2>
<p>Bravo! You successfully added FastArduino support, in your own project, for a specific SPI device!</p>
<p>The last mile would now consist in adding your valuable work to FastArduino library! You do not <em>have to</em>, of course, but this would be a good way to:</p><ul>
<li>thank other people who provided FastArduino open source library to you</li>
<li>feel part of the community</li>
<li>get feedback on your work, potentially allowing it to be further improved</li>
<li>share your work with the rest of the world</li>
</ul>
<p>However, like for a marathon, the last mile can be difficult! In order to run this last mile, you will have to:</p><ul>
<li>first accept FastArduino Apache License 2.0 for your contribution, or discuss with FastArduino owner for another one, if compatible</li>
<li>follow FastArduino coding guidelines: this might impose some code rewrite or reformatting</li>
<li>add API documentation with doxygen: this is mandatory for all <code>public</code> methods, and advised for <code>protected</code> ones.</li>
<li>add one (or more) usage example and integrate it in the <code>examples/spi</code> directory; examples must be kept simple but still demonstrate the API usage; example circuits (connection pins) shall be described. These examples can be further used as "tests" before new releases of FastArduino.</li>
<li>optionally develop a tutorial for this device</li>
<li>prepare and propose a PR to FastArduino project</li>
</ul>
<p><b>Important condition</b>: in order to accept merging a PR to FastArduino, I must be able to check it by myself, hence I need to first have the new supported device available on my workbench; I will gladly buy one (or a few) if it is affordable and easy to find. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.15 </li>
  </ul>
</div>
</body>
</html>
