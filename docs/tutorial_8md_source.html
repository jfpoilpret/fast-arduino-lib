<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>FastArduino: /home/jfpoilpret/electronics/fast-arduino-lib/dox/tutorial.md Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">FastArduino
   </div>
   <div id="projectbrief">C++ library to build fast but small Arduino/AVR projects</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('tutorial_8md.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">/home/jfpoilpret/electronics/fast-arduino-lib/dox/tutorial.md</div>  </div>
</div><!--header-->
<div class="contents">
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;FastArduino API Tutorial   {#tutorial}</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;========================</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;This is FastArduino API step-by-step tutorial.</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;Only the API is covered here: creating and building a project is not described here, you are supposed to know how to do it already.</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;Using FastArduino API can be learnt step by step in the preferred following order:</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;Basics:</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;1. [gpio &amp; time](@ref gpiotime)</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;2. [UART &amp; flash](@ref uartflash)</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;3. [analog input](@ref analoginput)</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;4. [timer](@ref timer)</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;5. real-time timer</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;6. PWM</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;7. utilities</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;Advanced:</div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;1. watchdog</div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;2. interrupts</div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;3. events, scheduler</div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;4. power</div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;5. SPI devices management</div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;6. I2C devices management</div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;7. eeprom</div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;8. Software UART</div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;</div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;Devices:</div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;1. SPI</div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;2. I2C</div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;3. Other devices: sonar, servo, SIPO</div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;</div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;</div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;@anchor gpiotime Basics: gpio &amp; time</div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;------------------------------------</div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;</div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;### Blink example ###</div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;</div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;Here is a first example of a FastArduino based program:</div><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.cpp}</div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;#include &lt;fastarduino/gpio.h&gt;</div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;#include &lt;fastarduino/time.h&gt;</div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;</div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;int main()</div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;{</div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;    board::init();</div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;    sei();</div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;</div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;    gpio::FastPinType&lt;board::DigitalPin::LED&gt;::TYPE led{gpio::PinMode::OUTPUT};</div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;    while (true)</div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;    {</div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;        led.toggle();</div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;        time::delay_ms(500);</div><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;    }</div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;    return 0;</div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;}</div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;</div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;This example can be broken down into several parts:</div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.cpp}</div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;#include &lt;fastarduino/gpio.h&gt;</div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;#include &lt;fastarduino/time.h&gt;</div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;This includes the necessary API from FastArduino; in this example, we just use `gpio.h` (all API for digital input/output) and `time.h` (API for busy loop delays).</div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;</div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.cpp}</div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;int main()</div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;{</div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;    board::init();</div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;    sei();</div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;The next part defines the standard `main()` function as the entry point of the program; first actions in the `main()` should always be to call `board::init()` (important initialization for some specific boards), then sooner or later call `sei()` to enable interrupts again, as interrupts are disabled when `main()` is initially called.</div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;</div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.cpp}</div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;    gpio::FastPinType&lt;board::DigitalPin::LED&gt;::TYPE led{gpio::PinMode::OUTPUT};</div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;This line declares and initializes a digital pin variable named `led` as output for the board&#39;s LED (i.e. `D13` on Arduino boards).</div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;</div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;`board::DigitalPin` is a strong enum class that defines all digital pins **for the current target**, that target must be defined in the compiler command-line.</div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;</div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;The actual type of `led` is `gpio::FastPin&lt;board::Port:PORT_B, 5&gt;` which means &quot;the pin number 5 within port B&quot;; since this type is not easy to declare when you only know the number of the pin you need, `gpio::FastPinType&lt;board::DigitalPin::LED&gt;::TYPE` is used instead, as it maps directly to the right type.</div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;</div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;`led` is initialized as an output pin, its initial level is `false` (i.e. GND) by default.</div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;</div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.cpp}</div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;    while (true)</div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;    {</div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;        led.toggle();</div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;        time::delay_ms(500);</div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;    }</div><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</div><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;Then the program enters an endless loop in which, at every iteration:</div><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;</div><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;1. It toggles the level of `led` pin (D13 on Arduino) from GND to Vcc or from Vcc to GND</div><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;2. It delays execution (i.e. it &quot;waits&quot;) for 500 milliseconds</div><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;</div><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;This part of the program simply makes your Arduino LED blink at 1Hz frequency!</div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;</div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;The last part below is never executed (because of the endless loop above) but is necessary to make the compiler happy, as `main()` shall return a value:</div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.cpp}</div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;    return 0;</div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;}</div><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</div><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;</div><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;Congratulation! We have just studied the typical &quot;blink&quot; program.</div><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;</div><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;At this point, it is interesting to compare our first program with the equivalent with standard Arduino API:</div><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.cpp}</div><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;void setup()</div><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;{</div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;    pinMode(LED_BUILTIN, OUTPUT);</div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;}</div><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;</div><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;void loop()</div><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;{</div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;    digitalWrite(LED_BUILTIN, HIGH);</div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;    delay(1000);</div><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;    digitalWrite(LED_BUILTIN, LOW);</div><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;    delay(1000);</div><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;}</div><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</div><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;Granted that the latter code seems simpler to write! However, it is also simpler to write it wrong, build and upload it to Arduino and only see it not working:</div><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.cpp}</div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;#define LED 53</div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;void setup()</div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;{</div><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;    pinMode(LED, OUTPUT);</div><div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;}</div><div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;</div><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;void loop()</div><div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;{</div><div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;    digitalWrite(LED, HIGH);</div><div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;    delay(500);</div><div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;    digitalWrite(LED, LOW);</div><div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;    delay(500);</div><div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;}</div><div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</div><div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;The problem here is that Arduino API accept a simple number when they need a pin, hence it is perfectly possible to pass them the number of a pin that does not exist, as in the faulty code above: this code will compile and upload properly to an Arduino UNO, however it will not work, because pin 53 does not exist!</div><div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;</div><div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;This problem cannot occur with FastArduino as the available pins are stored in a strong enum and it becomes impossible to select a pin that does not exist for the board we target!</div><div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;</div><div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;Now, what is really interesting in comparing both working code examples is the size of the built program (measured with UNO as a target, FastArduino project built with AVR Toolchain 3.5.3, Arduino API project built with Arduino IDE 1.8.2):</div><div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;|           | Arduino API | FastArduino |</div><div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;|-----------|-------------|-------------|</div><div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;| code size | 928 bytes   | 154 bytes   |</div><div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;| data size | 9 bytes     | 0 byte      |</div><div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;</div><div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;As you probably know, Atmel AVR MCU (and Arduino boards that embed them) are much constrained in code and data size, hence we could say that &quot;every byte counts&quot;. In the table ablove, one easily sees that Arduino API comes cluttered with lots of code and data, even if you don&#39;t need it; on the other hand, FastArduino is highly optimized and will produce code only for what you **do** use.</div><div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;</div><div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;### LED Chaser example ###</div><div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;</div><div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;Now `gpio.h` has more API than just `gpio::FastPin` and `gpio::FastPinType`; it also includes `gpio::FastPort` and `gpio::FastMaskedPort` that allow to manipulate several pins at a time, as long as these pis belong to the same Port of the MCU. This allows size and speed optimizations when having to deal with a group of related pins, e.g. if you want to implement a LED chaser project.</div><div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;</div><div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;With FastArduino, here is a program showing how you could implement a simple 8 LED chaser on UNO:</div><div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.cpp}</div><div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;#include &lt;fastarduino/gpio.h&gt;</div><div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;#include &lt;fastarduino/time.h&gt;</div><div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;</div><div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;int main()</div><div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;{</div><div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;    board::init();</div><div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;    sei();</div><div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;</div><div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;    gpio::FastPort&lt;board::Port::PORT_D&gt; leds{0xFF, 0x00};</div><div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;    uint8_t pattern = 0x01;</div><div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;    while (true)</div><div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;    {</div><div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;        leds.set_PORT(pattern);</div><div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;        time::delay_ms(250);</div><div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;        pattern &lt;&lt;= 1;</div><div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;        if (!pattern) pattern = 0x01;</div><div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;    }</div><div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;    return 0;</div><div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;}</div><div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</div><div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;In this example, we selected all pins of the same port to connect the 8 LEDs of our chaser. Concretely on UNO, this is port D, which pins are D0-D7.</div><div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;</div><div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;We thus declare and initialize `leds` as a `gpio::FastPort&lt;board::Port::PORT_D&gt;` port, with all pins as output (`0xFF`), with initial level to GND (`0x00`, all LEDs off).</div><div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;</div><div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;Then, we will keep track of the current lit LED through `pattern` byte which each bit represents actually one LED; `pattern` is initialized with `0x01` i.e. D0 should be the first LED to be ON.</div><div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;</div><div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;In the endless loop that follows, we perform the following actions:</div><div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;</div><div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;1. Set all pins values at once to the current value of `pattern`</div><div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;2. Delay execution for 250ms</div><div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;3. Shift the only 1 bit of `pattern` left; note that after 8 shifts, `pattern` will become `0`, hence we need to check against this condition to reset `pattern` to its initial state.</div><div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;</div><div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;This should be rather straightforward to understand if you know C or C++.</div><div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;</div><div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;Here is an equivalent example with Arduino API:</div><div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.cpp}</div><div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;const byte LED_PINS[] = {0, 1, 2, 3, 4, 5, 6, 7};</div><div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;const byte NUM_LEDS =  sizeof(LED_PINS) / sizeof(LED_PINS[0]);</div><div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;</div><div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;void setup()</div><div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;{</div><div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;    for(byte i = 0; i &lt; NUM_LEDS; i++)</div><div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;        pinMode(LED_PINS[i], OUTPUT);</div><div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;}</div><div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;</div><div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;void loop()</div><div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;{</div><div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;    for(byte i = 0; i &lt; NUM_LEDS; i++)</div><div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;    {</div><div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;        digitalWrite(LED_PINS[i], HIGH);</div><div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;        delay(250);</div><div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;        digitalWrite(LED_PINS[i], LOW);</div><div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;    }</div><div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;}</div><div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</div><div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;We see, with Arduino API, that we have to deal with each pin individually, which makes the program source code longer and not necessarily easier to understand.</div><div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;</div><div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;Here is a quick comparison of the sizes for both programs:</div><div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;|           | Arduino API | FastArduino |</div><div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;|-----------|-------------|-------------|</div><div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;| code size | 968 bytes   | 168 bytes   |</div><div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;| data size | 17 bytes    | 0 byte      |</div><div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;</div><div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;</div><div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;@anchor uartflash Basics: UART &amp; flash</div><div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;--------------------------------------</div><div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;</div><div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;### Simple Serial Output example ###</div><div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;</div><div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;Although not often necessary in many finished programs, `UART` (for serial communication interface) is often very useful for debugging a program while it is being developed; this is why `UART` is presented now.</div><div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;</div><div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;Here is a first simple program showing how to display, with FastArduino API, a simple string to the serial output (for UNO, this is connected to USB):</div><div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.cpp}</div><div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;#include &lt;fastarduino/uart.h&gt;</div><div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;</div><div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;static constexpr const uint8_t OUTPUT_BUFFER_SIZE = 64;</div><div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;static char output_buffer[OUTPUT_BUFFER_SIZE];</div><div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;</div><div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;REGISTER_UATX_ISR(0)</div><div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;</div><div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;int main()</div><div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;{</div><div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;    board::init();</div><div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;    sei();</div><div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;   </div><div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;    serial::hard::UATX&lt;board::USART::USART0&gt; uart{output_buffer};</div><div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;    uart.register_handler();</div><div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;    uart.begin(115200);</div><div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;</div><div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;    streams::OutputBuffer out = uart.out();</div><div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;    out.puts(&quot;Hello, World!\n&quot;);</div><div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;    out.flush();</div><div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;    return 0;</div><div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;}</div><div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</div><div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;As usual, at first we need to include the proper header (`uart.h`) to use its API.</div><div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;</div><div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;Then, we define a buffer that will be used by the `UART` API to transmit characters to your PC through USB. You may find it cumbersome to do it yourself but it brings a huge advantage: you are the one to decide of the buffer size, whereas in Arduino API, you have no choice. Here, we consider 64 bits to be big enough to store characters that will be transmitted to the PC. How `UART` is using this buffer is not important to you though.</div><div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;</div><div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;Then we *register an ISR* necessary for transmissions to take place; this is done by the `REGISTER_UATX_ISR(0)` macro. Explicit ISR registration is one important design choice of FastArduino: **you** decide which ISR should be registered to do what. This may again seem cumbersome but once again this gives you the benefit to decie what you need, hence build your application the way you want it.</div><div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;</div><div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;The code that follows instantiates a `uart::hard::UATX` object that is using `board::USART::USART0` (the only one available on UNO) and based on the previously created buffer. Note that `UATX` class is in charge of **only** transmitting characters, not receiving. Other classes exist for only receiving (`UARX`), or for doing both (`UART`).</div><div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;</div><div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;Once created, `uart` needs to be *linked* to the ISR previously registered, this is done through `uart.register_handler()`. Then we can set `uart` ready for transmission, at serial speed of 115200 bps.</div><div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;</div><div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;Next step consists in extracting, from `uart`, a `streams::OutputBuffer` that will allow us to send characters or strings to USB:</div><div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;</div><div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;    out.puts(&quot;Hello, World!\n&quot;);</div><div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;</div><div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;The last important instruction waits for all characters to be transmitted before leaving the program.</div><div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;</div><div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;Here is the equivalent code with Arduino API:</div><div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.cpp}</div><div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;void setup()</div><div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;{</div><div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;  Serial.begin(115200);</div><div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;  Serial.println(&quot;Hello, World!&quot;);</div><div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;}</div><div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;</div><div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;void loop()</div><div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;{</div><div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;}</div><div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</div><div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;Of course, we can see here that the code looks simpler, although one may wonder why we need to define a `loop()` function that does nothing.</div><div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;</div><div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;Now let&#39;s compare the size of both:</div><div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;|           | Arduino API | FastArduino |</div><div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;|-----------|-------------|-------------|</div><div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;| code size | 1440 bytes  | 768 bytes   |</div><div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;| data size | 200 bytes   | 93 bytes    |</div><div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;The data size is big because the buffer used by `Serial` has a hard-coded size (you cannot change it without modifying and recompiling Arduino API). Moreover, when using `Serial`, 2 buffers are created, one for input and one for output, even though you may only need the latter one!</div><div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;</div><div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;Now let&#39;s take a look at the 93 bytes of data used in the FastArduino version of this example, how are they broken down?</div><div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;| Source            | data size   |</div><div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;|-------------------|-------------|</div><div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;| `output_buffer`   | 64 bytes    |</div><div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;| power API         | 1 byte      |</div><div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;| `UATX` ISR        | 2 bytes     |</div><div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;| `UATX` vtable     | 10 bytes    |</div><div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;| &quot;Hello, World!\n&quot; | 16 bytes    |</div><div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;| **TOTAL**         | 93 bytes    |</div><div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;</div><div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;*vtable* is specific data created by C++ compiler for classes with `virtual` methods: every time you use virtual methods in classes, this will add more data size, this is why FastArduino avoids `virtual` as much as possible.</div><div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;</div><div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;As you can see in the table above, the constant string `&quot;Hello, World!\n&quot;` occupies 16 bytes of data (i.e. AVR SRAM) in addition to 16 bytes of Flash (as it is part of the program and must eb stored permanently). If your program deals with a lot of constant strings like this, you may quickly meet a memory problem with SRAM usage. This is why it is more effective to keep these strings exclusively in Flash (you have no choice) but load them t SRAM only when they are needed, i.e. when they get printed to `UATX` as in the sample code.</div><div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;</div><div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;How do we change our program so that this string is only stored in Flash? We can use FastArduino `flash` API for that, by changing only one line of code:</div><div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;</div><div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;    out.puts(F(&quot;Hello, World!\n&quot;));</div><div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;</div><div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;Note the use of `F()` macro here: this makes the string reside in Flash only, and then it is being read from Flash &quot;on the fly&quot; by `out.puts()` method; the latter method is overloaded for usual C-strings (initial example) and for C-strings stored in Flash only.</div><div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;</div><div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;We can compare the impact on sizes:</div><div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;|           | without %F() | with %F()   |</div><div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;|-----------|--------------|-------------|</div><div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;| code size | 768 bytes    | 776 bytes   |</div><div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;| data size | 93 bytes     | 77 bytes    |</div><div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;Although a bit more code has been added (the code to read the string from Flash into SRAM on the fly), we see 16 bytes have been removed from data, this is the size of the string constant.</div><div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;</div><div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;You may wonder why `&quot;Hello, World!\n&quot;` occupies 16 bytes, although it should use only 15 bytes (if we account for the terminating `&#39;\0&#39;` character); this is because the string is stored in Flash and Flash is word-addressable, not byte-addressable on AVR.</div><div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;</div><div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;Note that Flash can also be used to store other read-only data that you may want to access at runtime at specific times, i.e. data you do not want to be stored permanently on SRAM during all execution of your program.</div><div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;</div><div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;The following example shows how to:</div><div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;- define, in your source code, read-only data that shall be stored in Flash memory</div><div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;- read that data when you need it</div><div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.cpp}</div><div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;#include &lt;fastarduino/flash.h&gt;</div><div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;</div><div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;// This is the type of data we want to store in flash</div><div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;struct Dummy</div><div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;{</div><div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;    uint16_t a;</div><div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;    uint8_t b;</div><div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;    bool c;</div><div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;    int16_t d;</div><div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;    char e;</div><div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;};</div><div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;</div><div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;// Define 2 variables of that type, which will be stored in flash</div><div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;// Note the PROGMEM keyword that says the compiler and linker to put this data to flash</div><div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;const Dummy sample1 PROGMEM = {54321, 123, true, -22222, &#39;z&#39;};</div><div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;const Dummy sample2 PROGMEM = {12345, 231, false, -11111, &#39;A&#39;};</div><div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;</div><div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;// The following function needs value of sample1 to be read from flash</div><div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;void read_and_use_sample1()</div><div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;{</div><div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;    // value will get copied with sample1 read-only content</div><div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;    Dummy value;</div><div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;    // request reading sample1 from flash into local variable value</div><div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;    flash::read_flash(&amp;sample1, value);</div><div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;    // Here we can use value which is {54321, 123, true, -22222, &#39;z&#39;}</div><div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;</div><div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;}</div><div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</div><div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;</div><div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;### Formatted Output example ###</div><div class="line"><a name="l00354"></a><span class="lineno">  354</span>&#160;</div><div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160;Compared to Arduino API, FastArduino brings formatted streams as can be found in standard C++; although more verbose than usual C `printf()` function, formatted streams allow compile-time safety.</div><div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;</div><div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;Here is an example that prints formatted data to USB:</div><div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.cpp}</div><div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160;#include &lt;fastarduino/uart.h&gt;</div><div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;</div><div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;static constexpr const uint8_t OUTPUT_BUFFER_SIZE = 64;</div><div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;static char output_buffer[OUTPUT_BUFFER_SIZE];</div><div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;</div><div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;REGISTER_UATX_ISR(0)</div><div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;</div><div class="line"><a name="l00366"></a><span class="lineno">  366</span>&#160;int main()</div><div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;{</div><div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;    board::init();</div><div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160;    sei();</div><div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160;   </div><div class="line"><a name="l00371"></a><span class="lineno">  371</span>&#160;    serial::hard::UATX&lt;board::USART::USART0&gt; uart{output_buffer};</div><div class="line"><a name="l00372"></a><span class="lineno">  372</span>&#160;    uart.register_handler();</div><div class="line"><a name="l00373"></a><span class="lineno">  373</span>&#160;    uart.begin(115200);</div><div class="line"><a name="l00374"></a><span class="lineno">  374</span>&#160;</div><div class="line"><a name="l00375"></a><span class="lineno">  375</span>&#160;    streams::FormattedOutput&lt;streams::OutputBuffer&gt; out = uart.fout();</div><div class="line"><a name="l00376"></a><span class="lineno">  376</span>&#160;    uint16_t value = 0x8000;</div><div class="line"><a name="l00377"></a><span class="lineno">  377</span>&#160;    out &lt;&lt; F(&quot;value = 0x&quot;) &lt;&lt; hex &lt;&lt; value </div><div class="line"><a name="l00378"></a><span class="lineno">  378</span>&#160;        &lt;&lt; F(&quot;, &quot;) &lt;&lt; dec &lt;&lt; value </div><div class="line"><a name="l00379"></a><span class="lineno">  379</span>&#160;        &lt;&lt; F(&quot;, 0&quot;) &lt;&lt; oct &lt;&lt; value </div><div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160;        &lt;&lt; F(&quot;, B&quot;) &lt;&lt; bin &lt;&lt; value &lt;&lt; endl;</div><div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160;    return 0;</div><div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160;}</div><div class="line"><a name="l00383"></a><span class="lineno">  383</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</div><div class="line"><a name="l00384"></a><span class="lineno">  384</span>&#160;Here, we use `uart.fout()` instead of `uart.out()` to get a `streams::FormattedOutput` on which we can use the &quot;insertion operator&quot; `&lt;&lt;`.</div><div class="line"><a name="l00385"></a><span class="lineno">  385</span>&#160;</div><div class="line"><a name="l00386"></a><span class="lineno">  386</span>&#160;If you are used to programming with C++ for more usual systems (e.g. Linux), then you will immediately recognize [`std::ostream` API](http://www.cplusplus.com/reference/ostream/ostream/operator%3C%3C/) which FastArduino library tries to implement with some level of fidelity.</div><div class="line"><a name="l00387"></a><span class="lineno">  387</span>&#160;</div><div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160;You can also find more details in `streams` namespace documentation.</div><div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160;</div><div class="line"><a name="l00390"></a><span class="lineno">  390</span>&#160;Here is the equivalent code with Arduino API:</div><div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.cpp}</div><div class="line"><a name="l00392"></a><span class="lineno">  392</span>&#160;void setup()</div><div class="line"><a name="l00393"></a><span class="lineno">  393</span>&#160;{</div><div class="line"><a name="l00394"></a><span class="lineno">  394</span>&#160;    Serial.begin(115200);</div><div class="line"><a name="l00395"></a><span class="lineno">  395</span>&#160;    byte value = 0x8000;</div><div class="line"><a name="l00396"></a><span class="lineno">  396</span>&#160;    Serial.print(F(&quot;value = 0x&quot;));</div><div class="line"><a name="l00397"></a><span class="lineno">  397</span>&#160;    Serial.print(value, 16);</div><div class="line"><a name="l00398"></a><span class="lineno">  398</span>&#160;    Serial.print(F(&quot;, &quot;));</div><div class="line"><a name="l00399"></a><span class="lineno">  399</span>&#160;    Serial.print(value);</div><div class="line"><a name="l00400"></a><span class="lineno">  400</span>&#160;    Serial.print(F(&quot;, 0&quot;));</div><div class="line"><a name="l00401"></a><span class="lineno">  401</span>&#160;    Serial.print(value, 8);</div><div class="line"><a name="l00402"></a><span class="lineno">  402</span>&#160;    Serial.print(F(&quot;, B&quot;));</div><div class="line"><a name="l00403"></a><span class="lineno">  403</span>&#160;    Serial.println(value, 2);</div><div class="line"><a name="l00404"></a><span class="lineno">  404</span>&#160;}</div><div class="line"><a name="l00405"></a><span class="lineno">  405</span>&#160;</div><div class="line"><a name="l00406"></a><span class="lineno">  406</span>&#160;void loop()</div><div class="line"><a name="l00407"></a><span class="lineno">  407</span>&#160;{</div><div class="line"><a name="l00408"></a><span class="lineno">  408</span>&#160;}</div><div class="line"><a name="l00409"></a><span class="lineno">  409</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</div><div class="line"><a name="l00410"></a><span class="lineno">  410</span>&#160;</div><div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160;Once again, we can compare the size of both:</div><div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160;|           | Arduino API | FastArduino |</div><div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160;|-----------|-------------|-------------|</div><div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160;| code size | 1808 bytes  | 1412 bytes  |</div><div class="line"><a name="l00415"></a><span class="lineno">  415</span>&#160;| data size | 186 bytes   | 77 bytes    |</div><div class="line"><a name="l00416"></a><span class="lineno">  416</span>&#160;</div><div class="line"><a name="l00417"></a><span class="lineno">  417</span>&#160;### Serial Input example ###</div><div class="line"><a name="l00418"></a><span class="lineno">  418</span>&#160;</div><div class="line"><a name="l00419"></a><span class="lineno">  419</span>&#160;FastArduino also implements input streams connected to serial output; here is a simple example:</div><div class="line"><a name="l00420"></a><span class="lineno">  420</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.cpp}</div><div class="line"><a name="l00421"></a><span class="lineno">  421</span>&#160;#include &lt;fastarduino/uart.h&gt;</div><div class="line"><a name="l00422"></a><span class="lineno">  422</span>&#160;</div><div class="line"><a name="l00423"></a><span class="lineno">  423</span>&#160;static constexpr const uint8_t INPUT_BUFFER_SIZE = 64;</div><div class="line"><a name="l00424"></a><span class="lineno">  424</span>&#160;static char input_buffer[INPUT_BUFFER_SIZE];</div><div class="line"><a name="l00425"></a><span class="lineno">  425</span>&#160;</div><div class="line"><a name="l00426"></a><span class="lineno">  426</span>&#160;REGISTER_UARX_ISR(0)</div><div class="line"><a name="l00427"></a><span class="lineno">  427</span>&#160;</div><div class="line"><a name="l00428"></a><span class="lineno">  428</span>&#160;int main()</div><div class="line"><a name="l00429"></a><span class="lineno">  429</span>&#160;{</div><div class="line"><a name="l00430"></a><span class="lineno">  430</span>&#160;    board::init();</div><div class="line"><a name="l00431"></a><span class="lineno">  431</span>&#160;    sei();</div><div class="line"><a name="l00432"></a><span class="lineno">  432</span>&#160;   </div><div class="line"><a name="l00433"></a><span class="lineno">  433</span>&#160;    serial::hard::UARX&lt;board::USART::USART0&gt; uart{input_buffer};</div><div class="line"><a name="l00434"></a><span class="lineno">  434</span>&#160;    uart.register_handler();</div><div class="line"><a name="l00435"></a><span class="lineno">  435</span>&#160;    uart.begin(115200);</div><div class="line"><a name="l00436"></a><span class="lineno">  436</span>&#160;</div><div class="line"><a name="l00437"></a><span class="lineno">  437</span>&#160;    streams::InputBuffer in = uart.in();</div><div class="line"><a name="l00438"></a><span class="lineno">  438</span>&#160;</div><div class="line"><a name="l00439"></a><span class="lineno">  439</span>&#160;    // Get one character if any</div><div class="line"><a name="l00440"></a><span class="lineno">  440</span>&#160;    int input = in.get();</div><div class="line"><a name="l00441"></a><span class="lineno">  441</span>&#160;    if (input != InputBuffer:EOF)</div><div class="line"><a name="l00442"></a><span class="lineno">  442</span>&#160;    {</div><div class="line"><a name="l00443"></a><span class="lineno">  443</span>&#160;        char value = char(input);</div><div class="line"><a name="l00444"></a><span class="lineno">  444</span>&#160;    }</div><div class="line"><a name="l00445"></a><span class="lineno">  445</span>&#160;</div><div class="line"><a name="l00446"></a><span class="lineno">  446</span>&#160;    // Wait until a character is ready and get it</div><div class="line"><a name="l00447"></a><span class="lineno">  447</span>&#160;    char value = streams::get(in);</div><div class="line"><a name="l00448"></a><span class="lineno">  448</span>&#160;</div><div class="line"><a name="l00449"></a><span class="lineno">  449</span>&#160;    // Wait until a complete string is ready and get it</div><div class="line"><a name="l00450"></a><span class="lineno">  450</span>&#160;    char str[64+1];</div><div class="line"><a name="l00451"></a><span class="lineno">  451</span>&#160;    int len = streams::gets(in, str, 64);</div><div class="line"><a name="l00452"></a><span class="lineno">  452</span>&#160;</div><div class="line"><a name="l00453"></a><span class="lineno">  453</span>&#160;    return 0;</div><div class="line"><a name="l00454"></a><span class="lineno">  454</span>&#160;}</div><div class="line"><a name="l00455"></a><span class="lineno">  455</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</div><div class="line"><a name="l00456"></a><span class="lineno">  456</span>&#160;Note the similarities between this example and UATX example above for all the setup parts.</div><div class="line"><a name="l00457"></a><span class="lineno">  457</span>&#160;The main differences are:</div><div class="line"><a name="l00458"></a><span class="lineno">  458</span>&#160;- use `UARX` type instead of `UATX`</div><div class="line"><a name="l00459"></a><span class="lineno">  459</span>&#160;- `REGISTER_UARX_ISR()` instead of `REGISTER_UATX_ISR()` macro for ISR registration</div><div class="line"><a name="l00460"></a><span class="lineno">  460</span>&#160;- use `InputBuffer` instead of `OutputBuffer` and `uart.in()` instead of `uart.out()`</div><div class="line"><a name="l00461"></a><span class="lineno">  461</span>&#160;</div><div class="line"><a name="l00462"></a><span class="lineno">  462</span>&#160;Then `UARX` mainly offers one method, `get()`, which returns the next character serially received and buffered; if the input buffer is currently empty, then `get()` returns `InputBuffer::EOF`, which must be tested before dealing with the returned value.</div><div class="line"><a name="l00463"></a><span class="lineno">  463</span>&#160;</div><div class="line"><a name="l00464"></a><span class="lineno">  464</span>&#160;Then the example uses 2 functions defined directly within `streams` namespace:</div><div class="line"><a name="l00465"></a><span class="lineno">  465</span>&#160;- `get()`: this is similar to `InputBuffer.get()` except that it **blocks** until one character is available on serial input.</div><div class="line"><a name="l00466"></a><span class="lineno">  466</span>&#160;- `gets()`: this blocks until a complete string (terminated by `&#39;\0&#39;`) gets read on serial input and fills the given buffer parameter with that string content.</div><div class="line"><a name="l00467"></a><span class="lineno">  467</span>&#160;</div><div class="line"><a name="l00468"></a><span class="lineno">  468</span>&#160;Note that these 2 functions use `time::yield()` while waiting; this may be linked to `power` management. Please take a look at the documentation for this API for further details.</div><div class="line"><a name="l00469"></a><span class="lineno">  469</span>&#160;</div><div class="line"><a name="l00470"></a><span class="lineno">  470</span>&#160;### Formatted Input example ###</div><div class="line"><a name="l00471"></a><span class="lineno">  471</span>&#160;</div><div class="line"><a name="l00472"></a><span class="lineno">  472</span>&#160;Similar to output, input streams supports formatted input, as can be found in standard C++; once again, formatted input streams allow compile-time safety.</div><div class="line"><a name="l00473"></a><span class="lineno">  473</span>&#160;</div><div class="line"><a name="l00474"></a><span class="lineno">  474</span>&#160;The following example uses formatted input to read values from USB:</div><div class="line"><a name="l00475"></a><span class="lineno">  475</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.cpp}</div><div class="line"><a name="l00476"></a><span class="lineno">  476</span>&#160;#include &lt;fastarduino/uart.h&gt;</div><div class="line"><a name="l00477"></a><span class="lineno">  477</span>&#160;</div><div class="line"><a name="l00478"></a><span class="lineno">  478</span>&#160;// Define vectors we need in the example</div><div class="line"><a name="l00479"></a><span class="lineno">  479</span>&#160;REGISTER_UARX_ISR(0)</div><div class="line"><a name="l00480"></a><span class="lineno">  480</span>&#160;</div><div class="line"><a name="l00481"></a><span class="lineno">  481</span>&#160;// Buffers for UARX</div><div class="line"><a name="l00482"></a><span class="lineno">  482</span>&#160;static const uint8_t INPUT_BUFFER_SIZE = 64;</div><div class="line"><a name="l00483"></a><span class="lineno">  483</span>&#160;static char input_buffer[INPUT_BUFFER_SIZE];</div><div class="line"><a name="l00484"></a><span class="lineno">  484</span>&#160;</div><div class="line"><a name="l00485"></a><span class="lineno">  485</span>&#160;using INPUT = streams::FormattedInput&lt;streams::InputBuffer&gt;;</div><div class="line"><a name="l00486"></a><span class="lineno">  486</span>&#160;</div><div class="line"><a name="l00487"></a><span class="lineno">  487</span>&#160;int main()</div><div class="line"><a name="l00488"></a><span class="lineno">  488</span>&#160;{</div><div class="line"><a name="l00489"></a><span class="lineno">  489</span>&#160;    board::init();</div><div class="line"><a name="l00490"></a><span class="lineno">  490</span>&#160;    sei();</div><div class="line"><a name="l00491"></a><span class="lineno">  491</span>&#160;   </div><div class="line"><a name="l00492"></a><span class="lineno">  492</span>&#160;    // Start UART</div><div class="line"><a name="l00493"></a><span class="lineno">  493</span>&#160;    serial::hard::UARX&lt;board::USART::USART0&gt; uarx{input_buffer};</div><div class="line"><a name="l00494"></a><span class="lineno">  494</span>&#160;    uarx.register_handler();</div><div class="line"><a name="l00495"></a><span class="lineno">  495</span>&#160;    uarx.begin(115200);</div><div class="line"><a name="l00496"></a><span class="lineno">  496</span>&#160;    INPUT in = uarx.fin();</div><div class="line"><a name="l00497"></a><span class="lineno">  497</span>&#160;</div><div class="line"><a name="l00498"></a><span class="lineno">  498</span>&#160;    // Wait for a char</div><div class="line"><a name="l00499"></a><span class="lineno">  499</span>&#160;    char value1;</div><div class="line"><a name="l00500"></a><span class="lineno">  500</span>&#160;    in &gt;&gt; streams::skipws &gt;&gt; value1;</div><div class="line"><a name="l00501"></a><span class="lineno">  501</span>&#160;</div><div class="line"><a name="l00502"></a><span class="lineno">  502</span>&#160;    // Wait for an uint16_t</div><div class="line"><a name="l00503"></a><span class="lineno">  503</span>&#160;    uint16_t value2;</div><div class="line"><a name="l00504"></a><span class="lineno">  504</span>&#160;    in &gt;&gt; streams::skipws &gt;&gt; value2;</div><div class="line"><a name="l00505"></a><span class="lineno">  505</span>&#160;</div><div class="line"><a name="l00506"></a><span class="lineno">  506</span>&#160;    return 0;</div><div class="line"><a name="l00507"></a><span class="lineno">  507</span>&#160;}</div><div class="line"><a name="l00508"></a><span class="lineno">  508</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</div><div class="line"><a name="l00509"></a><span class="lineno">  509</span>&#160;Here, we use `uart.fin()` instead of `uart.in()` to get a `streams::FormattedInput` on which we can use the &quot;extraction operator&quot; `&gt;&gt;`. All extractions are blocking and will not return until the required type can be read from the buffer.</div><div class="line"><a name="l00510"></a><span class="lineno">  510</span>&#160;</div><div class="line"><a name="l00511"></a><span class="lineno">  511</span>&#160;If you are used to programming with C++ for more usual systems (e.g. Linux), then you will immediately recognize [`std::istream` API](http://www.cplusplus.com/reference/istream/istream/operator%3E%3E/) which FastArduino library tries to implement with some level of fidelity.</div><div class="line"><a name="l00512"></a><span class="lineno">  512</span>&#160;</div><div class="line"><a name="l00513"></a><span class="lineno">  513</span>&#160;You can also find more details in `streams` namespace documentation.</div><div class="line"><a name="l00514"></a><span class="lineno">  514</span>&#160;</div><div class="line"><a name="l00515"></a><span class="lineno">  515</span>&#160;We have already seen `UATX` and `UARX` as classes for sending, resp. receiving, data through serial. There is also `UARX` which combines both.</div><div class="line"><a name="l00516"></a><span class="lineno">  516</span>&#160;</div><div class="line"><a name="l00517"></a><span class="lineno">  517</span>&#160;As you know, the number of physical (hardware) UART available on an MCU target is limited, some targets (ATtiny) don&#39;t even have any hardware UART at all. For this reason, if you need extra UART featurs to connect to some devices, you can use software UART API, documented in [namespace `serial::soft`](TODO). As this more complicated to use, it is not part of this basic tutorial, but will be addressed later on.</div><div class="line"><a name="l00518"></a><span class="lineno">  518</span>&#160;</div><div class="line"><a name="l00519"></a><span class="lineno">  519</span>&#160;</div><div class="line"><a name="l00520"></a><span class="lineno">  520</span>&#160;@anchor analoginput Basics: analog input</div><div class="line"><a name="l00521"></a><span class="lineno">  521</span>&#160;----------------------------------------</div><div class="line"><a name="l00522"></a><span class="lineno">  522</span>&#160;</div><div class="line"><a name="l00523"></a><span class="lineno">  523</span>&#160;Here is a simple example using analog input API to read a value from some sensor (thermistor, potentiometer, whatever you like) and lights a LED if the read value is above some threshold:</div><div class="line"><a name="l00524"></a><span class="lineno">  524</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.cpp}</div><div class="line"><a name="l00525"></a><span class="lineno">  525</span>&#160;#include &lt;fastarduino/analog_input.h&gt;</div><div class="line"><a name="l00526"></a><span class="lineno">  526</span>&#160;#include &lt;fastarduino/gpio.h&gt;</div><div class="line"><a name="l00527"></a><span class="lineno">  527</span>&#160;#include &lt;fastarduino/time.h&gt;</div><div class="line"><a name="l00528"></a><span class="lineno">  528</span>&#160;</div><div class="line"><a name="l00529"></a><span class="lineno">  529</span>&#160;const uint16_t THRESHOLD = 500;</div><div class="line"><a name="l00530"></a><span class="lineno">  530</span>&#160;</div><div class="line"><a name="l00531"></a><span class="lineno">  531</span>&#160;int main()</div><div class="line"><a name="l00532"></a><span class="lineno">  532</span>&#160;{</div><div class="line"><a name="l00533"></a><span class="lineno">  533</span>&#160;    board::init();</div><div class="line"><a name="l00534"></a><span class="lineno">  534</span>&#160;    sei();</div><div class="line"><a name="l00535"></a><span class="lineno">  535</span>&#160;</div><div class="line"><a name="l00536"></a><span class="lineno">  536</span>&#160;    gpio::FastPinType&lt;board::DigitalPin::LED&gt;::TYPE led{gpio::PinMode::OUTPUT};</div><div class="line"><a name="l00537"></a><span class="lineno">  537</span>&#160;    analog::AnalogInput&lt;board::AnalogPin::A0&gt; sensor;</div><div class="line"><a name="l00538"></a><span class="lineno">  538</span>&#160;    while (true)</div><div class="line"><a name="l00539"></a><span class="lineno">  539</span>&#160;    {</div><div class="line"><a name="l00540"></a><span class="lineno">  540</span>&#160;        if (sensor.sample() &gt; THRESHOLD)</div><div class="line"><a name="l00541"></a><span class="lineno">  541</span>&#160;            led.set();</div><div class="line"><a name="l00542"></a><span class="lineno">  542</span>&#160;        else</div><div class="line"><a name="l00543"></a><span class="lineno">  543</span>&#160;            led.clear();</div><div class="line"><a name="l00544"></a><span class="lineno">  544</span>&#160;        time::delay_ms(100);</div><div class="line"><a name="l00545"></a><span class="lineno">  545</span>&#160;    }</div><div class="line"><a name="l00546"></a><span class="lineno">  546</span>&#160;    return 0;</div><div class="line"><a name="l00547"></a><span class="lineno">  547</span>&#160;}</div><div class="line"><a name="l00548"></a><span class="lineno">  548</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</div><div class="line"><a name="l00549"></a><span class="lineno">  549</span>&#160;This example is an adaptation of the [first GPIO example](@ref gpio) of this tutorial.</div><div class="line"><a name="l00550"></a><span class="lineno">  550</span>&#160;</div><div class="line"><a name="l00551"></a><span class="lineno">  551</span>&#160;The first change consists in including the necessary header:</div><div class="line"><a name="l00552"></a><span class="lineno">  552</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.cpp}</div><div class="line"><a name="l00553"></a><span class="lineno">  553</span>&#160;#include &lt;fastarduino/analog_input.h&gt;</div><div class="line"><a name="l00554"></a><span class="lineno">  554</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</div><div class="line"><a name="l00555"></a><span class="lineno">  555</span>&#160;</div><div class="line"><a name="l00556"></a><span class="lineno">  556</span>&#160;Then we have the definition of the `sensor` variable:</div><div class="line"><a name="l00557"></a><span class="lineno">  557</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.cpp}</div><div class="line"><a name="l00558"></a><span class="lineno">  558</span>&#160;    analog::AnalogInput&lt;board::AnalogPin::A0&gt; sensor;</div><div class="line"><a name="l00559"></a><span class="lineno">  559</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</div><div class="line"><a name="l00560"></a><span class="lineno">  560</span>&#160;Here we instantiate `AnalogInput` for analog pin `A0` (on Arduino UNO).</div><div class="line"><a name="l00561"></a><span class="lineno">  561</span>&#160;</div><div class="line"><a name="l00562"></a><span class="lineno">  562</span>&#160;In the infinite loop, we then get the current analog value of `sensor` and compare it to `THRESHOLD` constant:</div><div class="line"><a name="l00563"></a><span class="lineno">  563</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.cpp}</div><div class="line"><a name="l00564"></a><span class="lineno">  564</span>&#160;        if (sensor.sample() &gt; THRESHOLD)</div><div class="line"><a name="l00565"></a><span class="lineno">  565</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</div><div class="line"><a name="l00566"></a><span class="lineno">  566</span>&#160;</div><div class="line"><a name="l00567"></a><span class="lineno">  567</span>&#160;By default, sample values are on 10 bits (0..1023) represented as `uint16_t`.</div><div class="line"><a name="l00568"></a><span class="lineno">  568</span>&#160;</div><div class="line"><a name="l00569"></a><span class="lineno">  569</span>&#160;If you don&#39;t need such precision, you can define `sensor` differently:</div><div class="line"><a name="l00570"></a><span class="lineno">  570</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.cpp}</div><div class="line"><a name="l00571"></a><span class="lineno">  571</span>&#160;    analog::AnalogInput&lt;board::AnalogPin::A0, board::AnalogReference::AVCC, uint8_t&gt; sensor;</div><div class="line"><a name="l00572"></a><span class="lineno">  572</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</div><div class="line"><a name="l00573"></a><span class="lineno">  573</span>&#160;Note the two additional template arguments provided to `AnalogInput&lt;...&gt;`:</div><div class="line"><a name="l00574"></a><span class="lineno">  574</span>&#160;- the first added argument `board::AnalogReference::AVCC`, although seldom changed, may become important when you create your own boards from MCU chips; you can further read API documentation if you need more information about it</div><div class="line"><a name="l00575"></a><span class="lineno">  575</span>&#160;- the second added argument is the type of returned samples, either `uint16_t` (default value) or `uint8_t`. The type determines the samples precision:</div><div class="line"><a name="l00576"></a><span class="lineno">  576</span>&#160;    - `uint8_t`: 8 bits (samples between 0 and 255)</div><div class="line"><a name="l00577"></a><span class="lineno">  577</span>&#160;    - `uint16_t`: 10 bits (samples between 0 and 1023)</div><div class="line"><a name="l00578"></a><span class="lineno">  578</span>&#160;</div><div class="line"><a name="l00579"></a><span class="lineno">  579</span>&#160;Now let&#39;s compare the first example with the equivalent Arduino core API program:</div><div class="line"><a name="l00580"></a><span class="lineno">  580</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.cpp}</div><div class="line"><a name="l00581"></a><span class="lineno">  581</span>&#160;void setup()</div><div class="line"><a name="l00582"></a><span class="lineno">  582</span>&#160;{</div><div class="line"><a name="l00583"></a><span class="lineno">  583</span>&#160;    pinMode(LED_BUILTIN, OUTPUT);</div><div class="line"><a name="l00584"></a><span class="lineno">  584</span>&#160;}</div><div class="line"><a name="l00585"></a><span class="lineno">  585</span>&#160;</div><div class="line"><a name="l00586"></a><span class="lineno">  586</span>&#160;const uint16_t THRESHOLD = 500;</div><div class="line"><a name="l00587"></a><span class="lineno">  587</span>&#160;</div><div class="line"><a name="l00588"></a><span class="lineno">  588</span>&#160;void loop()</div><div class="line"><a name="l00589"></a><span class="lineno">  589</span>&#160;{</div><div class="line"><a name="l00590"></a><span class="lineno">  590</span>&#160;    if (analogRead(A0) &gt; THRESHOLD)</div><div class="line"><a name="l00591"></a><span class="lineno">  591</span>&#160;        digitalWrite(LED_BUILTIN, HIGH);</div><div class="line"><a name="l00592"></a><span class="lineno">  592</span>&#160;    else</div><div class="line"><a name="l00593"></a><span class="lineno">  593</span>&#160;        digitalWrite(LED_BUILTIN, LOW);</div><div class="line"><a name="l00594"></a><span class="lineno">  594</span>&#160;    delay(100);</div><div class="line"><a name="l00595"></a><span class="lineno">  595</span>&#160;}</div><div class="line"><a name="l00596"></a><span class="lineno">  596</span>&#160;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</div><div class="line"><a name="l00597"></a><span class="lineno">  597</span>&#160;</div><div class="line"><a name="l00598"></a><span class="lineno">  598</span>&#160;As usual, we compare the size of both:</div><div class="line"><a name="l00599"></a><span class="lineno">  599</span>&#160;|           | Arduino API | FastArduino |</div><div class="line"><a name="l00600"></a><span class="lineno">  600</span>&#160;|-----------|-------------|-------------|</div><div class="line"><a name="l00601"></a><span class="lineno">  601</span>&#160;| code size | 204 bytes   | 926 bytes   |</div><div class="line"><a name="l00602"></a><span class="lineno">  602</span>&#160;| data size | 0 bytes     | 9 bytes     |</div><div class="line"><a name="l00603"></a><span class="lineno">  603</span>&#160;</div><div class="line"><a name="l00604"></a><span class="lineno">  604</span>&#160;Note that Arduino core API does not allow you any other precision than 10 bits.</div><div class="line"><a name="l00605"></a><span class="lineno">  605</span>&#160;</div><div class="line"><a name="l00606"></a><span class="lineno">  606</span>&#160;</div><div class="line"><a name="l00607"></a><span class="lineno">  607</span>&#160;@anchor timer Basics: timer</div><div class="line"><a name="l00608"></a><span class="lineno">  608</span>&#160;---------------------------</div><div class="line"><a name="l00609"></a><span class="lineno">  609</span>&#160;</div><div class="line"><a name="l00610"></a><span class="lineno">  610</span>&#160;TODO reminder on what timers are and what they can do.</div><div class="line"><a name="l00611"></a><span class="lineno">  611</span>&#160;</div><div class="line"><a name="l00612"></a><span class="lineno">  612</span>&#160;TODO all timers are similar but different (prescalers, size, capabilities).</div><div class="line"><a name="l00613"></a><span class="lineno">  613</span>&#160;</div><div class="line"><a name="l00614"></a><span class="lineno">  614</span>&#160;TODO start simple example (which one?)</div><div class="line"><a name="l00615"></a><span class="lineno">  615</span>&#160;</div></div><!-- fragment --></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>tutorial.md</b></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
