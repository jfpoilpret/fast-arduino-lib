<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>FastArduino: i2c Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">FastArduino
   &#160;<span id="projectnumber">v1.9 alpha</span>
   </div>
   <div id="projectbrief">C++ library to build fast but small Arduino/AVR projects</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespacei2c.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">i2c Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Define API to define and manage I2C devices.  
<a href="namespacei2c.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacei2c_1_1debug"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacei2c_1_1debug.html">debug</a></td></tr>
<tr class="memdesc:namespacei2c_1_1debug"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines API to ease I2C devices debugging. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacei2c_1_1status"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacei2c_1_1status.html">status</a></td></tr>
<tr class="memdesc:namespacei2c_1_1status"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines API to ease I2C manager status tracing and debugging. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classi2c_1_1_i2_c_device.html">I2CDevice</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all I2C devices.  <a href="classi2c_1_1_i2_c_device.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classi2c_1_1_read_register_future.html">ReadRegisterFuture</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">General Future that can be used to read an I2C device register.  <a href="classi2c_1_1_read_register_future.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classi2c_1_1_t_read_register_future.html">TReadRegisterFuture</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic Future that can be used to read an I2C device register.  <a href="classi2c_1_1_t_read_register_future.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classi2c_1_1_write_register_future.html">WriteRegisterFuture</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">General Future that can be used to write to an I2C device register.  <a href="classi2c_1_1_write_register_future.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classi2c_1_1_t_write_register_future.html">TWriteRegisterFuture</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic Future that can be used to write to an I2C device register.  <a href="classi2c_1_1_t_write_register_future.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classi2c_1_1_t_write_multi_register_future.html">TWriteMultiRegisterFuture</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic Future that can be used to write to several I2C device registers.  <a href="classi2c_1_1_t_write_multi_register_future.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classi2c_1_1_i2_c_futures_group.html">I2CFuturesGroup</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract class to allow aggregation of several futures in relation to I2C transactions.  <a href="classi2c_1_1_i2_c_futures_group.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classi2c_1_1_i2_c_same_future_group.html">I2CSameFutureGroup</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to allow dynamic creation of futures from values stored in flash memory, leading to launch of I2C transactions.  <a href="classi2c_1_1_i2_c_same_future_group.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classi2c_1_1_abstract_i2_c_sync_a_tmega_manager.html">AbstractI2CSyncATmegaManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract synchronous I2C Manager for ATmega architecture.  <a href="classi2c_1_1_abstract_i2_c_sync_a_tmega_manager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classi2c_1_1_abstract_i2_c_async_manager.html">AbstractI2CAsyncManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract asynchronous I2C Manager.  <a href="classi2c_1_1_abstract_i2_c_async_manager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classi2c_1_1_i2_c_async_manager.html">I2CAsyncManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronous I2C Manager for ATmega architecture.  <a href="classi2c_1_1_i2_c_async_manager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classi2c_1_1_i2_c_async_debug_manager.html">I2CAsyncDebugManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronous I2C Manager for ATmega architecture with debug facility.  <a href="classi2c_1_1_i2_c_async_debug_manager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classi2c_1_1_i2_c_async_status_manager.html">I2CAsyncStatusManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronous I2C Manager for ATmega architecture with status notification facility.  <a href="classi2c_1_1_i2_c_async_status_manager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classi2c_1_1_i2_c_async_status_debug_manager.html">I2CAsyncStatusDebugManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronous I2C Manager for ATmega architecture with debug and status notification facilities.  <a href="classi2c_1_1_i2_c_async_status_debug_manager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classi2c_1_1_i2_c_sync_manager.html">I2CSyncManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronous I2C Manager for ATmega architecture.  <a href="classi2c_1_1_i2_c_sync_manager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classi2c_1_1_i2_c_sync_status_manager.html">I2CSyncStatusManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronous I2C Manager for ATmega architecture wit status notification facility.  <a href="classi2c_1_1_i2_c_sync_status_manager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classi2c_1_1_i2_c_sync_debug_manager.html">I2CSyncDebugManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronous I2C Manager for ATmega architecture with debug facility.  <a href="classi2c_1_1_i2_c_sync_debug_manager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classi2c_1_1_i2_c_sync_status_debug_manager.html">I2CSyncStatusDebugManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronous I2C Manager for ATmega architecture with status notification and debug facility.  <a href="classi2c_1_1_i2_c_sync_status_debug_manager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classi2c_1_1_abstract_i2_c_sync_a_ttiny_manager.html">AbstractI2CSyncATtinyManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract synchronous I2C Manager for ATtiny architecture.  <a href="classi2c_1_1_abstract_i2_c_sync_a_ttiny_manager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classi2c_1_1_i2_c_light_command.html">I2CLightCommand</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Light atomic I2C command as prepared by an I2C device.  <a href="classi2c_1_1_i2_c_light_command.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classi2c_1_1_i2_c_command.html">I2CCommand</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic I2C command as used internally by an asynchronous I2C Manager.  <a href="classi2c_1_1_i2_c_command.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classi2c_1_1_abstract_i2_c_sync_manager.html">AbstractI2CSyncManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract synchronous I2C Manager for all MCU architectures.  <a href="classi2c_1_1_abstract_i2_c_sync_manager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a28595eabdfa2ce6a84220d6eb59233e0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacei2c.html#a28595eabdfa2ce6a84220d6eb59233e0">I2C_DEBUG_HOOK</a> = void(*)(<a class="el" href="namespacei2c.html#a2572e0fde7ef325c8f5c1c974c2de720">DebugStatus</a> status, uint8_t data)</td></tr>
<tr class="memdesc:a28595eabdfa2ce6a84220d6eb59233e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default debugging hook type.  <a href="namespacei2c.html#a28595eabdfa2ce6a84220d6eb59233e0">More...</a><br /></td></tr>
<tr class="separator:a28595eabdfa2ce6a84220d6eb59233e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d00ac941e250c51b3cde59069e2fbec"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacei2c.html#a0d00ac941e250c51b3cde59069e2fbec">I2C_STATUS_HOOK</a> = void(*)(<a class="el" href="namespacei2c.html#adb5bfde92afd6cbc048d1ee7472bf394">Status</a> expected, <a class="el" href="namespacei2c.html#adb5bfde92afd6cbc048d1ee7472bf394">Status</a> actual)</td></tr>
<tr class="memdesc:a0d00ac941e250c51b3cde59069e2fbec"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default status observer hook type.  <a href="namespacei2c.html#a0d00ac941e250c51b3cde59069e2fbec">More...</a><br /></td></tr>
<tr class="separator:a0d00ac941e250c51b3cde59069e2fbec"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:adb5bfde92afd6cbc048d1ee7472bf394"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacei2c.html#adb5bfde92afd6cbc048d1ee7472bf394">Status</a> : uint8_t { <br />
&#160;&#160;<a class="el" href="namespacei2c.html#adb5bfde92afd6cbc048d1ee7472bf394ae0aa021e21dddbd6d8cecec71e9cf564">OK</a> = 0x00
, <br />
&#160;&#160;<a class="el" href="namespacei2c.html#adb5bfde92afd6cbc048d1ee7472bf394a0f0db442fad97bbaa5d55ef59d4a01d4">START_TRANSMITTED</a> = 0x08
, <br />
&#160;&#160;<a class="el" href="namespacei2c.html#adb5bfde92afd6cbc048d1ee7472bf394a2bf969769e65b7f1da7824cd59384d38">REPEAT_START_TRANSMITTED</a> = 0x10
, <br />
&#160;&#160;<a class="el" href="namespacei2c.html#adb5bfde92afd6cbc048d1ee7472bf394a4732cb8574071463f6bba0b25d081cd2">SLA_W_TRANSMITTED_ACK</a> = 0x18
, <br />
&#160;&#160;<a class="el" href="namespacei2c.html#adb5bfde92afd6cbc048d1ee7472bf394a9f0c8e7e539ae0087ac1bcb9c3fa721d">SLA_W_TRANSMITTED_NACK</a> = 0x20
, <br />
&#160;&#160;<a class="el" href="namespacei2c.html#adb5bfde92afd6cbc048d1ee7472bf394a3bc1886a3f635d69d7a3f86c0251e9cd">DATA_TRANSMITTED_ACK</a> = 0x28
, <br />
&#160;&#160;<a class="el" href="namespacei2c.html#adb5bfde92afd6cbc048d1ee7472bf394a78d1df25360b4e5d4b6e98b85ad1054a">DATA_TRANSMITTED_NACK</a> = 0x30
, <br />
&#160;&#160;<a class="el" href="namespacei2c.html#adb5bfde92afd6cbc048d1ee7472bf394a1b265dff01af1e30093a5c05a841197c">ARBITRATION_LOST</a> = 0x38
, <br />
&#160;&#160;<a class="el" href="namespacei2c.html#adb5bfde92afd6cbc048d1ee7472bf394aba848a7dd2b8595e79d1642ab7f143c1">SLA_R_TRANSMITTED_ACK</a> = 0x40
, <br />
&#160;&#160;<a class="el" href="namespacei2c.html#adb5bfde92afd6cbc048d1ee7472bf394ab073180fed195e16de9e345d1bbbbedc">SLA_R_TRANSMITTED_NACK</a> = 0x48
, <br />
&#160;&#160;<a class="el" href="namespacei2c.html#adb5bfde92afd6cbc048d1ee7472bf394a912b7b2e9352cadf9ed4bac50d985ac5">DATA_RECEIVED_ACK</a> = 0x50
, <br />
&#160;&#160;<a class="el" href="namespacei2c.html#adb5bfde92afd6cbc048d1ee7472bf394aa852f412f97bf4c4dc2d58a53c18db06">DATA_RECEIVED_NACK</a> = 0x58
<br />
 }</td></tr>
<tr class="memdesc:adb5bfde92afd6cbc048d1ee7472bf394"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transmission status codes.  <a href="namespacei2c.html#adb5bfde92afd6cbc048d1ee7472bf394">More...</a><br /></td></tr>
<tr class="separator:adb5bfde92afd6cbc048d1ee7472bf394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2780f0139dbc26f4d83a426dad67e36"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacei2c.html#ac2780f0139dbc26f4d83a426dad67e36">I2CMode</a> : uint8_t { <br />
&#160;&#160;<a class="el" href="namespacei2c.html#ac2780f0139dbc26f4d83a426dad67e36a94e94133f4bdc1794c6b647b8ea134d0">STANDARD</a>
, <br />
&#160;&#160;<a class="el" href="namespacei2c.html#ac2780f0139dbc26f4d83a426dad67e36adca6e617f6fb54033deb311e7e7c93cc">FAST</a>
<br />
 }</td></tr>
<tr class="memdesc:ac2780f0139dbc26f4d83a426dad67e36"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C available transmission modes.  <a href="namespacei2c.html#ac2780f0139dbc26f4d83a426dad67e36">More...</a><br /></td></tr>
<tr class="separator:ac2780f0139dbc26f4d83a426dad67e36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25d59895330a8395962d09a25a3f9f6d"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacei2c.html#a25d59895330a8395962d09a25a3f9f6d">I2CCallback</a> : uint8_t { <br />
&#160;&#160;<a class="el" href="namespacei2c.html#a25d59895330a8395962d09a25a3f9f6dab50339a10e1de285ac99d4c3990b8693">NONE</a> = 0
, <br />
&#160;&#160;<a class="el" href="namespacei2c.html#a25d59895330a8395962d09a25a3f9f6da711552a437320497067695003417ad61">END_COMMAND</a>
, <br />
&#160;&#160;<a class="el" href="namespacei2c.html#a25d59895330a8395962d09a25a3f9f6da481bd43bb59f8979a47ca7791b18b050">END_TRANSACTION</a>
, <br />
&#160;&#160;<a class="el" href="namespacei2c.html#a25d59895330a8395962d09a25a3f9f6dabb1ca97ec761fc37101737ba0aa2e7c5">ERROR</a>
<br />
 }</td></tr>
<tr class="memdesc:a25d59895330a8395962d09a25a3f9f6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type passed to I2C ISR registered callbacks (asynchronous I2C Manager only) when an asynchronous I2C transaction is executed.  <a href="namespacei2c.html#a25d59895330a8395962d09a25a3f9f6d">More...</a><br /></td></tr>
<tr class="separator:a25d59895330a8395962d09a25a3f9f6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2572e0fde7ef325c8f5c1c974c2de720"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacei2c.html#a2572e0fde7ef325c8f5c1c974c2de720">DebugStatus</a> : uint8_t { <br />
&#160;&#160;<a class="el" href="namespacei2c.html#a2572e0fde7ef325c8f5c1c974c2de720ab078ffd28db767c502ac367053f6e0ac">START</a> = 0
, <br />
&#160;&#160;<a class="el" href="namespacei2c.html#a2572e0fde7ef325c8f5c1c974c2de720a76b1318f71bfa0c154b487992316b17f">REPEAT_START</a>
, <br />
&#160;&#160;<a class="el" href="namespacei2c.html#a2572e0fde7ef325c8f5c1c974c2de720acd9fd54f6c2d152e758aaee66257b47a">SLAW</a>
, <br />
&#160;&#160;<a class="el" href="namespacei2c.html#a2572e0fde7ef325c8f5c1c974c2de720a2ccc467a63546c4af6e4f07ef674e882">SLAR</a>
, <br />
&#160;&#160;<a class="el" href="namespacei2c.html#a2572e0fde7ef325c8f5c1c974c2de720a548e51fa67d541384e9585adf0db95dc">SEND</a>
, <br />
&#160;&#160;<a class="el" href="namespacei2c.html#a2572e0fde7ef325c8f5c1c974c2de720ab882f51794befb4d8c136ce9b5e2d6e7">RECV</a>
, <br />
&#160;&#160;<a class="el" href="namespacei2c.html#a2572e0fde7ef325c8f5c1c974c2de720a9955c41ad5fc66b5da77307c2c59c255">RECV_LAST</a>
, <br />
&#160;&#160;<a class="el" href="namespacei2c.html#a2572e0fde7ef325c8f5c1c974c2de720a615a46af313786fc4e349f34118be111">STOP</a>
, <br />
&#160;&#160;<a class="el" href="namespacei2c.html#a2572e0fde7ef325c8f5c1c974c2de720a25ab30dd6c78e898a233330d0aff4075">SEND_OK</a>
, <br />
&#160;&#160;<a class="el" href="namespacei2c.html#a2572e0fde7ef325c8f5c1c974c2de720a2722a1c4409a8a5aad2b5467f3cb5b2d">SEND_ERROR</a>
, <br />
&#160;&#160;<a class="el" href="namespacei2c.html#a2572e0fde7ef325c8f5c1c974c2de720a351db13aaeaf87c513f33e9f00b3dcb4">RECV_OK</a>
, <br />
&#160;&#160;<a class="el" href="namespacei2c.html#a2572e0fde7ef325c8f5c1c974c2de720acbefb7345e20459bf05682fa57a439f9">RECV_ERROR</a>
<br />
 }</td></tr>
<tr class="memdesc:a2572e0fde7ef325c8f5c1c974c2de720"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of debug states that are reported by the I2C Manager in debug mode.  <a href="namespacei2c.html#a2572e0fde7ef325c8f5c1c974c2de720">More...</a><br /></td></tr>
<tr class="separator:a2572e0fde7ef325c8f5c1c974c2de720"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b806d8952ab67c30889f49248e7fa09"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacei2c.html#a2b806d8952ab67c30889f49248e7fa09">I2CErrorPolicy</a> : uint8_t { <br />
&#160;&#160;<a class="el" href="namespacei2c.html#a2b806d8952ab67c30889f49248e7fa09acd6102c4e0e339658526415ee06ad67d">DO_NOTHING</a>
, <br />
&#160;&#160;<a class="el" href="namespacei2c.html#a2b806d8952ab67c30889f49248e7fa09a6838e2ec9e1458cb5470fdd5aa8dbb39">CLEAR_ALL_COMMANDS</a>
, <br />
&#160;&#160;<a class="el" href="namespacei2c.html#a2b806d8952ab67c30889f49248e7fa09a9767f7913244ec57b19a3adf2fff4030">CLEAR_TRANSACTION_COMMANDS</a>
<br />
 }</td></tr>
<tr class="memdesc:a2b806d8952ab67c30889f49248e7fa09"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C Manager policy to use in case of an error during I2C transaction.  <a href="namespacei2c.html#a2b806d8952ab67c30889f49248e7fa09">More...</a><br /></td></tr>
<tr class="separator:a2b806d8952ab67c30889f49248e7fa09"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a5794e860eddf1016c5eb16ae1c9629bd"><td class="memTemplParams" colspan="2">template&lt;typename MANAGER &gt; </td></tr>
<tr class="memitem:a5794e860eddf1016c5eb16ae1c9629bd"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacei2c.html#a5794e860eddf1016c5eb16ae1c9629bd">await_same_future_group</a> (<a class="el" href="classi2c_1_1_i2_c_device.html">I2CDevice</a>&lt; MANAGER &gt; &amp;device, const uint8_t *buffer, uint8_t size)</td></tr>
<tr class="memdesc:a5794e860eddf1016c5eb16ae1c9629bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function that creates a <code><a class="el" href="classi2c_1_1_i2_c_same_future_group.html" title="Class to allow dynamic creation of futures from values stored in flash memory, leading to launch of I...">I2CSameFutureGroup</a></code> instance for the provided flash array, launches its I2C transactions on the provided I2C device, and waits for the transaction to finish.  <a href="namespacei2c.html#a5794e860eddf1016c5eb16ae1c9629bd">More...</a><br /></td></tr>
<tr class="separator:a5794e860eddf1016c5eb16ae1c9629bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ab75faf1b696d9d3d0383268167116746"><td class="memItemLeft" align="right" valign="top"><a id="ab75faf1b696d9d3d0383268167116746"></a>
static constexpr Mode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacei2c.html#ab75faf1b696d9d3d0383268167116746">I2C_STANDARD</a> = Mode&lt;<a class="el" href="namespacei2c.html#ac2780f0139dbc26f4d83a426dad67e36a94e94133f4bdc1794c6b647b8ea134d0">I2CMode::STANDARD</a>&gt;{}</td></tr>
<tr class="memdesc:ab75faf1b696d9d3d0383268167116746"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant determining that best supported I2C mode for an <a class="el" href="classi2c_1_1_i2_c_device.html" title="Base class for all I2C devices.">I2CDevice</a> is STANDARD (100kHz). <br /></td></tr>
<tr class="separator:ab75faf1b696d9d3d0383268167116746"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace3a5e20376d4212091d6db37a6767e6"><td class="memItemLeft" align="right" valign="top"><a id="ace3a5e20376d4212091d6db37a6767e6"></a>
static constexpr Mode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacei2c.html#ace3a5e20376d4212091d6db37a6767e6">I2C_FAST</a> = Mode&lt;<a class="el" href="namespacei2c.html#ac2780f0139dbc26f4d83a426dad67e36adca6e617f6fb54033deb311e7e7c93cc">I2CMode::FAST</a>&gt;{}</td></tr>
<tr class="memdesc:ace3a5e20376d4212091d6db37a6767e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant determining that best supported I2C mode for an <a class="el" href="classi2c_1_1_i2_c_device.html" title="Base class for all I2C devices.">I2CDevice</a> is FAST (400kHz). <br /></td></tr>
<tr class="separator:ace3a5e20376d4212091d6db37a6767e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Define API to define and manage I2C devices. </p>
<p>This namespace defines everything related to I2C.</p>
<p>I2C is available to all MCU supported by FastArduino, even in ATtiny MCU, for which I2C is implemented with <em>Universal Serial Interface</em> (USI). </p><dl class="section note"><dt>Note</dt><dd>Current implementation supports both synchronous and asynchronous operation. However, asynchronous operation is only supported on ATmega MCU.</dd></dl>
<p>The following snippet shows how to use an I2C device, the DS1307 Real Time Clock: </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="classi2c_1_1_i2_c_sync_manager.html">i2c::I2CSyncManager&lt;i2c::I2CMode::STANDARD&gt;</a> manager;</div>
<div class="line">    manager.<a class="code" href="classi2c_1_1_abstract_i2_c_sync_manager.html#a1d57efe73e4e8d75bf303f148be8fe1d">begin</a>();</div>
<div class="line">    <a class="code" href="classdevices_1_1rtc_1_1_d_s1307.html">devices::rtc::DS1307</a> rtc{manager};</div>
<div class="line">    <a class="code" href="structdevices_1_1rtc_1_1tm.html">devices::rtc::tm</a> now;</div>
<div class="line">    rtc.get_datetime(now);</div>
<div class="line">    ...</div>
<div class="line">    manager.<a class="code" href="classi2c_1_1_abstract_i2_c_sync_manager.html#a2511a80e2ce5b2b6142922a306b4588e">end</a>();</div>
<div class="line">}</div>
<div class="ttc" id="aclassdevices_1_1rtc_1_1_d_s1307_html"><div class="ttname"><a href="classdevices_1_1rtc_1_1_d_s1307.html">devices::rtc::DS1307</a></div><div class="ttdoc">I2C device driver for the DS1307 RTC chip.</div><div class="ttdef"><b>Definition:</b> <a href="ds1307_8h_source.html#l00116">ds1307.h:117</a></div></div>
<div class="ttc" id="aclassi2c_1_1_abstract_i2_c_sync_manager_html_a1d57efe73e4e8d75bf303f148be8fe1d"><div class="ttname"><a href="classi2c_1_1_abstract_i2_c_sync_manager.html#a1d57efe73e4e8d75bf303f148be8fe1d">i2c::AbstractI2CSyncManager::begin</a></div><div class="ttdeci">void begin()</div><div class="ttdoc">Prepare and enable the MCU for I2C transmission.</div><div class="ttdef"><b>Definition:</b> <a href="i2c__handler__common_8h_source.html#l00448">i2c_handler_common.h:448</a></div></div>
<div class="ttc" id="aclassi2c_1_1_abstract_i2_c_sync_manager_html_a2511a80e2ce5b2b6142922a306b4588e"><div class="ttname"><a href="classi2c_1_1_abstract_i2_c_sync_manager.html#a2511a80e2ce5b2b6142922a306b4588e">i2c::AbstractI2CSyncManager::end</a></div><div class="ttdeci">void end()</div><div class="ttdoc">Disable MCU I2C transmission.</div><div class="ttdef"><b>Definition:</b> <a href="i2c__handler__common_8h_source.html#l00459">i2c_handler_common.h:459</a></div></div>
<div class="ttc" id="aclassi2c_1_1_i2_c_sync_manager_html"><div class="ttname"><a href="classi2c_1_1_i2_c_sync_manager.html">i2c::I2CSyncManager</a></div><div class="ttdoc">Synchronous I2C Manager for ATmega architecture.</div><div class="ttdef"><b>Definition:</b> <a href="i2c__handler__atmega_8h_source.html#l00936">i2c_handler_atmega.h:938</a></div></div>
<div class="ttc" id="astructdevices_1_1rtc_1_1tm_html"><div class="ttname"><a href="structdevices_1_1rtc_1_1tm.html">devices::rtc::tm</a></div><div class="ttdoc">The datetime structure used by the RTC API.</div><div class="ttdef"><b>Definition:</b> <a href="ds1307_8h_source.html#l00079">ds1307.h:80</a></div></div>
</div><!-- fragment --><p>In FastArduino, I2C communication is centralized by an I2C Manager; there are several flavors of I2C Manager defined in FastArduino, with distinct characteristics such as:</p><ul>
<li>synchronous (all MCU) or asynchronous (ATmega only)</li>
<li>I2C mode supported (fast 400kHz or standard 100kHz)</li>
<li>policy to follow in case of failure during an I2C transaction</li>
<li>...</li>
</ul>
<p>I2C devices to connect with must be managed by a dedicated subclass of <a class="el" href="classi2c_1_1_i2_c_device.html" title="Base class for all I2C devices.">i2c::I2CDevice</a>, which provides a specific API for the interfaced device, and handles all communication with an I2C Manager.</p>
<p>For any I2C device subclass, the provided API comes in 2 flavours at a time (whatever I2C Manager is used):</p><ul>
<li><em>asynchronous</em>: the API enqueues a chain of I2C commands for the underlying I2C transaction and lets the I2C Manager handle these commands asynchronously if possible (the I2C Manager must support asynchronous operations); when really handled asynchronously, the API returns immediately, before the actual I2C transaction is performed. Actual results will be returned through a <a class="el" href="classfuture_1_1_future.html" title="Represent a value to be obtained, in some asynchronous way, in the future.">future::Future</a> instance, passed as input argument of the API.</li>
<li><em>synchronous</em>: the API blocks until the complete underlying I2C transaction is complete. This API is implemented based on the asynchronous API above, but simply awaits for the Future result of the I2C transaction.</li>
</ul>
<p>FastArduino defines many specific I2C Manager classes among the following:</p><ul>
<li><a class="el" href="classi2c_1_1_i2_c_async_manager.html" title="Asynchronous I2C Manager for ATmega architecture.">I2CAsyncManager</a>: bare bones asynchronous I2C Manager</li>
<li><a class="el" href="classi2c_1_1_i2_c_async_debug_manager.html" title="Asynchronous I2C Manager for ATmega architecture with debug facility.">I2CAsyncDebugManager</a>: asynchronous I2C Manager with a debug callback hook</li>
<li><a class="el" href="classi2c_1_1_i2_c_async_status_manager.html" title="Asynchronous I2C Manager for ATmega architecture with status notification facility.">I2CAsyncStatusManager</a>: asynchronous I2C Manager with an I2C status callback hook</li>
<li><a class="el" href="classi2c_1_1_i2_c_async_status_debug_manager.html" title="Asynchronous I2C Manager for ATmega architecture with debug and status notification facilities.">I2CAsyncStatusDebugManager</a>: asynchronous I2C Manager with both an I2C status callback hook and a debug callback hook</li>
<li><a class="el" href="classi2c_1_1_i2_c_sync_manager.html" title="Synchronous I2C Manager for ATmega architecture.">I2CSyncManager</a>: bare bones synchronous I2C Manager</li>
<li><a class="el" href="classi2c_1_1_i2_c_sync_debug_manager.html" title="Synchronous I2C Manager for ATmega architecture with debug facility.">I2CSyncDebugManager</a>: synchronous I2C Manager with a debug callback hook</li>
<li><a class="el" href="classi2c_1_1_i2_c_sync_status_manager.html" title="Synchronous I2C Manager for ATmega architecture wit status notification facility.">I2CSyncStatusManager</a>: synchronous I2C Manager with an I2C status callback hook</li>
<li><a class="el" href="classi2c_1_1_i2_c_sync_status_debug_manager.html" title="Synchronous I2C Manager for ATmega architecture with status notification and debug facility.">I2CSyncStatusDebugManager</a>: synchronous I2C Manager with both an I2C status callback hook and a debug callback hook</li>
</ul>
<p>All these classes are template classes with various arguments (the actual list of arguments depends on each specific class):</p><ul>
<li>MODE: <a class="el" href="namespacei2c.html#ac2780f0139dbc26f4d83a426dad67e36" title="I2C available transmission modes.">i2c::I2CMode</a> (bus frequency) supported (fast 400kHz or standard 100kHz)</li>
<li>POLICY: <a class="el" href="namespacei2c.html#a2b806d8952ab67c30889f49248e7fa09" title="I2C Manager policy to use in case of an error during I2C transaction.">i2c::I2CErrorPolicy</a> (behavior in case of an error during a transaction) for asynchronous I2C Managers only</li>
<li>DEBUG_HOOK: the type of callback hook for debug, can be a simple function pointer (type <a class="el" href="namespacei2c.html#a28595eabdfa2ce6a84220d6eb59233e0" title="The default debugging hook type.">i2c::I2C_DEBUG_HOOK</a>) or a more complex functor class</li>
<li>STATUS_HOOK: the type of callback hook for I2C status, can be a simple function pointer (type <a class="el" href="namespacei2c.html#a0d00ac941e250c51b3cde59069e2fbec" title="The default status observer hook type.">i2c::I2C_STATUS_HOOK</a>) or a more complex functor class</li>
</ul>
<p>All these different flavors of I2C Manager share the same API (except for their constructor that may need different arguments).</p>
<p>All I2C Manager asynchronous flavors operate based on a queue of I2C commands. It is up to the end program to create the properly sized buffer for that command queue, before instantiating the relevant asynchronous I2C Manager; the buffer must be passed to the asynchronous I2C Manager constructor. Asynchronous I2C Manager classes will work fine only if the proper ISR function is registered, through one of the 3 provided registration macros. Some of these registration macros also allow registration of a callback hook that will be called for every single I2C step (as defined in ATmega datasheet).</p>
<p>The following snippet shows the minimal code to operate the I2C RTC device DS1307 in synchronous mode: </p><div class="fragment"><div class="line"><span class="comment">// Define type alias for I2C Manager; here we use the simplest possible synchronous manager</span></div>
<div class="line"><span class="keyword">using</span> MANAGER = <a class="code" href="classi2c_1_1_i2_c_sync_manager.html">i2c::I2CSyncManager&lt;i2c::I2CMode::STANDARD&gt;</a>;</div>
<div class="line"><span class="keyword">using</span> RTC = DS1307&lt;MANAGER&gt;;</div>
<div class="line">...</div>
<div class="line"><span class="comment">// Instantiate and start I2C Manager</span></div>
<div class="line">MANAGER manager;</div>
<div class="line">manager.<a class="code" href="classi2c_1_1_abstract_i2_c_sync_manager.html#a1d57efe73e4e8d75bf303f148be8fe1d">begin</a>();</div>
<div class="line"><span class="comment">// Instantiate the DS1307 RTC device</span></div>
<div class="line">RTC rtc{manager};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Call specific DS1307 API to get current date</span></div>
<div class="line">tm now;</div>
<div class="line">rtc.get_datetime(now);</div>
</div><!-- fragment --><p>The next snippet demonstrates how to do the same but in an asynchronous way: </p><div class="fragment"><div class="line"><span class="comment">// Define type alias for I2C Manager; here we use the simplest possible asynchronous manager</span></div>
<div class="line"><span class="keyword">using</span> MANAGER = <a class="code" href="classi2c_1_1_i2_c_async_manager.html">i2c::I2CAsyncManager&lt;i2c::I2CMode::STANDARD&gt;</a>;</div>
<div class="line"><span class="keyword">using</span> RTC = DS1307&lt;MANAGER&gt;;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Define a buffer for the I2C Manager commands queue</span></div>
<div class="line"><span class="keyword">static</span> constexpr uint8_t I2C_BUFFER_SIZE = 32;</div>
<div class="line"><span class="keyword">static</span> MANAGER::I2CCOMMAND i2c_buffer[I2C_BUFFER_SIZE];</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Register I2C ISR to allow asynchronous operation with the I2C Manager</span></div>
<div class="line"><a class="code" href="i2c__handler__atmega_8h.html#a66b761ad07c3eb470ddf58fd6b58594e">REGISTER_I2C_ISR</a>(MANAGER)</div>
<div class="line">...</div>
<div class="line"><span class="comment">// Instantiate and start I2C Manager</span></div>
<div class="line">MANAGER manager{i2c_buffer};</div>
<div class="line">manager.<a class="code" href="classi2c_1_1_abstract_i2_c_sync_manager.html#a1d57efe73e4e8d75bf303f148be8fe1d">begin</a>();</div>
<div class="line"><span class="comment">// Instantiate the DS1307 RTC device</span></div>
<div class="line">RTC rtc{manager};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Prepare Future to receive current date</span></div>
<div class="line">RTC::GetDatetimeFuture <a class="code" href="namespacefuture.html">future</a>;</div>
<div class="line"><span class="comment">// Call specific DS1307 API to get current date</span></div>
<div class="line"><span class="keywordtype">int</span> error = rtc.get_datetime(<a class="code" href="namespacefuture.html">future</a>);</div>
<div class="line"><span class="comment">// Check error here (should be 0)...</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// When needed, get the Future result (await if needed)</span></div>
<div class="line">tm now;</div>
<div class="line"><span class="keywordtype">bool</span> ok = get_date_future.get(now);</div>
<div class="ttc" id="aclassi2c_1_1_i2_c_async_manager_html"><div class="ttname"><a href="classi2c_1_1_i2_c_async_manager.html">i2c::I2CAsyncManager</a></div><div class="ttdoc">Asynchronous I2C Manager for ATmega architecture.</div><div class="ttdef"><b>Definition:</b> <a href="i2c__handler__atmega_8h_source.html#l00765">i2c_handler_atmega.h:767</a></div></div>
<div class="ttc" id="ai2c__handler__atmega_8h_html_a66b761ad07c3eb470ddf58fd6b58594e"><div class="ttname"><a href="i2c__handler__atmega_8h.html#a66b761ad07c3eb470ddf58fd6b58594e">REGISTER_I2C_ISR</a></div><div class="ttdeci">#define REGISTER_I2C_ISR(MANAGER)</div><div class="ttdoc">Register the necessary ISR (Interrupt Service Routine) for an asynchronous I2C Manager to work proper...</div><div class="ttdef"><b>Definition:</b> <a href="i2c__handler__atmega_8h_source.html#l00057">i2c_handler_atmega.h:57</a></div></div>
<div class="ttc" id="anamespacefuture_html"><div class="ttname"><a href="namespacefuture.html">future</a></div><div class="ttdoc">Contains the API around Future implementation.</div><div class="ttdef"><b>Definition:</b> <a href="future_8h_source.html#l00311">future.h:312</a></div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="i2c__handler__atmega_8h.html#a66b761ad07c3eb470ddf58fd6b58594e" title="Register the necessary ISR (Interrupt Service Routine) for an asynchronous I2C Manager to work proper...">REGISTER_I2C_ISR()</a> </dd>
<dd>
<a class="el" href="i2c__handler__atmega_8h.html#a95b6a87c9bbf73a703e8404b676b19e8" title="Register the necessary ISR (Interrupt Service Routine) for an asynchronous I2C Manager to work proper...">REGISTER_I2C_ISR_FUNCTION()</a> </dd>
<dd>
<a class="el" href="i2c__handler__atmega_8h.html#aa88696f074970839a05894dfe0b7527e" title="Register the necessary ISR (Interrupt Service Routine) for an asynchronous I2C Manager to work proper...">REGISTER_I2C_ISR_METHOD()</a> </dd></dl>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a28595eabdfa2ce6a84220d6eb59233e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28595eabdfa2ce6a84220d6eb59233e0">&#9670;&nbsp;</a></span>I2C_DEBUG_HOOK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacei2c.html#a28595eabdfa2ce6a84220d6eb59233e0">i2c::I2C_DEBUG_HOOK</a> = typedef void (*)(<a class="el" href="namespacei2c.html#a2572e0fde7ef325c8f5c1c974c2de720">DebugStatus</a> status, uint8_t data)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The default debugging hook type. </p>
<dl class="section warning"><dt>Warning</dt><dd>Do not use this (function pointer) for your hooks! This will increase code size and ISR delay. Rather use functors as defined in <code><a class="el" href="i2c__debug_8h.html" title="I2C debugging utilities (useful when implementing support for new devices).">i2c_debug.h</a></code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classi2c_1_1_i2_c_sync_debug_manager.html" title="Synchronous I2C Manager for ATmega architecture with debug facility.">I2CSyncDebugManager</a> </dd>
<dd>
<a class="el" href="classi2c_1_1_i2_c_async_debug_manager.html" title="Asynchronous I2C Manager for ATmega architecture with debug facility.">I2CAsyncDebugManager</a> </dd>
<dd>
<a class="el" href="classi2c_1_1debug_1_1_i2_c_debug_recorder.html" title="Class recording I2C debug notifications for later output.">i2c::debug::I2CDebugRecorder</a> </dd>
<dd>
<a class="el" href="classi2c_1_1debug_1_1_i2_c_debug_live_logger.html" title="Class tracing I2C debug notifications live to out.">i2c::debug::I2CDebugLiveLogger</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="i2c__handler__common_8h_source.html#l00082">82</a> of file <a class="el" href="i2c__handler__common_8h_source.html">i2c_handler_common.h</a>.</p>

</div>
</div>
<a id="a0d00ac941e250c51b3cde59069e2fbec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d00ac941e250c51b3cde59069e2fbec">&#9670;&nbsp;</a></span>I2C_STATUS_HOOK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacei2c.html#a0d00ac941e250c51b3cde59069e2fbec">i2c::I2C_STATUS_HOOK</a> = typedef void (*)(<a class="el" href="namespacei2c.html#adb5bfde92afd6cbc048d1ee7472bf394">Status</a> expected, <a class="el" href="namespacei2c.html#adb5bfde92afd6cbc048d1ee7472bf394">Status</a> actual)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The default status observer hook type. </p>
<dl class="section warning"><dt>Warning</dt><dd>Do not use this (function pointer) for your hooks! This will increase code size and ISR delay. Rather use functors as defined in <code><a class="el" href="i2c__status_8h.html" title="I2C status hook utilities.">i2c_status.h</a></code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classi2c_1_1_i2_c_sync_status_manager.html" title="Synchronous I2C Manager for ATmega architecture wit status notification facility.">I2CSyncStatusManager</a> </dd>
<dd>
<a class="el" href="classi2c_1_1_i2_c_async_status_manager.html" title="Asynchronous I2C Manager for ATmega architecture with status notification facility.">I2CAsyncStatusManager</a> </dd>
<dd>
<a class="el" href="classi2c_1_1debug_1_1_i2_c_debug_recorder.html" title="Class recording I2C debug notifications for later output.">i2c::debug::I2CDebugRecorder</a> </dd>
<dd>
<a class="el" href="classi2c_1_1debug_1_1_i2_c_debug_live_logger.html" title="Class tracing I2C debug notifications live to out.">i2c::debug::I2CDebugLiveLogger</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="i2c__handler__common_8h_source.html#l00117">117</a> of file <a class="el" href="i2c__handler__common_8h_source.html">i2c_handler_common.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="adb5bfde92afd6cbc048d1ee7472bf394"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb5bfde92afd6cbc048d1ee7472bf394">&#9670;&nbsp;</a></span>Status</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacei2c.html#adb5bfde92afd6cbc048d1ee7472bf394">i2c::Status</a> : uint8_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transmission status codes. </p>
<p>Transmission status is returned by all <code><a class="el" href="classi2c_1_1_i2_c_device.html" title="Base class for all I2C devices.">i2c::I2CDevice</a></code> read and write methods. This status is also transmitted to an optional hook function for debug purposes.</p>
<p>All codes are defined and directly mapped from ATmega328 datasheet (section 22. "2-wire Serial interface", tables 22-2 and 22-3).</p>
<p>You will probably never need to use these codes in your program.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classi2c_1_1_i2_c_sync_status_manager.html" title="Synchronous I2C Manager for ATmega architecture wit status notification facility.">I2CSyncStatusManager</a> </dd>
<dd>
<a class="el" href="classi2c_1_1_i2_c_async_status_manager.html" title="Asynchronous I2C Manager for ATmega architecture with status notification facility.">I2CAsyncStatusManager</a> </dd>
<dd>
<a class="el" href="namespacei2c_1_1status.html" title="Defines API to ease I2C manager status tracing and debugging.">i2c::status</a> </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="adb5bfde92afd6cbc048d1ee7472bf394ae0aa021e21dddbd6d8cecec71e9cf564"></a>OK&#160;</td><td class="fielddoc"><p>Code indicating the last called method executed as expected without any issue. </p>
</td></tr>
<tr><td class="fieldname"><a id="adb5bfde92afd6cbc048d1ee7472bf394a0f0db442fad97bbaa5d55ef59d4a01d4"></a>START_TRANSMITTED&#160;</td><td class="fielddoc"><p>[Transmitter/Receiver modes] A START condition has been transmitted. </p>
</td></tr>
<tr><td class="fieldname"><a id="adb5bfde92afd6cbc048d1ee7472bf394a2bf969769e65b7f1da7824cd59384d38"></a>REPEAT_START_TRANSMITTED&#160;</td><td class="fielddoc"><p>[Transmitter/Receiver modes] A repeated START condition has been transmitted. </p>
</td></tr>
<tr><td class="fieldname"><a id="adb5bfde92afd6cbc048d1ee7472bf394a4732cb8574071463f6bba0b25d081cd2"></a>SLA_W_TRANSMITTED_ACK&#160;</td><td class="fielddoc"><p>[Transmitter mode] SLA+W has been transmitted; ACK has been received. </p>
</td></tr>
<tr><td class="fieldname"><a id="adb5bfde92afd6cbc048d1ee7472bf394a9f0c8e7e539ae0087ac1bcb9c3fa721d"></a>SLA_W_TRANSMITTED_NACK&#160;</td><td class="fielddoc"><p>[Transmitter mode] SLA+W has been transmitted; NOT ACK has been received. </p>
</td></tr>
<tr><td class="fieldname"><a id="adb5bfde92afd6cbc048d1ee7472bf394a3bc1886a3f635d69d7a3f86c0251e9cd"></a>DATA_TRANSMITTED_ACK&#160;</td><td class="fielddoc"><p>[Transmitter mode] Data byte has been transmitted; ACK has been received. </p>
</td></tr>
<tr><td class="fieldname"><a id="adb5bfde92afd6cbc048d1ee7472bf394a78d1df25360b4e5d4b6e98b85ad1054a"></a>DATA_TRANSMITTED_NACK&#160;</td><td class="fielddoc"><p>[Transmitter mode] Data byte has been transmitted; NOT ACK has been received. </p>
</td></tr>
<tr><td class="fieldname"><a id="adb5bfde92afd6cbc048d1ee7472bf394a1b265dff01af1e30093a5c05a841197c"></a>ARBITRATION_LOST&#160;</td><td class="fielddoc"><p>[Transmitter mode] Abitration lost in SLA+W or data bytes. </p>
<p>[Receiver mode] Abitration lost in SLA+R or NOT ACK bit. </p>
</td></tr>
<tr><td class="fieldname"><a id="adb5bfde92afd6cbc048d1ee7472bf394aba848a7dd2b8595e79d1642ab7f143c1"></a>SLA_R_TRANSMITTED_ACK&#160;</td><td class="fielddoc"><p>[Receiver mode] SLA+R has been transmitted; ACK has been received. </p>
</td></tr>
<tr><td class="fieldname"><a id="adb5bfde92afd6cbc048d1ee7472bf394ab073180fed195e16de9e345d1bbbbedc"></a>SLA_R_TRANSMITTED_NACK&#160;</td><td class="fielddoc"><p>[Receiver mode] SLA+R has been transmitted; NOT ACK has been received. </p>
</td></tr>
<tr><td class="fieldname"><a id="adb5bfde92afd6cbc048d1ee7472bf394a912b7b2e9352cadf9ed4bac50d985ac5"></a>DATA_RECEIVED_ACK&#160;</td><td class="fielddoc"><p>[Receiver mode] Data byte has been transmitted; ACK has been returned. </p>
</td></tr>
<tr><td class="fieldname"><a id="adb5bfde92afd6cbc048d1ee7472bf394aa852f412f97bf4c4dc2d58a53c18db06"></a>DATA_RECEIVED_NACK&#160;</td><td class="fielddoc"><p>[Receiver mode] Data byte has been transmitted; NOT ACK has been returned. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="i2c_8h_source.html#l00066">66</a> of file <a class="el" href="i2c_8h_source.html">i2c.h</a>.</p>

</div>
</div>
<a id="ac2780f0139dbc26f4d83a426dad67e36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2780f0139dbc26f4d83a426dad67e36">&#9670;&nbsp;</a></span>I2CMode</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacei2c.html#ac2780f0139dbc26f4d83a426dad67e36">i2c::I2CMode</a> : uint8_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>I2C available transmission modes. </p>
<p>This defines the maximum bus transmission frequency.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classi2c_1_1_i2_c_sync_manager.html" title="Synchronous I2C Manager for ATmega architecture.">I2CSyncManager</a> </dd>
<dd>
<a class="el" href="classi2c_1_1_i2_c_async_manager.html" title="Asynchronous I2C Manager for ATmega architecture.">I2CAsyncManager</a> </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ac2780f0139dbc26f4d83a426dad67e36a94e94133f4bdc1794c6b647b8ea134d0"></a>STANDARD&#160;</td><td class="fielddoc"><p>I2C Standard mode, less than 100KHz. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac2780f0139dbc26f4d83a426dad67e36adca6e617f6fb54033deb311e7e7c93cc"></a>FAST&#160;</td><td class="fielddoc"><p>I2C Fast mode, less than 400KHz. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="i2c_8h_source.html#l00167">167</a> of file <a class="el" href="i2c_8h_source.html">i2c.h</a>.</p>

</div>
</div>
<a id="a25d59895330a8395962d09a25a3f9f6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25d59895330a8395962d09a25a3f9f6d">&#9670;&nbsp;</a></span>I2CCallback</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacei2c.html#a25d59895330a8395962d09a25a3f9f6d">i2c::I2CCallback</a> : uint8_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Type passed to I2C ISR registered callbacks (asynchronous I2C Manager only) when an asynchronous I2C transaction is executed. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a25d59895330a8395962d09a25a3f9f6dab50339a10e1de285ac99d4c3990b8693"></a>NONE&#160;</td><td class="fielddoc"><p>An I2C command is being processed (intermediate step). </p>
</td></tr>
<tr><td class="fieldname"><a id="a25d59895330a8395962d09a25a3f9f6da711552a437320497067695003417ad61"></a>END_COMMAND&#160;</td><td class="fielddoc"><p>An I2C command has just been finished executed. </p>
</td></tr>
<tr><td class="fieldname"><a id="a25d59895330a8395962d09a25a3f9f6da481bd43bb59f8979a47ca7791b18b050"></a>END_TRANSACTION&#160;</td><td class="fielddoc"><p>The last I2C command in a transaction has just been finished executing. </p>
</td></tr>
<tr><td class="fieldname"><a id="a25d59895330a8395962d09a25a3f9f6dabb1ca97ec761fc37101737ba0aa2e7c5"></a>ERROR&#160;</td><td class="fielddoc"><p>An error has occurred during I2C transaction execution. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="i2c__handler__atmega_8h_source.html#l00118">118</a> of file <a class="el" href="i2c__handler__atmega_8h_source.html">i2c_handler_atmega.h</a>.</p>

</div>
</div>
<a id="a2572e0fde7ef325c8f5c1c974c2de720"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2572e0fde7ef325c8f5c1c974c2de720">&#9670;&nbsp;</a></span>DebugStatus</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacei2c.html#a2572e0fde7ef325c8f5c1c974c2de720">i2c::DebugStatus</a> : uint8_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>List of debug states that are reported by the I2C Manager in debug mode. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classi2c_1_1_i2_c_sync_debug_manager.html" title="Synchronous I2C Manager for ATmega architecture with debug facility.">I2CSyncDebugManager</a> </dd>
<dd>
<a class="el" href="classi2c_1_1_i2_c_async_debug_manager.html" title="Asynchronous I2C Manager for ATmega architecture with debug facility.">I2CAsyncDebugManager</a> </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a2572e0fde7ef325c8f5c1c974c2de720ab078ffd28db767c502ac367053f6e0ac"></a>START&#160;</td><td class="fielddoc"><p>A start condition has just been sent. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2572e0fde7ef325c8f5c1c974c2de720a76b1318f71bfa0c154b487992316b17f"></a>REPEAT_START&#160;</td><td class="fielddoc"><p>A repeat start condition has just been sent. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2572e0fde7ef325c8f5c1c974c2de720acd9fd54f6c2d152e758aaee66257b47a"></a>SLAW&#160;</td><td class="fielddoc"><p>A slave address has just been sent for writing. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2572e0fde7ef325c8f5c1c974c2de720a2ccc467a63546c4af6e4f07ef674e882"></a>SLAR&#160;</td><td class="fielddoc"><p>A slave address has just been sent for reading. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2572e0fde7ef325c8f5c1c974c2de720a548e51fa67d541384e9585adf0db95dc"></a>SEND&#160;</td><td class="fielddoc"><p>A byte has just be sent to the slave. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2572e0fde7ef325c8f5c1c974c2de720ab882f51794befb4d8c136ce9b5e2d6e7"></a>RECV&#160;</td><td class="fielddoc"><p>A byte is being received from the slave. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2572e0fde7ef325c8f5c1c974c2de720a9955c41ad5fc66b5da77307c2c59c255"></a>RECV_LAST&#160;</td><td class="fielddoc"><p>The last byte is being received from the slave. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2572e0fde7ef325c8f5c1c974c2de720a615a46af313786fc4e349f34118be111"></a>STOP&#160;</td><td class="fielddoc"><p>A stop condition has just been sent. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2572e0fde7ef325c8f5c1c974c2de720a25ab30dd6c78e898a233330d0aff4075"></a>SEND_OK&#160;</td><td class="fielddoc"><p>The latest sent byte has been acknowledged by the slave. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2572e0fde7ef325c8f5c1c974c2de720a2722a1c4409a8a5aad2b5467f3cb5b2d"></a>SEND_ERROR&#160;</td><td class="fielddoc"><p>The latest sent byte has not been acknowledged by the slave. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2572e0fde7ef325c8f5c1c974c2de720a351db13aaeaf87c513f33e9f00b3dcb4"></a>RECV_OK&#160;</td><td class="fielddoc"><p>I2C Manager has acknowledged the latest received byte from the slave. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2572e0fde7ef325c8f5c1c974c2de720acbefb7345e20459bf05682fa57a439f9"></a>RECV_ERROR&#160;</td><td class="fielddoc"><p>I2C Manager has not acknowledged the latest received byte from the slave. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="i2c__handler__common_8h_source.html#l00042">42</a> of file <a class="el" href="i2c__handler__common_8h_source.html">i2c_handler_common.h</a>.</p>

</div>
</div>
<a id="a2b806d8952ab67c30889f49248e7fa09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b806d8952ab67c30889f49248e7fa09">&#9670;&nbsp;</a></span>I2CErrorPolicy</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacei2c.html#a2b806d8952ab67c30889f49248e7fa09">i2c::I2CErrorPolicy</a> : uint8_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>I2C Manager policy to use in case of an error during I2C transaction. </p>
<dl class="section warning"><dt>Warning</dt><dd>available only on ATmega MCU. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classi2c_1_1_i2_c_async_manager.html" title="Asynchronous I2C Manager for ATmega architecture.">I2CAsyncManager</a> </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a2b806d8952ab67c30889f49248e7fa09acd6102c4e0e339658526415ee06ad67d"></a>DO_NOTHING&#160;</td><td class="fielddoc"><p>Do nothing at all in case of an error; useful only with a synchronous I2C Manager. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2b806d8952ab67c30889f49248e7fa09a6838e2ec9e1458cb5470fdd5aa8dbb39"></a>CLEAR_ALL_COMMANDS&#160;</td><td class="fielddoc"><p>In case of an error during I2C transaction, then all <a class="el" href="classi2c_1_1_i2_c_command.html" title="Atomic I2C command as used internally by an asynchronous I2C Manager.">I2CCommand</a> currently in queue will be removed. </p>
<dl class="section warning"><dt>Warning</dt><dd>this means that an error with device A can trigger a removal of pending commands for device B. </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="a2b806d8952ab67c30889f49248e7fa09a9767f7913244ec57b19a3adf2fff4030"></a>CLEAR_TRANSACTION_COMMANDS&#160;</td><td class="fielddoc"><p>In case of an error during I2C transaction, then all pending <a class="el" href="classi2c_1_1_i2_c_command.html" title="Atomic I2C command as used internally by an asynchronous I2C Manager.">I2CCommand</a> of the current transaction will be removed. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="i2c__handler__common_8h_source.html#l00146">146</a> of file <a class="el" href="i2c__handler__common_8h_source.html">i2c_handler_common.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a5794e860eddf1016c5eb16ae1c9629bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5794e860eddf1016c5eb16ae1c9629bd">&#9670;&nbsp;</a></span>await_same_future_group()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MANAGER &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool i2c::await_same_future_group </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classi2c_1_1_i2_c_device.html">I2CDevice</a>&lt; MANAGER &gt; &amp;&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper function that creates a <code><a class="el" href="classi2c_1_1_i2_c_same_future_group.html" title="Class to allow dynamic creation of futures from values stored in flash memory, leading to launch of I...">I2CSameFutureGroup</a></code> instance for the provided flash array, launches its I2C transactions on the provided I2C device, and waits for the transaction to finish. </p>
<dl class="section warning"><dt>Warning</dt><dd>Blocking API!</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MANAGER</td><td>the type of I2C Manager used to handle I2C communication </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>the <code><a class="el" href="classi2c_1_1_i2_c_device.html" title="Base class for all I2C devices.">i2c::I2CDevice</a></code> subclass instance that shall handle I2C commands to the I2C device </td></tr>
    <tr><td class="paramname">buffer</td><td>pointer, in flash storage space, to the first byte to write to the I2C device </td></tr>
    <tr><td class="paramname">size</td><td>size in bytes of the <code>buffer</code> array </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if the whole I2C transactions could be completely performed successfully</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classi2c_1_1_i2_c_same_future_group.html" title="Class to allow dynamic creation of futures from values stored in flash memory, leading to launch of I...">I2CSameFutureGroup</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="i2c__device__utilities_8h_source.html#l00823">823</a> of file <a class="el" href="i2c__device__utilities_8h_source.html">i2c_device_utilities.h</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacei2c.html">i2c</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
