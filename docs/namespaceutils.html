<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>FastArduino: utils Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">FastArduino
   </div>
   <div id="projectbrief">C++ library to build fast but small Arduino/AVR projects</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('namespaceutils.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">utils Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Contains all generic utility methods.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a6ba012c3dd675cf1eabcf14e55cea0e0"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutils.html#a6ba012c3dd675cf1eabcf14e55cea0e0">UnitPrefix</a> : int8_t { <br />
&#160;&#160;<b>GIGA</b> = 9, 
<br />
&#160;&#160;<b>MEGA</b> = 6, 
<br />
&#160;&#160;<b>KILO</b> = 3, 
<br />
&#160;&#160;<b>HECTO</b> = 2, 
<br />
&#160;&#160;<b>DECA</b> = 1, 
<br />
&#160;&#160;<b>NONE</b> = 0, 
<br />
&#160;&#160;<b>DECI</b> = -1, 
<br />
&#160;&#160;<b>CENTI</b> = -2, 
<br />
&#160;&#160;<b>MILLI</b> = -3, 
<br />
&#160;&#160;<b>MICRO</b> = -6, 
<br />
&#160;&#160;<b>NANO</b> = -9
<br />
 }<tr class="memdesc:a6ba012c3dd675cf1eabcf14e55cea0e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common prefixes for measurement units.  <a href="namespaceutils.html#a6ba012c3dd675cf1eabcf14e55cea0e0">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a6ba012c3dd675cf1eabcf14e55cea0e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:af1acb8c6f0e6493f88d42b2192e68ba3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af1acb8c6f0e6493f88d42b2192e68ba3"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutils.html#af1acb8c6f0e6493f88d42b2192e68ba3">constrain</a> (T value, T min, T max)</td></tr>
<tr class="memdesc:af1acb8c6f0e6493f88d42b2192e68ba3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constrain <code>value</code> to be greater than or equal to <code>min</code> and lower than or equal to <code>max</code>.  <a href="#af1acb8c6f0e6493f88d42b2192e68ba3">More...</a><br /></td></tr>
<tr class="separator:af1acb8c6f0e6493f88d42b2192e68ba3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a608f8edf36fb4a7c58dd01232e07c0c8"><td class="memTemplParams" colspan="2">template&lt;typename TI , typename TO &gt; </td></tr>
<tr class="memitem:a608f8edf36fb4a7c58dd01232e07c0c8"><td class="memTemplItemLeft" align="right" valign="top">constexpr TO&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutils.html#a608f8edf36fb4a7c58dd01232e07c0c8">map</a> (TI value, TI input_min, TI input_max, TO output_min, TO output_max)</td></tr>
<tr class="memdesc:a608f8edf36fb4a7c58dd01232e07c0c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linearly transform <code>value</code> from range [<code>input_min</code> ; <code>input_max</code>] to range [<code>output_min</code> ; <code>output_max</code>].  <a href="#a608f8edf36fb4a7c58dd01232e07c0c8">More...</a><br /></td></tr>
<tr class="separator:a608f8edf36fb4a7c58dd01232e07c0c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f09c3ac0739c934fa0b975fa827f993"><td class="memItemLeft" align="right" valign="top">constexpr uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutils.html#a1f09c3ac0739c934fa0b975fa827f993">power_of_10</a> (int8_t n)</td></tr>
<tr class="memdesc:a1f09c3ac0739c934fa0b975fa827f993"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate a power of 10 at compile-time, provided that <code>n</code> is a constant at call time.  <a href="#a1f09c3ac0739c934fa0b975fa827f993">More...</a><br /></td></tr>
<tr class="separator:a1f09c3ac0739c934fa0b975fa827f993"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a610e02474f969fc747fa1725b79e252c"><td class="memItemLeft" align="right" valign="top">constexpr int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutils.html#a610e02474f969fc747fa1725b79e252c">map_raw_to_physical</a> (int16_t value, <a class="el" href="namespaceutils.html#a6ba012c3dd675cf1eabcf14e55cea0e0">UnitPrefix</a> prefix, int16_t range, uint8_t precision_bits)</td></tr>
<tr class="memdesc:a610e02474f969fc747fa1725b79e252c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the raw <code>value</code>, obtained from a electronics device, using <code>precision_bit</code> number of bits (that defines the input range) into a physical measure for which <code>range</code> defines the complete output range for such value, adjusted according to the unit <code>prefix</code> that we want in the resulting measure.  <a href="#a610e02474f969fc747fa1725b79e252c">More...</a><br /></td></tr>
<tr class="separator:a610e02474f969fc747fa1725b79e252c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78e8ff3db7671b59028ba873086cfa32"><td class="memItemLeft" align="right" valign="top">constexpr int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutils.html#a78e8ff3db7671b59028ba873086cfa32">map_physical_to_raw</a> (int16_t value, <a class="el" href="namespaceutils.html#a6ba012c3dd675cf1eabcf14e55cea0e0">UnitPrefix</a> prefix, int16_t range, uint8_t precision_bits)</td></tr>
<tr class="memdesc:a78e8ff3db7671b59028ba873086cfa32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an absolute physical <code>value</code>, expressed in some given measurement unit, scaled with <code>prefix</code>, into a raw measurement as if obtained from a electronics device, using <code>precision_bit</code> number of bits (that defines the device raw measure range); for this device, physical measures are within <code>range</code>.  <a href="#a78e8ff3db7671b59028ba873086cfa32">More...</a><br /></td></tr>
<tr class="separator:a78e8ff3db7671b59028ba873086cfa32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d48a47fd601d3b960ce55b26a4d5194"><td class="memItemLeft" align="right" valign="top">constexpr uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutils.html#a9d48a47fd601d3b960ce55b26a4d5194">as_uint16_t</a> (uint8_t high, uint8_t low)</td></tr>
<tr class="memdesc:a9d48a47fd601d3b960ce55b26a4d5194"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert 2 bytes into an unsigned int.  <a href="#a9d48a47fd601d3b960ce55b26a4d5194">More...</a><br /></td></tr>
<tr class="separator:a9d48a47fd601d3b960ce55b26a4d5194"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3525bf2bf63c9f906bc9b952f0d54355"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3525bf2bf63c9f906bc9b952f0d54355"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutils.html#a3525bf2bf63c9f906bc9b952f0d54355">is_zero</a> (T value, T default_value)</td></tr>
<tr class="memdesc:a3525bf2bf63c9f906bc9b952f0d54355"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace <code>value</code> by <code>default_value</code> if not "true" (also known as "Elvis 
operator").  <a href="#a3525bf2bf63c9f906bc9b952f0d54355">More...</a><br /></td></tr>
<tr class="separator:a3525bf2bf63c9f906bc9b952f0d54355"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a983d6f3839652d22e2353e7cfeff63af"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a983d6f3839652d22e2353e7cfeff63af"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutils.html#a983d6f3839652d22e2353e7cfeff63af">set_mask</a> (volatile T &amp;reg, T mask, T value)</td></tr>
<tr class="memdesc:a983d6f3839652d22e2353e7cfeff63af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common utility to force a part of the value of a register, desognated by a bit mask.  <a href="#a983d6f3839652d22e2353e7cfeff63af">More...</a><br /></td></tr>
<tr class="separator:a983d6f3839652d22e2353e7cfeff63af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5b3426ba48caf5ee96ed71fa8b7bb5e"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutils.html#af5b3426ba48caf5ee96ed71fa8b7bb5e">bcd_to_binary</a> (uint8_t bcd)</td></tr>
<tr class="memdesc:af5b3426ba48caf5ee96ed71fa8b7bb5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert Binary-coded decimal byte (each nibble is a digit from 0 to 9) into a natural byte.  <a href="#af5b3426ba48caf5ee96ed71fa8b7bb5e">More...</a><br /></td></tr>
<tr class="separator:af5b3426ba48caf5ee96ed71fa8b7bb5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76076365828136f5178f279fb3c129de"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutils.html#a76076365828136f5178f279fb3c129de">binary_to_bcd</a> (uint8_t binary)</td></tr>
<tr class="memdesc:a76076365828136f5178f279fb3c129de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a natural integers to a BCD byte (2 digits).  <a href="#a76076365828136f5178f279fb3c129de">More...</a><br /></td></tr>
<tr class="separator:a76076365828136f5178f279fb3c129de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53f4a46843c0030ed1388d10c0ad6179"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutils.html#a53f4a46843c0030ed1388d10c0ad6179">swap_bytes</a> (uint16_t &amp;value)</td></tr>
<tr class="memdesc:a53f4a46843c0030ed1388d10c0ad6179"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap 2 bytes of a 2-bytes integer.  <a href="#a53f4a46843c0030ed1388d10c0ad6179">More...</a><br /></td></tr>
<tr class="separator:a53f4a46843c0030ed1388d10c0ad6179"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa520b3da671862f180de0fa3499ae293"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutils.html#aa520b3da671862f180de0fa3499ae293">swap_bytes</a> (int16_t &amp;value)</td></tr>
<tr class="memdesc:aa520b3da671862f180de0fa3499ae293"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap 2 bytes of a 2-bytes integer.  <a href="#aa520b3da671862f180de0fa3499ae293">More...</a><br /></td></tr>
<tr class="separator:aa520b3da671862f180de0fa3499ae293"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8122a1acb9aff2f2cd1d4ae7e1e99ac9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8122a1acb9aff2f2cd1d4ae7e1e99ac9"><td class="memTemplItemLeft" align="right" valign="top">constexpr uint8_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutils.html#a8122a1acb9aff2f2cd1d4ae7e1e99ac9">as_uint8_t</a> (T input)</td></tr>
<tr class="memdesc:a8122a1acb9aff2f2cd1d4ae7e1e99ac9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast a one byte long bit-fields struct into a byte.  <a href="#a8122a1acb9aff2f2cd1d4ae7e1e99ac9">More...</a><br /></td></tr>
<tr class="separator:a8122a1acb9aff2f2cd1d4ae7e1e99ac9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ed4721feb889faa1f72fc2629d71271"><td class="memItemLeft" align="right" valign="top">constexpr uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutils.html#a6ed4721feb889faa1f72fc2629d71271">calculate_delay1_count</a> (float time_us)</td></tr>
<tr class="memdesc:a6ed4721feb889faa1f72fc2629d71271"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the count to pass to <code>delay1()</code> in order to reach <code>time_us</code> microseconds delay.  <a href="#a6ed4721feb889faa1f72fc2629d71271">More...</a><br /></td></tr>
<tr class="separator:a6ed4721feb889faa1f72fc2629d71271"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadb785961c9199701ce9025177b243c6"><td class="memItemLeft" align="right" valign="top"><a id="aadb785961c9199701ce9025177b243c6"></a>
constexpr uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>num_bits</b> (uint8_t mask, uint8_t num=0)</td></tr>
<tr class="separator:aadb785961c9199701ce9025177b243c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Contains all generic utility methods. </p>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a6ba012c3dd675cf1eabcf14e55cea0e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ba012c3dd675cf1eabcf14e55cea0e0">&#9670;&nbsp;</a></span>UnitPrefix</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceutils.html#a6ba012c3dd675cf1eabcf14e55cea0e0">utils::UnitPrefix</a> : int8_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Common prefixes for measurement units. </p>
<p>Used by <code><a class="el" href="namespaceutils.html#a610e02474f969fc747fa1725b79e252c" title="Convert the raw value, obtained from a electronics device, using precision_bit number of bits (that d...">map_raw_to_physical()</a></code> and <code><a class="el" href="namespaceutils.html#a78e8ff3db7671b59028ba873086cfa32" title="Convert an absolute physical value, expressed in some given measurement unit, scaled with prefix...">map_physical_to_raw()</a></code> for units conversion. To avoid large arithmetic calculation, we limit these prefixes to power of 10 that can hold within 32 bits; this is why TERA or PICO are absent. </p>

<p class="definition">Definition at line <a class="el" href="utilities_8h_source.html#l00105">105</a> of file <a class="el" href="utilities_8h_source.html">utilities.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="af1acb8c6f0e6493f88d42b2192e68ba3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1acb8c6f0e6493f88d42b2192e68ba3">&#9670;&nbsp;</a></span>constrain()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr T utils::constrain </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constrain <code>value</code> to be greater than or equal to <code>min</code> and lower than or equal to <code>max</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type of <code>value</code> (must be comparable: int, float...) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the value to constrain </td></tr>
    <tr><td class="paramname">min</td><td>the minimum allowed value </td></tr>
    <tr><td class="paramname">max</td><td>the maximum allowed value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value constrained to be between <code>min</code> and <code>max</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="utilities_8h_source.html#l00071">71</a> of file <a class="el" href="utilities_8h_source.html">utilities.h</a>.</p>

</div>
</div>
<a id="a608f8edf36fb4a7c58dd01232e07c0c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a608f8edf36fb4a7c58dd01232e07c0c8">&#9670;&nbsp;</a></span>map()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TI , typename TO &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr TO utils::map </td>
          <td>(</td>
          <td class="paramtype">TI&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TI&#160;</td>
          <td class="paramname"><em>input_min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TI&#160;</td>
          <td class="paramname"><em>input_max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TO&#160;</td>
          <td class="paramname"><em>output_min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TO&#160;</td>
          <td class="paramname"><em>output_max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Linearly transform <code>value</code> from range [<code>input_min</code> ; <code>input_max</code>] to range [<code>output_min</code> ; <code>output_max</code>]. </p>
<p>Note that the transformed value is not explicitly constrained to range [<code>output_min</code> ; <code>output_max</code>], hence if you want it to be with that range, you should also use <code><a class="el" href="namespaceutils.html#af1acb8c6f0e6493f88d42b2192e68ba3" title="Constrain value to be greater than or equal to min and lower than or equal to max. ">constrain()</a></code> on the returned value.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T0</td><td>the type of the target range and value </td></tr>
    <tr><td class="paramname">T1</td><td>the type of the source range and value </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the value to transform </td></tr>
    <tr><td class="paramname">input_min</td><td>the minimum value of the input range </td></tr>
    <tr><td class="paramname">input_max</td><td>the maximum value of the input range </td></tr>
    <tr><td class="paramname">output_min</td><td>the minimum value of the output range </td></tr>
    <tr><td class="paramname">output_max</td><td>the maximum value of the output range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>transformed <code>value</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="utilities_8h_source.html#l00093">93</a> of file <a class="el" href="utilities_8h_source.html">utilities.h</a>.</p>

</div>
</div>
<a id="a1f09c3ac0739c934fa0b975fa827f993"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f09c3ac0739c934fa0b975fa827f993">&#9670;&nbsp;</a></span>power_of_10()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr uint32_t utils::power_of_10 </td>
          <td>(</td>
          <td class="paramtype">int8_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate a power of 10 at compile-time, provided that <code>n</code> is a constant at call time. </p>
<p>This is to avoid dragging huge mathematics libraries if this can be avoided. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the power of exponent to apply to 10; if negative, then its absolute value is used instead. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>10 ^ |<code>n|</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="utilities_8h_source.html#l00128">128</a> of file <a class="el" href="utilities_8h_source.html">utilities.h</a>.</p>

</div>
</div>
<a id="a610e02474f969fc747fa1725b79e252c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a610e02474f969fc747fa1725b79e252c">&#9670;&nbsp;</a></span>map_raw_to_physical()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int16_t utils::map_raw_to_physical </td>
          <td>(</td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceutils.html#a6ba012c3dd675cf1eabcf14e55cea0e0">UnitPrefix</a>&#160;</td>
          <td class="paramname"><em>prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>precision_bits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert the raw <code>value</code>, obtained from a electronics device, using <code>precision_bit</code> number of bits (that defines the input range) into a physical measure for which <code>range</code> defines the complete output range for such value, adjusted according to the unit <code>prefix</code> that we want in the resulting measure. </p>
<p>This is useful when you need to display real measurement from raw values provided by a sensor. Note however, that in most cases, this method will be evaluated at runtime only, and thus will drag all arithmetic computation libraries. If you need to know the physical measure from a raw value, only to compare it against some constant physical value, then it is preferable to convert the latter, with <code><a class="el" href="namespaceutils.html#a610e02474f969fc747fa1725b79e252c" title="Convert the raw value, obtained from a electronics device, using precision_bit number of bits (that d...">map_raw_to_physical()</a></code> which will be evaluated at compile time, and only compare raw values in your program: that will help decrease code size and improve code speed (no runtime conversions needed).</p>
<div class="fragment"><div class="line"><span class="comment">// This sample code use MPU6050 (accelerometer-gyroscope) support</span></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacedevices_1_1magneto.html">devices::magneto</a>;</div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceutils.html">utils</a>;</div><div class="line"><span class="comment">// These are the accel and gyro ranges used in this code</span></div><div class="line"><span class="keyword">static</span> constexpr <span class="keyword">const</span> GyroRange GYRO_RANGE = GyroRange::RANGE_250;</div><div class="line"><span class="keyword">static</span> constexpr <span class="keyword">const</span> AccelRange ACCEL_RANGE = AccelRange::RANGE_2G;</div><div class="line"></div><div class="line"><span class="comment">// This function converts a raw gyro axis measure into centi-degrees per second</span></div><div class="line"><span class="comment">// so that it can be displayed to an LCD.</span></div><div class="line"><span class="keyword">inline</span> int16_t gyro(int16_t value)</div><div class="line">{</div><div class="line">    <span class="comment">// GYRO_RANGE_DPS calculates the gyro maximum range (in degrees per second)</span></div><div class="line">    <span class="comment">// 15 is the number of bits of precision (on positive range only).</span></div><div class="line">    <span class="keywordflow">return</span> <a class="code" href="namespaceutils.html#a610e02474f969fc747fa1725b79e252c">map_raw_to_physical</a>(value, UnitPrefix::CENTI, GYRO_RANGE_DPS(GYRO_RANGE), 15);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// This function converts a raw accelerometer axis measure into milli-g</span></div><div class="line"><span class="comment">// so that it can be displayed to an LCD.</span></div><div class="line"><span class="keyword">inline</span> int16_t accel(int16_t value)</div><div class="line">{</div><div class="line">    <span class="comment">// ACCEL_RANGE_G calculates the accel maximum range (in g)</span></div><div class="line">    <span class="comment">// 15 is the number of bits of precision (on positive range only).</span></div><div class="line">    <span class="keywordflow">return</span> <a class="code" href="namespaceutils.html#a610e02474f969fc747fa1725b79e252c">map_raw_to_physical</a>(value, UnitPrefix::MILLI, ACCEL_RANGE_G(ACCEL_RANGE), 15);</div><div class="line">}</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the raw value to convert </td></tr>
    <tr><td class="paramname">prefix</td><td>the unit scale prefix to use to compute the physical value </td></tr>
    <tr><td class="paramname">range</td><td>the physical measure matching the maximum raw value </td></tr>
    <tr><td class="paramname">precision_bits</td><td>the number of significant bits of the raw value; only positive values are accounted, hence if a raw measure can be any value in [-32768;+32767], then <code>precision_bits</code> is <code>15</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the physical value calculated from <code>value</code>, scaled according to <code>prefix</code> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceutils.html#a78e8ff3db7671b59028ba873086cfa32" title="Convert an absolute physical value, expressed in some given measurement unit, scaled with prefix...">map_physical_to_raw()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="utilities_8h_source.html#l00187">187</a> of file <a class="el" href="utilities_8h_source.html">utilities.h</a>.</p>

</div>
</div>
<a id="a78e8ff3db7671b59028ba873086cfa32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78e8ff3db7671b59028ba873086cfa32">&#9670;&nbsp;</a></span>map_physical_to_raw()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int16_t utils::map_physical_to_raw </td>
          <td>(</td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceutils.html#a6ba012c3dd675cf1eabcf14e55cea0e0">UnitPrefix</a>&#160;</td>
          <td class="paramname"><em>prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>precision_bits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert an absolute physical <code>value</code>, expressed in some given measurement unit, scaled with <code>prefix</code>, into a raw measurement as if obtained from a electronics device, using <code>precision_bit</code> number of bits (that defines the device raw measure range); for this device, physical measures are within <code>range</code>. </p>
<p>Computations done by this method will be performed at compile-time as long as all provided arguments are constants; this is important as this will help optimize code size and execution time. This is useful when you want to compare physical values against meaningful limits, and perform actions based on these comparisons; instead of always converting measured raw values into physical ones and then compare with a physical limit, you do the opposite, compare the measured raw values against the raw limits (converted, at compile-time, from physical limits constants).</p>
<div class="fragment"><div class="line"><span class="comment">// This sample code use MPU6050 (accelerometer-gyroscope) support</span></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacedevices_1_1magneto.html">devices::magneto</a>;</div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceutils.html">utils</a>;</div><div class="line"><span class="comment">// These is the accelerometer range used in this code</span></div><div class="line"><span class="keyword">static</span> constexpr <span class="keyword">const</span> AccelRange ACCEL_RANGE = AccelRange::RANGE_2G;</div><div class="line"><span class="keyword">static</span> constexpr <span class="keyword">const</span> uint16_t ACCEL_RANGE_IN_G = ACCEL_RANGE_G(ACCEL_RANGE);</div><div class="line"><span class="comment">// These are specific threshold values for acceleration</span></div><div class="line"><span class="keyword">static</span> constexpr <span class="keyword">const</span> int16_t ACCEL_1 = <a class="code" href="namespaceutils.html#a78e8ff3db7671b59028ba873086cfa32">map_physical_to_raw</a>(500, UnitPrefix::MILLI, ACCEL_RANGE_IN_G, 15);</div><div class="line"><span class="keyword">static</span> constexpr <span class="keyword">const</span> int16_t ACCEL_2 = <a class="code" href="namespaceutils.html#a78e8ff3db7671b59028ba873086cfa32">map_physical_to_raw</a>(1000, UnitPrefix::MILLI, ACCEL_RANGE_IN_G, 15);</div><div class="line"></div><div class="line"><span class="comment">// This function performs an action based on current accelerometer value.</span></div><div class="line"><span class="keywordtype">void</span> check_accel(int16_t raw)</div><div class="line">{</div><div class="line">    <span class="comment">// We consider accelerations the same whatever the sign</span></div><div class="line">    <span class="keywordflow">if</span> (raw &lt; 0) raw = -raw;</div><div class="line">    <span class="keywordflow">if</span> (raw &lt; ACCEL_1)</div><div class="line">        act_when_low_accel();</div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (raw &lt; ACCEL_2)</div><div class="line">        act_when_mid_accel();</div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (raw &lt; ACCEL_2)</div><div class="line">        act_when_high_accel();</div><div class="line">}</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the physical value to convert </td></tr>
    <tr><td class="paramname">prefix</td><td>the unit scale prefix in which <code>value</code> is expressed </td></tr>
    <tr><td class="paramname">range</td><td>the physical measure matching the maximum raw value </td></tr>
    <tr><td class="paramname">precision_bits</td><td>the number of significant bits of the raw value; only positive values are accounted, hence if a raw measure can be any value in [-32768;+32767], then <code>precision_bits</code> is <code>15</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the raw value calculated from <code>value</code>, as if directly returned by the device sensor </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceutils.html#a610e02474f969fc747fa1725b79e252c" title="Convert the raw value, obtained from a electronics device, using precision_bit number of bits (that d...">map_raw_to_physical()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="utilities_8h_source.html#l00245">245</a> of file <a class="el" href="utilities_8h_source.html">utilities.h</a>.</p>

</div>
</div>
<a id="a9d48a47fd601d3b960ce55b26a4d5194"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d48a47fd601d3b960ce55b26a4d5194">&#9670;&nbsp;</a></span>as_uint16_t()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr uint16_t utils::as_uint16_t </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>high</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>low</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert 2 bytes into an unsigned int. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">high</td><td>the high byte </td></tr>
    <tr><td class="paramname">low</td><td>the low byte </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the unsigned integer computed from <code>high</code> and <code>low</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="utilities_8h_source.html#l00258">258</a> of file <a class="el" href="utilities_8h_source.html">utilities.h</a>.</p>

</div>
</div>
<a id="a3525bf2bf63c9f906bc9b952f0d54355"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3525bf2bf63c9f906bc9b952f0d54355">&#9670;&nbsp;</a></span>is_zero()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr T utils::is_zero </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>default_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace <code>value</code> by <code>default_value</code> if not "true" (also known as "Elvis 
operator"). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the value to check </td></tr>
    <tr><td class="paramname">default_value</td><td>the value to replace 0 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>value</code> if <code>value</code> is not false (or 0) otherwise <code>default_value</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="utilities_8h_source.html#l00270">270</a> of file <a class="el" href="utilities_8h_source.html">utilities.h</a>.</p>

</div>
</div>
<a id="a983d6f3839652d22e2353e7cfeff63af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a983d6f3839652d22e2353e7cfeff63af">&#9670;&nbsp;</a></span>set_mask()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void utils::set_mask </td>
          <td>(</td>
          <td class="paramtype">volatile T &amp;&#160;</td>
          <td class="paramname"><em>reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Common utility to force a part of the value of a register, desognated by a bit mask. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reg</td><td>the value to change part of </td></tr>
    <tr><td class="paramname">mask</td><td>the bit mask indicating which bits shall change </td></tr>
    <tr><td class="paramname">value</td><td>the new value for <code>reg</code> </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="utilities_8h_source.html#l00282">282</a> of file <a class="el" href="utilities_8h_source.html">utilities.h</a>.</p>

</div>
</div>
<a id="af5b3426ba48caf5ee96ed71fa8b7bb5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5b3426ba48caf5ee96ed71fa8b7bb5e">&#9670;&nbsp;</a></span>bcd_to_binary()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t utils::bcd_to_binary </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bcd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert Binary-coded decimal byte (each nibble is a digit from 0 to 9) into a natural byte. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bcd</td><td>the input using BCD format </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>bcd</code> converted to natural integer </dd></dl>

<p class="definition">Definition at line <a class="el" href="utilities_8h_source.html#l00293">293</a> of file <a class="el" href="utilities_8h_source.html">utilities.h</a>.</p>

</div>
</div>
<a id="a76076365828136f5178f279fb3c129de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76076365828136f5178f279fb3c129de">&#9670;&nbsp;</a></span>binary_to_bcd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t utils::binary_to_bcd </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>binary</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a natural integers to a BCD byte (2 digits). </p>
<p>Behavior is undefined if <code>binary</code> <code>&gt;99</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">binary</td><td>the natural integer value to convert to BCD; must be in range [0..99] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>binary</code> converted to BCD </dd></dl>

<p class="definition">Definition at line <a class="el" href="utilities_8h_source.html#l00307">307</a> of file <a class="el" href="utilities_8h_source.html">utilities.h</a>.</p>

</div>
</div>
<a id="a53f4a46843c0030ed1388d10c0ad6179"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53f4a46843c0030ed1388d10c0ad6179">&#9670;&nbsp;</a></span>swap_bytes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void utils::swap_bytes </td>
          <td>(</td>
          <td class="paramtype">uint16_t &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swap 2 bytes of a 2-bytes integer. </p>
<p>Useful to convert from big-endian to small-endian (AVR). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>value to convert in place (reference) </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="utilities_8h_source.html#l00323">323</a> of file <a class="el" href="utilities_8h_source.html">utilities.h</a>.</p>

</div>
</div>
<a id="aa520b3da671862f180de0fa3499ae293"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa520b3da671862f180de0fa3499ae293">&#9670;&nbsp;</a></span>swap_bytes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void utils::swap_bytes </td>
          <td>(</td>
          <td class="paramtype">int16_t &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swap 2 bytes of a 2-bytes integer. </p>
<p>Useful to convert from big-endian to small-endian (AVR). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>value to convert in place (reference) </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="utilities_8h_source.html#l00333">333</a> of file <a class="el" href="utilities_8h_source.html">utilities.h</a>.</p>

</div>
</div>
<a id="a8122a1acb9aff2f2cd1d4ae7e1e99ac9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8122a1acb9aff2f2cd1d4ae7e1e99ac9">&#9670;&nbsp;</a></span>as_uint8_t()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr uint8_t utils::as_uint8_t </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cast a one byte long bit-fields struct into a byte. </p>
<p>Useful when dealing with devices registers (bytes) where each bit has a specific maening which you want to clarify through a bitfield struct. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the bit field struct value to convert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>input</code> casted as a byte </dd></dl>

<p class="definition">Definition at line <a class="el" href="utilities_8h_source.html#l00357">357</a> of file <a class="el" href="utilities_8h_source.html">utilities.h</a>.</p>

</div>
</div>
<a id="a6ed4721feb889faa1f72fc2629d71271"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ed4721feb889faa1f72fc2629d71271">&#9670;&nbsp;</a></span>calculate_delay1_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr uint8_t utils::calculate_delay1_count </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>time_us</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the count to pass to <code>delay1()</code> in order to reach <code>time_us</code> microseconds delay. </p>
<p>Calculation is performed at compile-time, provided that <code>time_us</code> is a constant when the method is called. This is to avoid dragging huge mathematics libraries if it can be avoided. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">time_us</td><td>the time to reach through <code>delay1()</code> AVR function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the count to pass to <code>delay</code>()` AVR function </dd></dl>

<p class="definition">Definition at line <a class="el" href="utilities_8h_source.html#l00370">370</a> of file <a class="el" href="utilities_8h_source.html">utilities.h</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceutils.html">utils</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
