<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>FastArduino: utils Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">FastArduino<span id="projectnumber">&#160;v1.10</span>
   </div>
   <div id="projectbrief">C++ library to build fast but small Arduino/AVR projects</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('namespaceutils.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">utils Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Contains all generic utility methods.  
<a href="namespaceutils.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutils_1_1range.html">range</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterable class that can embed arrays or initializer lists through implicit conversion.  <a href="classutils_1_1range.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a6ba012c3dd675cf1eabcf14e55cea0e0"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutils.html#a6ba012c3dd675cf1eabcf14e55cea0e0">UnitPrefix</a> : int8_t { <br />
&#160;&#160;<b>GIGA</b> = 9
, <br />
&#160;&#160;<b>MEGA</b> = 6
, <br />
&#160;&#160;<b>KILO</b> = 3
, <br />
&#160;&#160;<b>HECTO</b> = 2
, <br />
&#160;&#160;<b>DECA</b> = 1
, <br />
&#160;&#160;<b>NONE</b> = 0
, <br />
&#160;&#160;<b>DECI</b> = -1
, <br />
&#160;&#160;<b>CENTI</b> = -2
, <br />
&#160;&#160;<b>MILLI</b> = -3
, <br />
&#160;&#160;<b>MICRO</b> = -6
, <br />
&#160;&#160;<b>NANO</b> = -9
<br />
 }</td></tr>
<tr class="memdesc:a6ba012c3dd675cf1eabcf14e55cea0e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common prefixes for measurement units.  <a href="namespaceutils.html#a6ba012c3dd675cf1eabcf14e55cea0e0">More...</a><br /></td></tr>
<tr class="separator:a6ba012c3dd675cf1eabcf14e55cea0e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:af1acb8c6f0e6493f88d42b2192e68ba3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af1acb8c6f0e6493f88d42b2192e68ba3"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutils.html#af1acb8c6f0e6493f88d42b2192e68ba3">constrain</a> (T value, T <a class="el" href="namespaceutils.html#a13c5a184562f144148035716f457fee4">min</a>, T <a class="el" href="namespaceutils.html#a2f939dc5a7bd4bf757171fb26b6bd4df">max</a>)</td></tr>
<tr class="memdesc:af1acb8c6f0e6493f88d42b2192e68ba3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constrain <code>value</code> to be greater than or equal to <code>min</code> and lower than or equal to <code>max</code>.  <a href="namespaceutils.html#af1acb8c6f0e6493f88d42b2192e68ba3">More...</a><br /></td></tr>
<tr class="separator:af1acb8c6f0e6493f88d42b2192e68ba3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a608f8edf36fb4a7c58dd01232e07c0c8"><td class="memTemplParams" colspan="2">template&lt;typename TI , typename TO &gt; </td></tr>
<tr class="memitem:a608f8edf36fb4a7c58dd01232e07c0c8"><td class="memTemplItemLeft" align="right" valign="top">constexpr TO&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutils.html#a608f8edf36fb4a7c58dd01232e07c0c8">map</a> (TI value, TI input_min, TI input_max, TO output_min, TO output_max)</td></tr>
<tr class="memdesc:a608f8edf36fb4a7c58dd01232e07c0c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linearly transform <code>value</code> from range [<code>input_min</code> ; <code>input_max</code>] to range [<code>output_min</code> ; <code>output_max</code>].  <a href="namespaceutils.html#a608f8edf36fb4a7c58dd01232e07c0c8">More...</a><br /></td></tr>
<tr class="separator:a608f8edf36fb4a7c58dd01232e07c0c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13c5a184562f144148035716f457fee4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a13c5a184562f144148035716f457fee4"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutils.html#a13c5a184562f144148035716f457fee4">min</a> (T a, T b)</td></tr>
<tr class="memdesc:a13c5a184562f144148035716f457fee4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the min of 2 integral values.  <a href="namespaceutils.html#a13c5a184562f144148035716f457fee4">More...</a><br /></td></tr>
<tr class="separator:a13c5a184562f144148035716f457fee4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f939dc5a7bd4bf757171fb26b6bd4df"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2f939dc5a7bd4bf757171fb26b6bd4df"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutils.html#a2f939dc5a7bd4bf757171fb26b6bd4df">max</a> (T a, T b)</td></tr>
<tr class="memdesc:a2f939dc5a7bd4bf757171fb26b6bd4df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the max of 2 integral values.  <a href="namespaceutils.html#a2f939dc5a7bd4bf757171fb26b6bd4df">More...</a><br /></td></tr>
<tr class="separator:a2f939dc5a7bd4bf757171fb26b6bd4df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f09c3ac0739c934fa0b975fa827f993"><td class="memItemLeft" align="right" valign="top">constexpr uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutils.html#a1f09c3ac0739c934fa0b975fa827f993">power_of_10</a> (int8_t n)</td></tr>
<tr class="memdesc:a1f09c3ac0739c934fa0b975fa827f993"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate a power of 10 at compile-time, provided that <code>n</code> is a constant at call time.  <a href="namespaceutils.html#a1f09c3ac0739c934fa0b975fa827f993">More...</a><br /></td></tr>
<tr class="separator:a1f09c3ac0739c934fa0b975fa827f993"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a610e02474f969fc747fa1725b79e252c"><td class="memItemLeft" align="right" valign="top">constexpr int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutils.html#a610e02474f969fc747fa1725b79e252c">map_raw_to_physical</a> (int16_t value, <a class="el" href="namespaceutils.html#a6ba012c3dd675cf1eabcf14e55cea0e0">UnitPrefix</a> prefix, int16_t <a class="el" href="classutils_1_1range.html">range</a>, uint8_t precision_bits)</td></tr>
<tr class="memdesc:a610e02474f969fc747fa1725b79e252c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the raw <code>value</code>, obtained from an electronics device, using <code>precision_bit</code> number of bits (that defines the input range) into a physical measure for which <code>range</code> defines the complete output range for such value, adjusted according to the unit <code>prefix</code> that we want in the resulting measure.  <a href="namespaceutils.html#a610e02474f969fc747fa1725b79e252c">More...</a><br /></td></tr>
<tr class="separator:a610e02474f969fc747fa1725b79e252c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78e8ff3db7671b59028ba873086cfa32"><td class="memItemLeft" align="right" valign="top">constexpr int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutils.html#a78e8ff3db7671b59028ba873086cfa32">map_physical_to_raw</a> (int16_t value, <a class="el" href="namespaceutils.html#a6ba012c3dd675cf1eabcf14e55cea0e0">UnitPrefix</a> prefix, int16_t <a class="el" href="classutils_1_1range.html">range</a>, uint8_t precision_bits)</td></tr>
<tr class="memdesc:a78e8ff3db7671b59028ba873086cfa32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an absolute physical <code>value</code>, expressed in some given measurement unit, scaled with <code>prefix</code>, into a raw measurement as if obtained from a electronics device, using <code>precision_bit</code> number of bits (that defines the device raw measure range); for this device, physical measures are within <code>range</code>.  <a href="namespaceutils.html#a78e8ff3db7671b59028ba873086cfa32">More...</a><br /></td></tr>
<tr class="separator:a78e8ff3db7671b59028ba873086cfa32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5f19301125b8e9dc9e89ea50da962fa"><td class="memItemLeft" align="right" valign="top">constexpr uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutils.html#ad5f19301125b8e9dc9e89ea50da962fa">low_byte</a> (uint16_t word)</td></tr>
<tr class="memdesc:ad5f19301125b8e9dc9e89ea50da962fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the low order byte of a 16-bits word.  <a href="namespaceutils.html#ad5f19301125b8e9dc9e89ea50da962fa">More...</a><br /></td></tr>
<tr class="separator:ad5f19301125b8e9dc9e89ea50da962fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84e5a79013cf3cf3c46a09b2c4861d37"><td class="memItemLeft" align="right" valign="top">constexpr uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutils.html#a84e5a79013cf3cf3c46a09b2c4861d37">high_byte</a> (uint16_t word)</td></tr>
<tr class="memdesc:a84e5a79013cf3cf3c46a09b2c4861d37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the high order byte of a 16-bits word.  <a href="namespaceutils.html#a84e5a79013cf3cf3c46a09b2c4861d37">More...</a><br /></td></tr>
<tr class="separator:a84e5a79013cf3cf3c46a09b2c4861d37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d48a47fd601d3b960ce55b26a4d5194"><td class="memItemLeft" align="right" valign="top">constexpr uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutils.html#a9d48a47fd601d3b960ce55b26a4d5194">as_uint16_t</a> (uint8_t high, uint8_t low)</td></tr>
<tr class="memdesc:a9d48a47fd601d3b960ce55b26a4d5194"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert 2 bytes into an unsigned int.  <a href="namespaceutils.html#a9d48a47fd601d3b960ce55b26a4d5194">More...</a><br /></td></tr>
<tr class="separator:a9d48a47fd601d3b960ce55b26a4d5194"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3525bf2bf63c9f906bc9b952f0d54355"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3525bf2bf63c9f906bc9b952f0d54355"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutils.html#a3525bf2bf63c9f906bc9b952f0d54355">is_zero</a> (T value, T default_value)</td></tr>
<tr class="memdesc:a3525bf2bf63c9f906bc9b952f0d54355"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace <code>value</code> by <code>default_value</code> if not "true" (also known as "Elvis 
operator").  <a href="namespaceutils.html#a3525bf2bf63c9f906bc9b952f0d54355">More...</a><br /></td></tr>
<tr class="separator:a3525bf2bf63c9f906bc9b952f0d54355"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a983d6f3839652d22e2353e7cfeff63af"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a983d6f3839652d22e2353e7cfeff63af"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutils.html#a983d6f3839652d22e2353e7cfeff63af">set_mask</a> (volatile T &amp;reg, T mask, T value)</td></tr>
<tr class="memdesc:a983d6f3839652d22e2353e7cfeff63af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common utility to force a part of the value of a register, designated by a bit mask.  <a href="namespaceutils.html#a983d6f3839652d22e2353e7cfeff63af">More...</a><br /></td></tr>
<tr class="separator:a983d6f3839652d22e2353e7cfeff63af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a719f3f44a5cf8093953fbb97486bbee9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a719f3f44a5cf8093953fbb97486bbee9"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutils.html#a719f3f44a5cf8093953fbb97486bbee9">is_mask_equal</a> (T actual, T mask, T expected)</td></tr>
<tr class="memdesc:a719f3f44a5cf8093953fbb97486bbee9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common utility to check if 2 values are equal according to a mask.  <a href="namespaceutils.html#a719f3f44a5cf8093953fbb97486bbee9">More...</a><br /></td></tr>
<tr class="separator:a719f3f44a5cf8093953fbb97486bbee9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5b3426ba48caf5ee96ed71fa8b7bb5e"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutils.html#af5b3426ba48caf5ee96ed71fa8b7bb5e">bcd_to_binary</a> (uint8_t bcd)</td></tr>
<tr class="memdesc:af5b3426ba48caf5ee96ed71fa8b7bb5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert Binary-coded decimal byte (each nibble is a digit from 0 to 9) into a natural byte.  <a href="namespaceutils.html#af5b3426ba48caf5ee96ed71fa8b7bb5e">More...</a><br /></td></tr>
<tr class="separator:af5b3426ba48caf5ee96ed71fa8b7bb5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76076365828136f5178f279fb3c129de"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutils.html#a76076365828136f5178f279fb3c129de">binary_to_bcd</a> (uint8_t binary)</td></tr>
<tr class="memdesc:a76076365828136f5178f279fb3c129de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a natural integers to a BCD byte (2 digits).  <a href="namespaceutils.html#a76076365828136f5178f279fb3c129de">More...</a><br /></td></tr>
<tr class="separator:a76076365828136f5178f279fb3c129de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53f4a46843c0030ed1388d10c0ad6179"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutils.html#a53f4a46843c0030ed1388d10c0ad6179">swap_bytes</a> (uint16_t &amp;value)</td></tr>
<tr class="memdesc:a53f4a46843c0030ed1388d10c0ad6179"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap 2 bytes of a 2-bytes integer.  <a href="namespaceutils.html#a53f4a46843c0030ed1388d10c0ad6179">More...</a><br /></td></tr>
<tr class="separator:a53f4a46843c0030ed1388d10c0ad6179"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa520b3da671862f180de0fa3499ae293"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutils.html#aa520b3da671862f180de0fa3499ae293">swap_bytes</a> (int16_t &amp;value)</td></tr>
<tr class="memdesc:aa520b3da671862f180de0fa3499ae293"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap 2 bytes of a 2-bytes integer.  <a href="namespaceutils.html#aa520b3da671862f180de0fa3499ae293">More...</a><br /></td></tr>
<tr class="separator:aa520b3da671862f180de0fa3499ae293"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25cf0b4e16f41600e112ba90f41c2e1f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutils.html#a25cf0b4e16f41600e112ba90f41c2e1f">swap_bytes</a> (uint32_t &amp;value)</td></tr>
<tr class="memdesc:a25cf0b4e16f41600e112ba90f41c2e1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse 4 bytes of a 4-bytes integer.  <a href="namespaceutils.html#a25cf0b4e16f41600e112ba90f41c2e1f">More...</a><br /></td></tr>
<tr class="separator:a25cf0b4e16f41600e112ba90f41c2e1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa14a9a9958ae56f2a8d63ec2a0591cf9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutils.html#aa14a9a9958ae56f2a8d63ec2a0591cf9">swap_bytes</a> (int32_t &amp;value)</td></tr>
<tr class="memdesc:aa14a9a9958ae56f2a8d63ec2a0591cf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse 4 bytes of a 4-bytes integer.  <a href="namespaceutils.html#aa14a9a9958ae56f2a8d63ec2a0591cf9">More...</a><br /></td></tr>
<tr class="separator:aa14a9a9958ae56f2a8d63ec2a0591cf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad646807311bd7bcd02d6af12e3b51934"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutils.html#ad646807311bd7bcd02d6af12e3b51934">swap_bytes</a> (uint64_t &amp;value)</td></tr>
<tr class="memdesc:ad646807311bd7bcd02d6af12e3b51934"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse 8 bytes of a 8-bytes integer.  <a href="namespaceutils.html#ad646807311bd7bcd02d6af12e3b51934">More...</a><br /></td></tr>
<tr class="separator:ad646807311bd7bcd02d6af12e3b51934"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafea56db3de82001ff9c5e40f8357ab6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutils.html#aafea56db3de82001ff9c5e40f8357ab6">swap_bytes</a> (int64_t &amp;value)</td></tr>
<tr class="memdesc:aafea56db3de82001ff9c5e40f8357ab6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse 8 bytes of a 8-bytes integer.  <a href="namespaceutils.html#aafea56db3de82001ff9c5e40f8357ab6">More...</a><br /></td></tr>
<tr class="separator:aafea56db3de82001ff9c5e40f8357ab6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b22c789724a654df1a1efba8b3b6083"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4b22c789724a654df1a1efba8b3b6083"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutils.html#a4b22c789724a654df1a1efba8b3b6083">swap</a> (T &amp;a, T &amp;b)</td></tr>
<tr class="memdesc:a4b22c789724a654df1a1efba8b3b6083"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap the values of 2 variables passed by reference.  <a href="namespaceutils.html#a4b22c789724a654df1a1efba8b3b6083">More...</a><br /></td></tr>
<tr class="separator:a4b22c789724a654df1a1efba8b3b6083"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8122a1acb9aff2f2cd1d4ae7e1e99ac9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8122a1acb9aff2f2cd1d4ae7e1e99ac9"><td class="memTemplItemLeft" align="right" valign="top">constexpr uint8_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutils.html#a8122a1acb9aff2f2cd1d4ae7e1e99ac9">as_uint8_t</a> (T input)</td></tr>
<tr class="memdesc:a8122a1acb9aff2f2cd1d4ae7e1e99ac9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast a one byte long bit-fields struct into a byte.  <a href="namespaceutils.html#a8122a1acb9aff2f2cd1d4ae7e1e99ac9">More...</a><br /></td></tr>
<tr class="separator:a8122a1acb9aff2f2cd1d4ae7e1e99ac9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56da5697e356f76ec2e4061279ca0254"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U  = uint8_t[sizeof(T)]&gt; </td></tr>
<tr class="memitem:a56da5697e356f76ec2e4061279ca0254"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutils.html#a56da5697e356f76ec2e4061279ca0254">as_array</a> (const T &amp;input, U output)</td></tr>
<tr class="memdesc:a56da5697e356f76ec2e4061279ca0254"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast an instance of type <code>T</code> to an array of <code>uint8_t</code> of the size of <code>T</code>.  <a href="namespaceutils.html#a56da5697e356f76ec2e4061279ca0254">More...</a><br /></td></tr>
<tr class="separator:a56da5697e356f76ec2e4061279ca0254"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ed4721feb889faa1f72fc2629d71271"><td class="memItemLeft" align="right" valign="top">constexpr uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutils.html#a6ed4721feb889faa1f72fc2629d71271">calculate_delay1_count</a> (float time_us)</td></tr>
<tr class="memdesc:a6ed4721feb889faa1f72fc2629d71271"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the count to pass to <code>delay1()</code> in order to reach <code>time_us</code> microseconds delay.  <a href="namespaceutils.html#a6ed4721feb889faa1f72fc2629d71271">More...</a><br /></td></tr>
<tr class="separator:a6ed4721feb889faa1f72fc2629d71271"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadb785961c9199701ce9025177b243c6"><td class="memItemLeft" align="right" valign="top">constexpr uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutils.html#aadb785961c9199701ce9025177b243c6">num_bits</a> (uint8_t mask, uint8_t num=0)</td></tr>
<tr class="memdesc:aadb785961c9199701ce9025177b243c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the number of <code>1</code> bits in a byte.  <a href="namespaceutils.html#aadb785961c9199701ce9025177b243c6">More...</a><br /></td></tr>
<tr class="separator:aadb785961c9199701ce9025177b243c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a233bddd8743dd54547e9b36c1e58ef2f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a233bddd8743dd54547e9b36c1e58ef2f"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutils.html#a233bddd8743dd54547e9b36c1e58ef2f">change_endianness</a> (const T &amp;value)</td></tr>
<tr class="memdesc:a233bddd8743dd54547e9b36c1e58ef2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change endianness of any integral type (from big to small or small to big).  <a href="namespaceutils.html#a233bddd8743dd54547e9b36c1e58ef2f">More...</a><br /></td></tr>
<tr class="separator:a233bddd8743dd54547e9b36c1e58ef2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Contains all generic utility methods. </p>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a6ba012c3dd675cf1eabcf14e55cea0e0" name="a6ba012c3dd675cf1eabcf14e55cea0e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ba012c3dd675cf1eabcf14e55cea0e0">&#9670;&#160;</a></span>UnitPrefix</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="namespaceutils.html#a6ba012c3dd675cf1eabcf14e55cea0e0">utils::UnitPrefix</a> : int8_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Common prefixes for measurement units. </p>
<p >Used by <code><a class="el" href="namespaceutils.html#a610e02474f969fc747fa1725b79e252c" title="Convert the raw value, obtained from an electronics device, using precision_bit number of bits (that ...">map_raw_to_physical()</a></code> and <code><a class="el" href="namespaceutils.html#a78e8ff3db7671b59028ba873086cfa32" title="Convert an absolute physical value, expressed in some given measurement unit, scaled with prefix,...">map_physical_to_raw()</a></code> for units conversion. To avoid large arithmetic calculation, we limit these prefixes to power of 10 that can hold within 32 bits; this is why TERA or PICO are absent. </p>

<p class="definition">Definition at line <a class="el" href="utilities_8h_source.html#l00101">101</a> of file <a class="el" href="utilities_8h_source.html">utilities.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="af1acb8c6f0e6493f88d42b2192e68ba3" name="af1acb8c6f0e6493f88d42b2192e68ba3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1acb8c6f0e6493f88d42b2192e68ba3">&#9670;&#160;</a></span>constrain()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T utils::constrain </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constrain <code>value</code> to be greater than or equal to <code>min</code> and lower than or equal to <code>max</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type of <code>value</code> (must be comparable: int, float...) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the value to constrain </td></tr>
    <tr><td class="paramname">min</td><td>the minimum allowed value </td></tr>
    <tr><td class="paramname">max</td><td>the maximum allowed value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value constrained to be between <code>min</code> and <code>max</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="utilities_8h_source.html#l00062">62</a> of file <a class="el" href="utilities_8h_source.html">utilities.h</a>.</p>

</div>
</div>
<a id="a608f8edf36fb4a7c58dd01232e07c0c8" name="a608f8edf36fb4a7c58dd01232e07c0c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a608f8edf36fb4a7c58dd01232e07c0c8">&#9670;&#160;</a></span>map()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TI , typename TO &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr TO utils::map </td>
          <td>(</td>
          <td class="paramtype">TI&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TI&#160;</td>
          <td class="paramname"><em>input_min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TI&#160;</td>
          <td class="paramname"><em>input_max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TO&#160;</td>
          <td class="paramname"><em>output_min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TO&#160;</td>
          <td class="paramname"><em>output_max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Linearly transform <code>value</code> from range [<code>input_min</code> ; <code>input_max</code>] to range [<code>output_min</code> ; <code>output_max</code>]. </p>
<p >Note that the transformed value is not explicitly constrained to range [<code>output_min</code> ; <code>output_max</code>], hence if you want it to be with that range, you should also use <code><a class="el" href="namespaceutils.html#af1acb8c6f0e6493f88d42b2192e68ba3" title="Constrain value to be greater than or equal to min and lower than or equal to max.">constrain()</a></code> on the returned value.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T0</td><td>the type of the target range and value </td></tr>
    <tr><td class="paramname">T1</td><td>the type of the source range and value </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the value to transform </td></tr>
    <tr><td class="paramname">input_min</td><td>the minimum value of the input range </td></tr>
    <tr><td class="paramname">input_max</td><td>the maximum value of the input range </td></tr>
    <tr><td class="paramname">output_min</td><td>the minimum value of the output range </td></tr>
    <tr><td class="paramname">output_max</td><td>the maximum value of the output range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>transformed <code>value</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="utilities_8h_source.html#l00089">89</a> of file <a class="el" href="utilities_8h_source.html">utilities.h</a>.</p>

</div>
</div>
<a id="a13c5a184562f144148035716f457fee4" name="a13c5a184562f144148035716f457fee4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13c5a184562f144148035716f457fee4">&#9670;&#160;</a></span>min()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T utils::min </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the min of 2 integral values. </p>
<p >Computations done by this method will be performed at compile-time as long as all provided arguments are constants; this is important as this will help optimize code size and execution time.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type of values to be compared </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>first value </td></tr>
    <tr><td class="paramname">b</td><td>second value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>constexpr T the minimum of <code>a</code> and <code>b</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="utilities_8h_source.html#l00127">127</a> of file <a class="el" href="utilities_8h_source.html">utilities.h</a>.</p>

</div>
</div>
<a id="a2f939dc5a7bd4bf757171fb26b6bd4df" name="a2f939dc5a7bd4bf757171fb26b6bd4df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f939dc5a7bd4bf757171fb26b6bd4df">&#9670;&#160;</a></span>max()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T utils::max </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the max of 2 integral values. </p>
<p >Computations done by this method will be performed at compile-time as long as all provided arguments are constants; this is important as this will help optimize code size and execution time.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type of values to be compared </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>first value </td></tr>
    <tr><td class="paramname">b</td><td>second value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>constexpr T the maximum of <code>a</code> and <code>b</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="utilities_8h_source.html#l00143">143</a> of file <a class="el" href="utilities_8h_source.html">utilities.h</a>.</p>

</div>
</div>
<a id="a1f09c3ac0739c934fa0b975fa827f993" name="a1f09c3ac0739c934fa0b975fa827f993"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f09c3ac0739c934fa0b975fa827f993">&#9670;&#160;</a></span>power_of_10()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr uint32_t utils::power_of_10 </td>
          <td>(</td>
          <td class="paramtype">int8_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate a power of 10 at compile-time, provided that <code>n</code> is a constant at call time. </p>
<p >This is to avoid dragging huge mathematics libraries if this can be avoided. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the power of exponent to apply to 10; if negative, then its absolute value is used instead. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>10 ^ |<code>n|</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="utilities_8h_source.html#l00156">156</a> of file <a class="el" href="utilities_8h_source.html">utilities.h</a>.</p>

</div>
</div>
<a id="a610e02474f969fc747fa1725b79e252c" name="a610e02474f969fc747fa1725b79e252c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a610e02474f969fc747fa1725b79e252c">&#9670;&#160;</a></span>map_raw_to_physical()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int16_t utils::map_raw_to_physical </td>
          <td>(</td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceutils.html#a6ba012c3dd675cf1eabcf14e55cea0e0">UnitPrefix</a>&#160;</td>
          <td class="paramname"><em>prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>precision_bits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert the raw <code>value</code>, obtained from an electronics device, using <code>precision_bit</code> number of bits (that defines the input range) into a physical measure for which <code>range</code> defines the complete output range for such value, adjusted according to the unit <code>prefix</code> that we want in the resulting measure. </p>
<p >This is useful when you need to display real measurement from raw values provided by a sensor. Note however, that in most cases, this method will be evaluated at runtime only, and thus will drag all arithmetic computation libraries. If you need to know the physical measure from a raw value, only to compare it against some constant physical value, then it is preferable to convert the latter, with <code><a class="el" href="namespaceutils.html#a610e02474f969fc747fa1725b79e252c" title="Convert the raw value, obtained from an electronics device, using precision_bit number of bits (that ...">map_raw_to_physical()</a></code> which will be evaluated at compile time, and only compare raw values in your program: that will help decrease code size and improve code speed (no runtime conversions needed).</p>
<div class="fragment"><div class="line"><span class="comment">// This sample code use MPU6050 (accelerometer-gyroscope) support</span></div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacedevices_1_1magneto.html">devices::magneto</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespaceutils.html">utils</a>;</div>
<div class="line"><span class="comment">// These are the accel and gyro ranges used in this code</span></div>
<div class="line"><span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">const</span> <a class="code hl_enumeration" href="namespacedevices_1_1magneto.html#af1ab54980b0620a7f3c95ff2318604f4">GyroRange</a> GYRO_RANGE = GyroRange::RANGE_250;</div>
<div class="line"><span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">const</span> <a class="code hl_enumeration" href="namespacedevices_1_1magneto.html#a293a7ee50fc4bbf24e89858a328e1775">AccelRange</a> ACCEL_RANGE = AccelRange::RANGE_2G;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This function converts a raw gyro axis measure into centi-degrees per second</span></div>
<div class="line"><span class="comment">// so that it can be displayed to an LCD.</span></div>
<div class="line"><span class="keyword">inline</span> int16_t gyro(int16_t value)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// GYRO_RANGE_DPS calculates the gyro maximum range (in degrees per second)</span></div>
<div class="line">    <span class="comment">// 15 is the number of bits of precision (on positive range only).</span></div>
<div class="line">    <span class="keywordflow">return</span> <a class="code hl_function" href="namespaceutils.html#a610e02474f969fc747fa1725b79e252c">map_raw_to_physical</a>(value, UnitPrefix::CENTI, GYRO_RANGE_DPS(GYRO_RANGE), 15);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This function converts a raw accelerometer axis measure into milli-g</span></div>
<div class="line"><span class="comment">// so that it can be displayed to an LCD.</span></div>
<div class="line"><span class="keyword">inline</span> int16_t accel(int16_t value)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// ACCEL_RANGE_G calculates the accel maximum range (in g)</span></div>
<div class="line">    <span class="comment">// 15 is the number of bits of precision (on positive range only).</span></div>
<div class="line">    <span class="keywordflow">return</span> <a class="code hl_function" href="namespaceutils.html#a610e02474f969fc747fa1725b79e252c">map_raw_to_physical</a>(value, UnitPrefix::MILLI, ACCEL_RANGE_G(ACCEL_RANGE), 15);</div>
<div class="line">}</div>
<div class="ttc" id="anamespacedevices_1_1magneto_html"><div class="ttname"><a href="namespacedevices_1_1magneto.html">devices::magneto</a></div><div class="ttdoc">Defines API for magnetic sensors for direction, speed and acceleration properties.</div><div class="ttdef"><b>Definition:</b> <a href="common__magneto_8h_source.html#l00031">common_magneto.h:32</a></div></div>
<div class="ttc" id="anamespacedevices_1_1magneto_html_a293a7ee50fc4bbf24e89858a328e1775"><div class="ttname"><a href="namespacedevices_1_1magneto.html#a293a7ee50fc4bbf24e89858a328e1775">devices::magneto::AccelRange</a></div><div class="ttdeci">AccelRange</div><div class="ttdoc">The full-scale range of the accelerometer in g (datasheet ยง6.2).</div><div class="ttdef"><b>Definition:</b> <a href="mpu6050_8h_source.html#l00070">mpu6050.h:71</a></div></div>
<div class="ttc" id="anamespacedevices_1_1magneto_html_af1ab54980b0620a7f3c95ff2318604f4"><div class="ttname"><a href="namespacedevices_1_1magneto.html#af1ab54980b0620a7f3c95ff2318604f4">devices::magneto::GyroRange</a></div><div class="ttdeci">GyroRange</div><div class="ttdoc">The full-scale range of the gyroscope in dps (datasheet ยง6.1).</div><div class="ttdef"><b>Definition:</b> <a href="mpu6050_8h_source.html#l00045">mpu6050.h:46</a></div></div>
<div class="ttc" id="anamespaceutils_html"><div class="ttname"><a href="namespaceutils.html">utils</a></div><div class="ttdoc">Contains all generic utility methods.</div><div class="ttdef"><b>Definition:</b> <a href="iterator_8h_source.html#l00028">iterator.h:29</a></div></div>
<div class="ttc" id="anamespaceutils_html_a610e02474f969fc747fa1725b79e252c"><div class="ttname"><a href="namespaceutils.html#a610e02474f969fc747fa1725b79e252c">utils::map_raw_to_physical</a></div><div class="ttdeci">constexpr int16_t map_raw_to_physical(int16_t value, UnitPrefix prefix, int16_t range, uint8_t precision_bits)</div><div class="ttdoc">Convert the raw value, obtained from an electronics device, using precision_bit number of bits (that ...</div><div class="ttdef"><b>Definition:</b> <a href="utilities_8h_source.html#l00219">utilities.h:219</a></div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the raw value to convert </td></tr>
    <tr><td class="paramname">prefix</td><td>the unit scale prefix to use to compute the physical value </td></tr>
    <tr><td class="paramname">range</td><td>the physical measure matching the maximum raw value </td></tr>
    <tr><td class="paramname">precision_bits</td><td>the number of significant bits of the raw value; only positive values are accounted, hence if a raw measure can be any value in [-32768;+32767], then <code>precision_bits</code> is <code>15</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the physical value calculated from <code>value</code>, scaled according to <code>prefix</code> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceutils.html#a78e8ff3db7671b59028ba873086cfa32" title="Convert an absolute physical value, expressed in some given measurement unit, scaled with prefix,...">map_physical_to_raw()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="utilities_8h_source.html#l00219">219</a> of file <a class="el" href="utilities_8h_source.html">utilities.h</a>.</p>

</div>
</div>
<a id="a78e8ff3db7671b59028ba873086cfa32" name="a78e8ff3db7671b59028ba873086cfa32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78e8ff3db7671b59028ba873086cfa32">&#9670;&#160;</a></span>map_physical_to_raw()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int16_t utils::map_physical_to_raw </td>
          <td>(</td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceutils.html#a6ba012c3dd675cf1eabcf14e55cea0e0">UnitPrefix</a>&#160;</td>
          <td class="paramname"><em>prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>precision_bits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert an absolute physical <code>value</code>, expressed in some given measurement unit, scaled with <code>prefix</code>, into a raw measurement as if obtained from a electronics device, using <code>precision_bit</code> number of bits (that defines the device raw measure range); for this device, physical measures are within <code>range</code>. </p>
<p >Computations done by this method will be performed at compile-time as long as all provided arguments are constants; this is important as this will help optimize code size and execution time. This is useful when you want to compare physical values against meaningful limits, and perform actions based on these comparisons; instead of always converting measured raw values into physical ones and then compare with a physical limit, you do the opposite, compare the measured raw values against the raw limits (converted, at compile-time, from physical limits constants).</p>
<div class="fragment"><div class="line"><span class="comment">// This sample code use MPU6050 (accelerometer-gyroscope) support</span></div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacedevices_1_1magneto.html">devices::magneto</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespaceutils.html">utils</a>;</div>
<div class="line"><span class="comment">// These is the accelerometer range used in this code</span></div>
<div class="line"><span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">const</span> <a class="code hl_enumeration" href="namespacedevices_1_1magneto.html#a293a7ee50fc4bbf24e89858a328e1775">AccelRange</a> ACCEL_RANGE = AccelRange::RANGE_2G;</div>
<div class="line"><span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">const</span> uint16_t ACCEL_RANGE_IN_G = ACCEL_RANGE_G(ACCEL_RANGE);</div>
<div class="line"><span class="comment">// These are specific threshold values for acceleration</span></div>
<div class="line"><span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">const</span> int16_t ACCEL_1 = <a class="code hl_function" href="namespaceutils.html#a78e8ff3db7671b59028ba873086cfa32">map_physical_to_raw</a>(500, UnitPrefix::MILLI, ACCEL_RANGE_IN_G, 15);</div>
<div class="line"><span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">const</span> int16_t ACCEL_2 = <a class="code hl_function" href="namespaceutils.html#a78e8ff3db7671b59028ba873086cfa32">map_physical_to_raw</a>(1000, UnitPrefix::MILLI, ACCEL_RANGE_IN_G, 15);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This function performs an action based on current accelerometer value.</span></div>
<div class="line"><span class="keywordtype">void</span> check_accel(int16_t raw)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// We consider accelerations the same whatever the sign</span></div>
<div class="line">    <span class="keywordflow">if</span> (raw &lt; 0) raw = -raw;</div>
<div class="line">    <span class="keywordflow">if</span> (raw &lt; ACCEL_1)</div>
<div class="line">        act_when_low_accel();</div>
<div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (raw &lt; ACCEL_2)</div>
<div class="line">        act_when_mid_accel();</div>
<div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (raw &lt; ACCEL_2)</div>
<div class="line">        act_when_high_accel();</div>
<div class="line">}</div>
<div class="ttc" id="anamespaceutils_html_a78e8ff3db7671b59028ba873086cfa32"><div class="ttname"><a href="namespaceutils.html#a78e8ff3db7671b59028ba873086cfa32">utils::map_physical_to_raw</a></div><div class="ttdeci">constexpr int16_t map_physical_to_raw(int16_t value, UnitPrefix prefix, int16_t range, uint8_t precision_bits)</div><div class="ttdoc">Convert an absolute physical value, expressed in some given measurement unit, scaled with prefix,...</div><div class="ttdef"><b>Definition:</b> <a href="utilities_8h_source.html#l00292">utilities.h:292</a></div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the physical value to convert </td></tr>
    <tr><td class="paramname">prefix</td><td>the unit scale prefix in which <code>value</code> is expressed </td></tr>
    <tr><td class="paramname">range</td><td>the physical measure matching the maximum raw value </td></tr>
    <tr><td class="paramname">precision_bits</td><td>the number of significant bits of the raw value; only positive values are accounted, hence if a raw measure can be any value in [-32768;+32767], then <code>precision_bits</code> is <code>15</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the raw value calculated from <code>value</code>, as if directly returned by the device sensor </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceutils.html#a610e02474f969fc747fa1725b79e252c" title="Convert the raw value, obtained from an electronics device, using precision_bit number of bits (that ...">map_raw_to_physical()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="utilities_8h_source.html#l00292">292</a> of file <a class="el" href="utilities_8h_source.html">utilities.h</a>.</p>

</div>
</div>
<a id="ad5f19301125b8e9dc9e89ea50da962fa" name="ad5f19301125b8e9dc9e89ea50da962fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5f19301125b8e9dc9e89ea50da962fa">&#9670;&#160;</a></span>low_byte()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr uint8_t utils::low_byte </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>word</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extract the low order byte of a 16-bits word. </p>

<p class="definition">Definition at line <a class="el" href="utilities_8h_source.html#l00308">308</a> of file <a class="el" href="utilities_8h_source.html">utilities.h</a>.</p>

</div>
</div>
<a id="a84e5a79013cf3cf3c46a09b2c4861d37" name="a84e5a79013cf3cf3c46a09b2c4861d37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84e5a79013cf3cf3c46a09b2c4861d37">&#9670;&#160;</a></span>high_byte()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr uint8_t utils::high_byte </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>word</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extract the high order byte of a 16-bits word. </p>

<p class="definition">Definition at line <a class="el" href="utilities_8h_source.html#l00316">316</a> of file <a class="el" href="utilities_8h_source.html">utilities.h</a>.</p>

</div>
</div>
<a id="a9d48a47fd601d3b960ce55b26a4d5194" name="a9d48a47fd601d3b960ce55b26a4d5194"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d48a47fd601d3b960ce55b26a4d5194">&#9670;&#160;</a></span>as_uint16_t()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr uint16_t utils::as_uint16_t </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>high</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>low</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert 2 bytes into an unsigned int. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">high</td><td>the high byte </td></tr>
    <tr><td class="paramname">low</td><td>the low byte </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the unsigned integer computed from <code>high</code> and <code>low</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="utilities_8h_source.html#l00327">327</a> of file <a class="el" href="utilities_8h_source.html">utilities.h</a>.</p>

</div>
</div>
<a id="a3525bf2bf63c9f906bc9b952f0d54355" name="a3525bf2bf63c9f906bc9b952f0d54355"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3525bf2bf63c9f906bc9b952f0d54355">&#9670;&#160;</a></span>is_zero()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T utils::is_zero </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>default_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replace <code>value</code> by <code>default_value</code> if not "true" (also known as "Elvis 
operator"). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the value to check </td></tr>
    <tr><td class="paramname">default_value</td><td>the value to replace 0 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>value</code> if <code>value</code> is not false (or 0) otherwise <code>default_value</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="utilities_8h_source.html#l00339">339</a> of file <a class="el" href="utilities_8h_source.html">utilities.h</a>.</p>

</div>
</div>
<a id="a983d6f3839652d22e2353e7cfeff63af" name="a983d6f3839652d22e2353e7cfeff63af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a983d6f3839652d22e2353e7cfeff63af">&#9670;&#160;</a></span>set_mask()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void utils::set_mask </td>
          <td>(</td>
          <td class="paramtype">volatile T &amp;&#160;</td>
          <td class="paramname"><em>reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Common utility to force a part of the value of a register, designated by a bit mask. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type of values to handle </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reg</td><td>the value to change part of </td></tr>
    <tr><td class="paramname">mask</td><td>the bit mask indicating which bits shall change </td></tr>
    <tr><td class="paramname">value</td><td>the new value for <code>reg</code> </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="utilities_8h_source.html#l00352">352</a> of file <a class="el" href="utilities_8h_source.html">utilities.h</a>.</p>

</div>
</div>
<a id="a719f3f44a5cf8093953fbb97486bbee9" name="a719f3f44a5cf8093953fbb97486bbee9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a719f3f44a5cf8093953fbb97486bbee9">&#9670;&#160;</a></span>is_mask_equal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool utils::is_mask_equal </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>actual</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>expected</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Common utility to check if 2 values are equal according to a mask. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type of values to compare </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">actual</td><td>the actual value to compare </td></tr>
    <tr><td class="paramname">mask</td><td>the bit mask indicating which bits shall change </td></tr>
    <tr><td class="paramname">expected</td><td>the expected value </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="utilities_8h_source.html#l00364">364</a> of file <a class="el" href="utilities_8h_source.html">utilities.h</a>.</p>

</div>
</div>
<a id="af5b3426ba48caf5ee96ed71fa8b7bb5e" name="af5b3426ba48caf5ee96ed71fa8b7bb5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5b3426ba48caf5ee96ed71fa8b7bb5e">&#9670;&#160;</a></span>bcd_to_binary()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t utils::bcd_to_binary </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bcd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert Binary-coded decimal byte (each nibble is a digit from 0 to 9) into a natural byte. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bcd</td><td>the input using BCD format </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>bcd</code> converted to natural integer </dd></dl>

<p class="definition">Definition at line <a class="el" href="utilities_8h_source.html#l00375">375</a> of file <a class="el" href="utilities_8h_source.html">utilities.h</a>.</p>

</div>
</div>
<a id="a76076365828136f5178f279fb3c129de" name="a76076365828136f5178f279fb3c129de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76076365828136f5178f279fb3c129de">&#9670;&#160;</a></span>binary_to_bcd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t utils::binary_to_bcd </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>binary</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a natural integers to a BCD byte (2 digits). </p>
<p >Behavior is undefined if <code>binary</code> <code>&gt;99</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">binary</td><td>the natural integer value to convert to BCD; must be in range [0..99] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>binary</code> converted to BCD </dd></dl>

<p class="definition">Definition at line <a class="el" href="utilities_8h_source.html#l00389">389</a> of file <a class="el" href="utilities_8h_source.html">utilities.h</a>.</p>

</div>
</div>
<a id="a53f4a46843c0030ed1388d10c0ad6179" name="a53f4a46843c0030ed1388d10c0ad6179"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53f4a46843c0030ed1388d10c0ad6179">&#9670;&#160;</a></span>swap_bytes() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void utils::swap_bytes </td>
          <td>(</td>
          <td class="paramtype">uint16_t &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swap 2 bytes of a 2-bytes integer. </p>
<p >Useful to convert from big-endian to little-endian (AVR). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>value to convert in place (reference) </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="utilities_8h_source.html#l00405">405</a> of file <a class="el" href="utilities_8h_source.html">utilities.h</a>.</p>

</div>
</div>
<a id="aa520b3da671862f180de0fa3499ae293" name="aa520b3da671862f180de0fa3499ae293"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa520b3da671862f180de0fa3499ae293">&#9670;&#160;</a></span>swap_bytes() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void utils::swap_bytes </td>
          <td>(</td>
          <td class="paramtype">int16_t &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swap 2 bytes of a 2-bytes integer. </p>
<p >Useful to convert from big-endian to little-endian (AVR). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>value to convert in place (reference) </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="utilities_8h_source.html#l00415">415</a> of file <a class="el" href="utilities_8h_source.html">utilities.h</a>.</p>

</div>
</div>
<a id="a25cf0b4e16f41600e112ba90f41c2e1f" name="a25cf0b4e16f41600e112ba90f41c2e1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25cf0b4e16f41600e112ba90f41c2e1f">&#9670;&#160;</a></span>swap_bytes() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void utils::swap_bytes </td>
          <td>(</td>
          <td class="paramtype">uint32_t &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reverse 4 bytes of a 4-bytes integer. </p>
<p >Useful to convert from big-endian to little-endian (AVR). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>value to convert in place (reference) </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="utilities_8h_source.html#l00425">425</a> of file <a class="el" href="utilities_8h_source.html">utilities.h</a>.</p>

</div>
</div>
<a id="aa14a9a9958ae56f2a8d63ec2a0591cf9" name="aa14a9a9958ae56f2a8d63ec2a0591cf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa14a9a9958ae56f2a8d63ec2a0591cf9">&#9670;&#160;</a></span>swap_bytes() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void utils::swap_bytes </td>
          <td>(</td>
          <td class="paramtype">int32_t &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reverse 4 bytes of a 4-bytes integer. </p>
<p >Useful to convert from big-endian to little-endian (AVR). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>value to convert in place (reference) </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="utilities_8h_source.html#l00439">439</a> of file <a class="el" href="utilities_8h_source.html">utilities.h</a>.</p>

</div>
</div>
<a id="ad646807311bd7bcd02d6af12e3b51934" name="ad646807311bd7bcd02d6af12e3b51934"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad646807311bd7bcd02d6af12e3b51934">&#9670;&#160;</a></span>swap_bytes() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void utils::swap_bytes </td>
          <td>(</td>
          <td class="paramtype">uint64_t &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reverse 8 bytes of a 8-bytes integer. </p>
<p >Useful to convert from big-endian to little-endian (AVR). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>value to convert in place (reference) </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="utilities_8h_source.html#l00449">449</a> of file <a class="el" href="utilities_8h_source.html">utilities.h</a>.</p>

</div>
</div>
<a id="aafea56db3de82001ff9c5e40f8357ab6" name="aafea56db3de82001ff9c5e40f8357ab6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafea56db3de82001ff9c5e40f8357ab6">&#9670;&#160;</a></span>swap_bytes() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void utils::swap_bytes </td>
          <td>(</td>
          <td class="paramtype">int64_t &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reverse 8 bytes of a 8-bytes integer. </p>
<p >Useful to convert from big-endian to little-endian (AVR). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>value to convert in place (reference) </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="utilities_8h_source.html#l00463">463</a> of file <a class="el" href="utilities_8h_source.html">utilities.h</a>.</p>

</div>
</div>
<a id="a4b22c789724a654df1a1efba8b3b6083" name="a4b22c789724a654df1a1efba8b3b6083"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b22c789724a654df1a1efba8b3b6083">&#9670;&#160;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void utils::swap </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swap the values of 2 variables passed by reference. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type of variables to swap </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>reference to the first variable </td></tr>
    <tr><td class="paramname">b</td><td>reference to the second variable </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="utilities_8h_source.html#l00475">475</a> of file <a class="el" href="utilities_8h_source.html">utilities.h</a>.</p>

</div>
</div>
<a id="a8122a1acb9aff2f2cd1d4ae7e1e99ac9" name="a8122a1acb9aff2f2cd1d4ae7e1e99ac9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8122a1acb9aff2f2cd1d4ae7e1e99ac9">&#9670;&#160;</a></span>as_uint8_t()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr uint8_t utils::as_uint8_t </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cast a one byte long bit-fields struct into a byte. </p>
<p >Useful when dealing with devices registers (bytes) where each bit has a specific meaning which you want to clarify through a bitfield struct. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the bit field struct value to convert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>input</code> casted as a byte </dd></dl>

<p class="definition">Definition at line <a class="el" href="utilities_8h_source.html#l00506">506</a> of file <a class="el" href="utilities_8h_source.html">utilities.h</a>.</p>

</div>
</div>
<a id="a56da5697e356f76ec2e4061279ca0254" name="a56da5697e356f76ec2e4061279ca0254"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56da5697e356f76ec2e4061279ca0254">&#9670;&#160;</a></span>as_array()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U  = uint8_t[sizeof(T)]&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void utils::as_array </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cast an instance of type <code>T</code> to an array of <code>uint8_t</code> of the size of <code>T</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type of <code>input</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>a constant reference to the instance to cast to an array </td></tr>
    <tr><td class="paramname">output</td><td>a pointer to an array of the size of <code>T</code> </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="utilities_8h_source.html#l00518">518</a> of file <a class="el" href="utilities_8h_source.html">utilities.h</a>.</p>

</div>
</div>
<a id="a6ed4721feb889faa1f72fc2629d71271" name="a6ed4721feb889faa1f72fc2629d71271"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ed4721feb889faa1f72fc2629d71271">&#9670;&#160;</a></span>calculate_delay1_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr uint8_t utils::calculate_delay1_count </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>time_us</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the count to pass to <code>delay1()</code> in order to reach <code>time_us</code> microseconds delay. </p>
<p >Calculation is performed at compile-time, provided that <code>time_us</code> is a constant when the method is called. This is to avoid dragging huge mathematics libraries if it can be avoided. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">time_us</td><td>the time to reach through <code>delay1()</code> AVR function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the count to pass to <code>delay1()</code> AVR function </dd></dl>

<p class="definition">Definition at line <a class="el" href="utilities_8h_source.html#l00531">531</a> of file <a class="el" href="utilities_8h_source.html">utilities.h</a>.</p>

</div>
</div>
<a id="aadb785961c9199701ce9025177b243c6" name="aadb785961c9199701ce9025177b243c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadb785961c9199701ce9025177b243c6">&#9670;&#160;</a></span>num_bits()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr uint8_t utils::num_bits </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>num</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the number of <code>1</code> bits in a byte. </p>
<p >Calculation is performed at compile-time, provided that <code>mask</code> is a constant when the method is called. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mask</td><td>the byte which you want to count the number of <code>1</code> bits </td></tr>
    <tr><td class="paramname">num</td><td>used internally, always use default value for this argument! </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="utilities_8h_source.html#l00542">542</a> of file <a class="el" href="utilities_8h_source.html">utilities.h</a>.</p>

</div>
</div>
<a id="a233bddd8743dd54547e9b36c1e58ef2f" name="a233bddd8743dd54547e9b36c1e58ef2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a233bddd8743dd54547e9b36c1e58ef2f">&#9670;&#160;</a></span>change_endianness()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T utils::change_endianness </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Change endianness of any integral type (from big to small or small to big). </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type fo <code>value</code>; if not an integral type, the function will do nothing; only 16 bits and 32 bits integral types are currently supported. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the value which endianness shall be reverted </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value with reverted endianness if an integer; otherwise, value is returned unchanged. </dd></dl>

<p class="definition">Definition at line <a class="el" href="utilities_8h_source.html#l00560">560</a> of file <a class="el" href="utilities_8h_source.html">utilities.h</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceutils.html">utils</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5 </li>
  </ul>
</div>
</body>
</html>
