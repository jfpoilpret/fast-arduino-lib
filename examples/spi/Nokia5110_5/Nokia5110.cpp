//   Copyright 2016-2023 Jean-Francois Poilpret
//
//   Licensed under the Apache License, Version 2.0 (the "License");
//   you may not use this file except in compliance with the License.
//   You may obtain a copy of the License at
//
//       http://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.

/*
 * Program to debug a weird issue with display refresh of Nokia 5110.
 * This focuses on the seimplest way to repduce the issue then add debugging options.
 * 
 * PCD8544 chip is using 3.3V levels max. Several breakouts exist (e.g. Adafruit), 
 * but most of them (all?) do not include level converters.
 * It is highly suggested to use level converters (5V->3.3V, no need for bidir)
 * for all logical signals.
 * 
 * I generally use CD74HC4050 CMOS circuit which can be used to lower 6 digital 
 * signals from 5V to 3.3V (PCD8544 needs 5 signals).
 * Most breakouts also include backlighting LEDs which current must be restricted
 * according to breakout datasheet.
 * 
 * Wiring: 
 * - on ATmega328P based boards (including Arduino UNO):
 *   - D13 (SCK): connected to 5110 breakout SCLK pin (via level converter)
 *   - D11 (MOSI): connected to 5110 breakout DN pin (via level converter)
 *   - D10 (SS): connected to 5110 breakout SCE pin (via level converter)
 *   - D9: connected to 5110 breakout D/C pin (via level converter)
 *   - D8: connected to 5110 breakout RST pin (via level converter)
 *   - 5110 breakout LED pin connected to 3.3V via 330 resistor
 */

#include <fastarduino/bits.h>
#include <fastarduino/devices/lcd5110.h>
#include <fastarduino/devices/display.h>
#include <fastarduino/time.h>
#include <fastarduino/iomanip.h>
#include <fastarduino/uart.h>

#ifndef ARDUINO_UNO
#error "Current target is not supported!"
#endif

// For testing we use default SS pin as CS
static constexpr const board::DigitalPin CS = board::DigitalPin::D10_PB2;
static constexpr const board::DigitalPin DC = board::DigitalPin::D9_PB1;
static constexpr const board::DigitalPin RES = board::DigitalPin::D8_PB0;

// Debug through UART
static const constexpr board::USART UART = board::USART::USART0;
#define USART_NUM 0

// Buffers for UART
static const uint8_t OUTPUT_BUFFER_SIZE = 64;
static char output_buffer[OUTPUT_BUFFER_SIZE];
REGISTER_UATX_ISR(USART_NUM)
REGISTER_OSTREAMBUF_LISTENERS(serial::hard::UATX<UART>)

using NOKIA = devices::display::LCD5110<CS, DC, RES>;
using DISPLAY = devices::display::Display<NOKIA>;
using devices::display::Mode;
using streams::endl, streams::setw, streams::hex, streams::dec, streams::flush;

static constexpr uint16_t BLINK_MS = 250;
static constexpr uint16_t DEBUG_MS = 2000;

static constexpr uint8_t ROW_HEIGHT = 8;
static constexpr uint8_t ROWS = DISPLAY::HEIGHT / ROW_HEIGHT;
static constexpr uint8_t COLS = DISPLAY::WIDTH;
static constexpr uint16_t RASTER_SIZE = ROWS * COLS;

static constexpr uint8_t RECT_LEFT		= 30;
static constexpr uint8_t RECT_RIGHT		= 55;
static constexpr uint8_t RECT_TOP		= 35;
static constexpr uint8_t RECT_BOTTOM	= 45;

static constexpr uint8_t REF_RASTER[] = {
	0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
	0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
	0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
	0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
	0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
	0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x1f,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
};

static bool is_raster_empty(const uint8_t* raster)
{
	bool fully_zero = true;
	for (uint16_t i = 0; i < RASTER_SIZE; ++i)
		if (raster[i])
		{
			fully_zero = false;
			break;
		}
	return fully_zero;
}

static bool is_raster_equal_ref(const uint8_t* raster)
{
	for (uint16_t i = 0; i < RASTER_SIZE; ++i)
		if (raster[i] != REF_RASTER[i])
			return false;
	return true;
}

static void debug_raster(streams::ostream& out, const uint8_t* raster)
{
	for (uint8_t row = 0; row < ROWS; ++row)
	{
		// out << setw(3) << dec << row << F(": ") << flush;
		for (uint8_t col = 0; col < COLS; ++col)
		{
			out << F("0x") << hex << raster[row * COLS + col] << ',' << flush;
		}
		out << endl;
	}
	out << '\n' << endl;
}

int main()
{
	board::init();
	sei();

	// Setup traces
	serial::hard::UATX<UART> uatx{output_buffer};
	uatx.begin(115200);
	streams::ostream out = uatx.out();

	// Start SPI interface
	spi::init();
	
	// Start or init SPI device if needed
	DISPLAY nokia;
	nokia.reset();
	nokia.set_display_bias();
	nokia.set_display_contrast();
	nokia.normal();
	nokia.power_up();

	nokia.set_draw_mode({Mode::NO_CHANGE, true});
	nokia.set_fill_mode({Mode::XOR, true});
	while(true)
	{
		nokia.draw_rectangle({RECT_LEFT, RECT_TOP}, {RECT_RIGHT, RECT_BOTTOM});
		// Check invalid area encompasses rectangle => looks always OK!
		const auto& invalid = nokia.invalid_area();
		if (invalid.empty || invalid.x1 != RECT_LEFT || invalid.y1 != RECT_TOP
			|| invalid.x2 != RECT_RIGHT || invalid.y2 != RECT_BOTTOM)
		{
			// Debug invalid area
			out << dec << F("InvalidArea(") << invalid.empty << ','
				<< invalid.x1 << ',' << invalid.y1 << ','
				<< invalid.x2 << ',' << invalid.y2 << ')' << endl;
		}

		//TODO Check raster has consistent rectangle area: either all 0 or not
		const uint8_t* raster = nokia.raster();
		if ((!is_raster_empty(raster)) && !is_raster_equal_ref(raster))
		{
			debug_raster(out, raster);
		}

		nokia.update();
		time::delay_ms(BLINK_MS);
	}
}
